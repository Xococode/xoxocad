<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XOCOCAD - Pantalla Completa</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            background-color: #1e1e1e;
            color: #d4d4d4;
        }

        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            width: 100vw;
            background-color: #1e1e1e;
        }

        .top-interface-area {
            background-color: #252526;
            padding: 8px 15px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            z-index: 100;
            display: flex;
            flex-direction: column;
            align-items: center;
            flex-shrink: 0;
        }

        .top-interface-area h1 {
            margin: 0 0 8px 0;
            font-size: 1.1em;
            color: #cccccc;
            font-weight: 500;
        }

        .controls, .references-panel {
            margin-bottom: 8px;
            padding: 8px;
            border: 1px solid #3c3c3c;
            border-radius: 4px;
            background-color: #2d2d2d;
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            justify-content: center;
            width: fit-content;
            max-width: 95%;
        }

        .controls button, .controls select {
            margin: 4px;
            padding: 6px 10px;
            border: 1px solid #4a4a4a;
            border-radius: 3px;
            background-color: #3c3c3c;
            color: #cccccc;
            cursor: pointer;
            font-size: 0.85em;
            transition: background-color 0.2s ease;
        }
        .controls button .icon { margin-right: 5px; }

        .controls button.active {
            background-color: #007acc;
            border-color: #005f99;
            color: white;
        }
        .controls button.edit-mode-active {
            background-color: #b87333; /* Un color distintivo para el modo edici√≥n */
            border-color: #8c531e;
            color: white;
        }
        .controls button:hover, .controls select:hover {
            background-color: #4f4f4f;
        }
        .controls button:disabled {
            background-color: #333333;
            color: #6a6a6a;
            cursor: not-allowed;
        }

        .controls .ayudas-label, .controls .spline-options-label, .controls .offset-label, .controls .dimension-label {
            margin-left: 10px;
            margin-right: 5px;
            font-weight: bold;
            font-size: 0.85em;
            color: #a0a0a0;
        }
        .spline-options, .offset-options { display: contents; } /* Para que los elementos internos se alineen bien en flex */
        .offset-controls { display: flex; align-items: center; margin: 0 4px; }
        .offset-controls span { margin-right: 5px; font-size: 0.85em; color: #a0a0a0;}
        .offset-controls input[type="number"] {
            width: 50px; padding: 5px; border: 1px solid #4a4a4a; border-radius: 3px;
            box-sizing: border-box; font-size: 0.85em; background-color: #3c3c3c; color: #cccccc;
        }
        .offset-side-btn {
            padding: 5px 7px; margin: 0 2px; background-color: #333; border: 1px solid #4a4a4a;
            border-radius: 3px; cursor: pointer; font-size: 0.8em; color: #b0b0b0;
        }
        .offset-side-btn.active { background-color: #007acc; border-color: #005f99; font-weight: bold; color: white; }

        .references-panel h3 {
            margin-top: 0; margin-bottom: 8px; font-size: 0.9em; text-align: center; color: #a0a0a0;
        }
        .references-group { display: flex; flex-wrap: wrap; justify-content: center; }
        .reference-checkbox { display: flex; align-items: center; margin-right: 10px; margin-bottom: 5px; font-size: 0.8em; color: #b0b0b0; }
        .reference-checkbox input { margin-right: 4px; transform: scale(0.9); accent-color: #007acc; }


        #canvasContainer {
            flex-grow: 1;
            position: relative; /* Necesario para posicionar elementos hijos absolutos */
            width: 100%;
            background-color: #22252b; /* Un poco m√°s oscuro que el fondo general para contraste */
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #cadCanvas {
            border: none; /* Sin borde para el canvas */
            display: block; /* Para quitar espacio extra debajo */
            width: 100%;
            height: 100%;
            background-color: transparent; /* El fondo lo da el contenedor */
        }

        /* Indicador de Snap */
        #snapIndicator {
            position: absolute;
            /*left: 0; top: 0;  Se establecer√° con JS */
            pointer-events: none; /* Para que no interfiera con los clics en el canvas */
            opacity: 0;
            transition: opacity 0.1s ease;
            z-index: 110; /* Encima del canvas pero debajo de otros popups si los hubiera */
        }
        .snap-text {
            position: absolute;
            background-color: rgba(60, 60, 60, 0.95); /* Fondo semitransparente oscuro */
            border: 1px solid #555;
            border-radius: 3px;
            padding: 3px 6px;
            font-size: 11px;
            color: #e0e0e0; /* Texto claro */
            pointer-events: none;
            white-space: nowrap;
            transform: translate(15px, -20px); /* Ajusta la posici√≥n relativa al punto de snap */
        }

        /* Mensaje de estado de la herramienta */
        #toolStatus {
            margin-top: 5px;
            font-size: 0.8em;
            color: #b0b0b0;
            min-height: 18px; /* Para que no salte la UI si el texto est√° vac√≠o */
            padding: 4px 8px;
            border-radius: 4px;
            background-color: #2d2d2d;
            border: 1px solid #3c3c3c;
            text-align: center;
            width: fit-content;
            max-width: 90%;
        }
        
        /* Div para mostrar valores de transformaci√≥n (rotaci√≥n/escala) */
        #transformValues {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(45,45,45,0.85);
            color: #d4d4d4;
            padding: 5px 10px;
            border-radius: 4px;
            border: 1px solid #3c3c3c;
            font-size: 0.85em;
            display: none; /* Se mostrar√°/ocultar√° con JavaScript */
            z-index: 200;
            box-shadow: 0 1px 3px rgba(0,0,0,0.5);
        }

        /* Estilos para la UI compacta */
        .top-interface-area.compact-ui h1,
        .top-interface-area.compact-ui .references-panel,
        .top-interface-area.compact-ui #toolStatus {
            display: none;
        }

        .top-interface-area.compact-ui {
            padding-top: 5px;
            padding-bottom: 5px;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="top-interface-area">
            <h1>XOCONODO CAD</h1>
            <div class="controls">
                <!-- Herramientas de Selecci√≥n y Dibujo B√°sico -->
                <button id="selectToolBtn"><span class="icon">üñêÔ∏è</span>Seleccionar</button>
                <button id="lineToolBtn"><span class="icon">üìè</span>L√≠nea</button>
                <button id="circleToolBtn"><span class="icon">‚≠ï</span>C√≠rculo</button>
                <button id="arcToolBtn"><span class="icon">‚åí</span>Arco (3P)</button>
                <button id="arcCenterStartEndToolBtn"><span class="icon">üéØ</span>Arco (C,I,F)</button>
                <button id="splineToolBtn"><span class="icon">„Ä∞Ô∏è</span>Spline</button>
                <button id="pointToolBtn"><span class="icon">üìç</span>Punto</button>
                <button id="rectangleToolBtn"><span class="icon">‚ñ≠</span>Rect√°ngulo</button>
                <button id="ellipseToolBtn"><span class="icon">‚¨¨</span>Elipse</button>
                <button id="hexagonToolBtn"><span class="icon">‚¨°</span>Hex√°gono</button>
                <button id="starToolBtn"><span class="icon">‚≠ê</span>Estrella</button>
                <button id="editPointsBtn" style="display:none;"><span class="icon">‚úé</span>Editar Geometr√≠a</button>
                
                <!-- Herramientas de Modificaci√≥n -->
                <button id="offsetToolBtn"><span class="icon">‚éé</span>Equidistancia</button>
                <button id="trimToolBtn"><span class="icon">‚úÇÔ∏è</span>Recortar</button>
                <button id="extendToolBtn"><span class="icon">‚ÜîÔ∏è</span>Alargar</button>
                <button id="rotateToolBtn"><span class="icon">üîÑ</span>Rotar</button>
                <button id="scaleToolBtn"><span class="icon">‚ÜîÔ∏è‚ÜïÔ∏è</span>Escalar</button>

                <!-- Herramientas de Acotaci√≥n -->
                <span class="dimension-label">Acotaci√≥n:</span>
                <button id="dimHorizontalBtn"><span class="icon">‚¨å</span>Cota H</button>
                <button id="dimVerticalBtn"><span class="icon">‚¨ç</span>Cota V</button>
                <button id="dimRadiusBtn"><span class="icon">‚åÄ</span>Cota Radio</button>

                <!-- Controles espec√≠ficos de herramientas -->
                <div class="offset-controls" id="offsetControlsContainer" style="display:none;">
                    <span class="offset-label">Equidistancia:</span>
                    <span>Dist:</span>
                    <input type="number" id="offsetDistanceInput" value="10" step="1" min="0.1" />
                    <span style="margin-left: 5px;">Lado:</span>
                    <button id="offsetLeftBtn" class="offset-side-btn active">Izq</button>
                    <button id="offsetRightBtn" class="offset-side-btn">Der</button>
                    <button id="offsetBothBtn" class="offset-side-btn">Ambos</button>
                </div>

                <div class="spline-options" id="splineOptionsContainer" style="display:none;">
                    <span class="spline-options-label" id="splineOptionsLabel">Spline:</span>
                    <select id="splineInterpolationSelect">
                        <option value="cardinal" selected>Cardinal</option>
                        <option value="linear">Lineal</option>
                        <option value="bezier">Bezier</option>
                        <option value="catmull-rom">Catmull-Rom</option>
                    </select>
                </div>

                <!-- Acciones Generales y Ayudas -->
                <button id="clearBtn"><span class="icon">üóëÔ∏è</span>Limpiar</button>
                <button id="saveFileBtn"><span class="icon">üíæ</span>Guardar</button>
                <button id="openFileBtn"><span class="icon">üìÇ</span>Abrir</button>
                <span class="ayudas-label">Ayudas:</span>
                <button id="snapToGridBtn"><span class="icon">‚ñ¶</span>Rejilla Off</button>
                <button id="orthoModeBtn"><span class="icon">üìê</span>Orto Off</button>
                <button id="toggleUIModeBtn" title="Alternar interfaz compacta"><span class="icon">‚öôÔ∏è</span>UI</button>
            </div>

            <div class="references-panel">
                <h3>Referencias a Objetos:</h3>
                <div class="references-group">
                    <label class="reference-checkbox"><input type="checkbox" id="refEndpoint" checked>P. Final</label>
                    <label class="reference-checkbox"><input type="checkbox" id="refMidpoint">P. Medio</label>
                    <label class="reference-checkbox"><input type="checkbox" id="refCenter" checked>Centro</label>
                    <label class="reference-checkbox"><input type="checkbox" id="refQuadrant">Cuadrante</label>
                    <label class="reference-checkbox"><input type="checkbox" id="refIntersection" checked>Intersecci√≥n</label>
                    <label class="reference-checkbox"><input type="checkbox" id="refTangent">Tangente</label>
                    <label class="reference-checkbox"><input type="checkbox" id="refNearest">Cercano</label>
                </div>
            </div>
            <div id="toolStatus">Herramienta actual: Seleccionar Objeto</div>
        </div>

        <div id="canvasContainer">
            <canvas id="cadCanvas"></canvas>
            <div id="snapIndicator"></div> <!-- Para el texto y el s√≠mbolo de snap -->
            <div id="transformValues"></div> <!-- Para mostrar √°ngulo/factor de transformaci√≥n -->
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('cadCanvas');
            const canvasContainer = document.getElementById('canvasContainer');
            const ctx = canvas.getContext('2d');
            const toolStatusDiv = document.getElementById('toolStatus');
            const snapIndicatorDiv = document.getElementById('snapIndicator');
            let transformValuesDiv = null; // Se inicializar√° en initTransformTools

            // Referencias a botones y controles de la UI
            const selectToolBtn = document.getElementById('selectToolBtn');
            const lineToolBtn = document.getElementById('lineToolBtn');
            const circleToolBtn = document.getElementById('circleToolBtn');
            const arcToolBtn = document.getElementById('arcToolBtn'); 
            const arcCenterStartEndToolBtn = document.getElementById('arcCenterStartEndToolBtn');
            const splineToolBtn = document.getElementById('splineToolBtn');
            const pointToolBtn = document.getElementById('pointToolBtn');
            const rectangleToolBtn = document.getElementById('rectangleToolBtn');
            const ellipseToolBtn = document.getElementById('ellipseToolBtn');
            const hexagonToolBtn = document.getElementById('hexagonToolBtn');
            const starToolBtn = document.getElementById('starToolBtn');
            const editPointsBtn = document.getElementById('editPointsBtn');
            const offsetToolBtn = document.getElementById('offsetToolBtn');
            const trimToolBtn = document.getElementById('trimToolBtn');
            const extendToolBtn = document.getElementById('extendToolBtn');
            const rotateToolBtn = document.getElementById('rotateToolBtn');
            const scaleToolBtn = document.getElementById('scaleToolBtn');

            const dimHorizontalBtn = document.getElementById('dimHorizontalBtn');
            const dimVerticalBtn = document.getElementById('dimVerticalBtn');
            const dimRadiusBtn = document.getElementById('dimRadiusBtn');

            const offsetControlsContainer = document.getElementById('offsetControlsContainer');
            const offsetDistanceInput = document.getElementById('offsetDistanceInput');
            const offsetLeftBtn = document.getElementById('offsetLeftBtn');
            const offsetRightBtn = document.getElementById('offsetRightBtn');
            const offsetBothBtn = document.getElementById('offsetBothBtn');
            const clearBtn = document.getElementById('clearBtn');
            const saveFileBtn = document.getElementById('saveFileBtn'); // Bot√≥n Guardar
            const openFileBtn = document.getElementById('openFileBtn'); // Bot√≥n Abrir
            const snapToGridBtn = document.getElementById('snapToGridBtn');
            const orthoModeBtn = document.getElementById('orthoModeBtn');

            const splineOptionsContainer = document.getElementById('splineOptionsContainer');
            const splineInterpolationSelect = document.getElementById('splineInterpolationSelect');

            // Referencias a checkboxes de snap
            const refEndpointCb = document.getElementById('refEndpoint');
            const refMidpointCb = document.getElementById('refMidpoint');
            const refCenterCb = document.getElementById('refCenter');
            const refQuadrantCb = document.getElementById('refQuadrant');
            const refIntersectionCb = document.getElementById('refIntersection');
            const refTangentCb = document.getElementById('refTangent');
            const refNearestCb = document.getElementById('refNearest');
            
            // UI Compacta
            const topInterfaceArea = document.querySelector('.top-interface-area');
            const toggleUIModeBtn = document.getElementById('toggleUIModeBtn');
            let isCompactUI = false;

            // Input de archivo (oculto)
            let fileInput; 
            fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.accept = '.json,.xoccad';
            fileInput.style.display = 'none';
            document.body.appendChild(fileInput);


            // Constantes de dibujo y comportamiento
            const GRID_SIZE = 20;
            const HIT_TOLERANCE_SCREEN = 6; 
            const CONTROL_POINT_RADIUS_SCREEN = 5; 
            const SNAP_TOLERANCE_SCREEN = 15; 
            const SNAP_SYMBOL_SIZE = 8; 
            const TRANSFORM_HANDLE_VISUAL_RADIUS = 50; 

            // Constantes para acotaci√≥n
            const DIM_TEXT_SIZE_SCREEN = 10;
            const DIM_OFFSET_FROM_LINE_SCREEN = 3;
            const DIM_EXT_LINE_GAP_SCREEN = 2;    
            const DIM_EXT_LINE_OVERSHOOT_SCREEN = 3;
            const DIM_ARROW_SIZE_SCREEN = 5;
            const DIM_COLOR = '#569cd6'; 
            const DIM_SELECTED_COLOR = '#c586c0'; 


            // Variables de estado
            let currentTool = 'select';
            let drawing = false; 
            let startPoint = null;         
            let definingPoint2 = null;     
            let arcCenterPoint = null;     
            let ellipseCenter = null;
            let ellipseRadiusXPoint = null;
            let starNumPoints = 5; 
            let starInnerRadiusFactor = 0.5; 

            // Estado para herramientas de transformaci√≥n (rotar, escalar)
            let transformState = {
                active: false, mode: null, 
                center: null, objectsToTransform: [], originalObjectStates: new Map(),
                dragStartPoint: null, 
                currentAngleRad: 0, initialHandleAngleRad: 0, 
                currentFactor: 1, initialHandleDistance: 1, 
                uniformScale: true, 
                showHandles: true,
                snapAngleDeg: 15, snapScaleFactor: 0.1, isSnapping: false 
            };

            let currentSplinePoints = [];
            let currentSplineInterpolation = 'cardinal'; 
            
            let objects = []; 
            let nextObjectId = 1;
            let selectedObjectIds = []; 
            
            let dimensions = []; 
            let nextDimensionId = 1;
            let selectedDimensionIds = []; 

            let mousePosWorld = { x: 0, y: 0 }; 
            let currentSnap = null; 

            let isDraggingObject = false; 
            let dragStartMousePos_World = null; 
            let dragStartObjectPositions = new Map(); 
            let dragStartDimensionData = new Map(); 


            // Variables para zoom y paneo
            let scale = 1.0;
            const MIN_SCALE = 0.1; const MAX_SCALE = 10.0;
            let offsetCanvas = { x: 0, y: 0 }; 

            let isPanning = false;
            let panStartMousePos_Screen = null; 

            // Variables para ayudas al dibujo
            let snapToGridEnabled = false;
            let orthoModeEnabled = false;

            // Variables para el modo de edici√≥n de puntos
            let editModeActive = false;
            let editableObject = null; 
            let controlPointHandles = []; 
            let isDraggingControlPoint = false; 
            let dragStartHandlePositions = new Map(); 

            // Variables para la herramienta de equidistancia (offset)
            let objectToOffset = null;
            let offsetPreviewObjects = [];
            let offsetSide = "left"; 

            // Variables para la herramienta de recortar (trim)
            let trimState = { phase: 0, boundaries: [], objectToTrimId: null, intersections: [], previewSegment: null };
            let extendState = { objectToExtendId: null, boundaryId: null, whichEnd: null, previewPoint: null, possibleExtensions: [] };
            let lastKnownMouseScreenPos = {x: 0, y: 0}; 

            // --- FUNCIONES DE TRANSFORMACI√ìN (ROTAR/ESCALAR) ---
            function rotatePoint(point, center, angleRad) {
                const s = Math.sin(angleRad); const c = Math.cos(angleRad);
                const px = point.x - center.x; const py = point.y - center.y;
                const xnew = px * c - py * s; const ynew = px * s + py * c;
                return { x: xnew + center.x, y: ynew + center.y };
            }

            function scalePoint(point, base, factor) {
                const newX = base.x + (point.x - base.x) * factor;
                const newY = base.y + (point.y - base.y) * factor;
                return { x: newX, y: newY };
            }
             function applyRotationToObjects(objectList, center, angleRad) {
                objectList.forEach(objId => {
                    const obj = objects.find(o => o.id === objId);
                    if (!obj) return;

                    if (obj.type === 'line') {
                        const p1 = rotatePoint({ x: obj.startX, y: obj.startY }, center, angleRad);
                        const p2 = rotatePoint({ x: obj.endX, y: obj.endY }, center, angleRad);
                        obj.startX = p1.x; obj.startY = p1.y; obj.endX = p2.x; obj.endY = p2.y;
                    } else if (obj.type === 'circle' || obj.type === 'ellipse') {
                        const newCenter = rotatePoint({ x: obj.centerX, y: obj.centerY }, center, angleRad);
                        obj.centerX = newCenter.x; obj.centerY = newCenter.y;
                        if (obj.type === 'ellipse') { obj.rotation = (obj.rotation || 0) + angleRad; }
                    } else if (obj.type === 'arc' || obj.type === 'arcCenterStartEnd') {
                        const newCenter = rotatePoint({ x: obj.centerX, y: obj.centerY }, center, angleRad);
                        obj.centerX = newCenter.x; obj.centerY = newCenter.y;
                        obj.startAngle += angleRad; obj.endAngle += angleRad;
                        if(obj.p1) obj.p1 = rotatePoint(obj.p1, center, angleRad);
                        if(obj.p2) obj.p2 = rotatePoint(obj.p2, center, angleRad);
                        if(obj.p3) obj.p3 = rotatePoint(obj.p3, center, angleRad);
                        if(obj.pCenter) obj.pCenter = rotatePoint(obj.pCenter, center, angleRad);
                        if(obj.pStart) obj.pStart = rotatePoint(obj.pStart, center, angleRad);
                        if(obj.pEnd) obj.pEnd = rotatePoint(obj.pEnd, center, angleRad);
                    } else if (obj.type === 'spline' || obj.type === 'hexagon' || obj.type === 'star') {
                        obj.points = obj.points.map(p => rotatePoint(p, center, angleRad));
                        if (obj.centerX !== undefined && obj.centerY !== undefined) { 
                            const newPolyCenter = rotatePoint({x: obj.centerX, y: obj.centerY}, center, angleRad);
                            obj.centerX = newPolyCenter.x; obj.centerY = newPolyCenter.y;
                        }
                    } else if (obj.type === 'point') {
                        const newPt = rotatePoint({ x: obj.x, y: obj.y }, center, angleRad);
                        obj.x = newPt.x; obj.y = newPt.y;
                    } else if (obj.type === 'rectangle') { 
                        const p1 = {x: obj.x, y: obj.y};
                        const p2 = {x: obj.x + obj.width, y: obj.y};
                        const p3 = {x: obj.x + obj.width, y: obj.y + obj.height};
                        const p4 = {x: obj.x, y: obj.y + obj.height};
                        const rp1 = rotatePoint(p1, center, angleRad); const rp2 = rotatePoint(p2, center, angleRad);
                        const rp3 = rotatePoint(p3, center, angleRad); const rp4 = rotatePoint(p4, center, angleRad);
                        const minX = Math.min(rp1.x, rp2.x, rp3.x, rp4.x); const minY = Math.min(rp1.y, rp2.y, rp3.y, rp4.y);
                        const maxX = Math.max(rp1.x, rp2.x, rp3.x, rp4.x); const maxY = Math.max(rp1.y, rp2.y, rp3.y, rp4.y);
                        obj.x = minX; obj.y = minY; obj.width = maxX - minX; obj.height = maxY - minY;
                    }
                });
            }

            function applyScalingToObjects(objectList, basePoint, factor, uniform = true) { 
                objectList.forEach(objId => {
                    const obj = objects.find(o => o.id === objId);
                    if (!obj) return;

                    if (obj.type === 'line') {
                        const p1 = scalePoint({ x: obj.startX, y: obj.startY }, basePoint, factor);
                        const p2 = scalePoint({ x: obj.endX, y: obj.endY }, basePoint, factor);
                        obj.startX = p1.x; obj.startY = p1.y; obj.endX = p2.x; obj.endY = p2.y;
                    } else if (obj.type === 'circle') {
                        const newCenter = scalePoint({ x: obj.centerX, y: obj.centerY }, basePoint, factor);
                        obj.centerX = newCenter.x; obj.centerY = newCenter.y;
                        obj.radius = Math.max(0.1/scale, obj.radius * factor); 
                    } else if (obj.type === 'ellipse') {
                        const newCenter = scalePoint({ x: obj.centerX, y: obj.centerY }, basePoint, factor);
                        obj.centerX = newCenter.x; obj.centerY = newCenter.y;
                        obj.radiusX = Math.max(0.1/scale, obj.radiusX * factor); 
                        obj.radiusY = Math.max(0.1/scale, obj.radiusY * factor);
                    } else if (obj.type === 'arc' || obj.type === 'arcCenterStartEnd') {
                        const newCenter = scalePoint({ x: obj.centerX, y: obj.centerY }, basePoint, factor);
                        obj.centerX = newCenter.x; obj.centerY = newCenter.y;
                        obj.radius = Math.max(0.1/scale, obj.radius * factor);
                        if(obj.p1) obj.p1 = scalePoint(obj.p1, basePoint, factor);
                        if(obj.p2) obj.p2 = scalePoint(obj.p2, basePoint, factor);
                        if(obj.p3) obj.p3 = scalePoint(obj.p3, basePoint, factor);
                        if(obj.pCenter) obj.pCenter = scalePoint(obj.pCenter, basePoint, factor);
                        if(obj.pStart) obj.pStart = scalePoint(obj.pStart, basePoint, factor);
                        if(obj.pEnd) obj.pEnd = scalePoint(obj.pEnd, basePoint, factor);
                        if (obj.type === 'arcCenterStartEnd' && obj.pStart && obj.pEnd && obj.pCenter) {
                            obj.startAngle = Math.atan2(obj.pStart.y - obj.centerY, obj.pStart.x - obj.centerX);
                            obj.endAngle = Math.atan2(obj.pEnd.y - obj.centerY, obj.pEnd.x - obj.centerX);
                        } else if (obj.type === 'arc' && obj.p1 && obj.p3 && obj.p2){ 
                             const newArcParams = calculateArcParameters(obj.p1, obj.p2, obj.p3);
                             if(newArcParams) {
                                obj.centerX = newArcParams.centerX; obj.centerY = newArcParams.centerY;
                                obj.radius = newArcParams.radius; obj.startAngle = newArcParams.startAngle;
                                obj.endAngle = newArcParams.endAngle; obj.clockwise = newArcParams.clockwise;
                             }
                        }
                    } else if (obj.type === 'spline' || obj.type === 'hexagon' || obj.type === 'star') {
                        obj.points = obj.points.map(p => scalePoint(p, basePoint, factor));
                        if (obj.centerX !== undefined && obj.centerY !== undefined) { 
                             const newPolyCenter = scalePoint({x: obj.centerX, y: obj.centerY}, basePoint, factor);
                            obj.centerX = newPolyCenter.x; obj.centerY = newPolyCenter.y;
                        }
                        if(obj.radius !== undefined) obj.radius = Math.max(0.1/scale, obj.radius * factor); 
                        if(obj.outerRadius !== undefined) obj.outerRadius = Math.max(0.1/scale, obj.outerRadius * factor); 
                        if(obj.innerRadius !== undefined) obj.innerRadius = Math.max(0.1/scale, obj.innerRadius * factor); 
                    } else if (obj.type === 'point') {
                        const newPt = scalePoint({ x: obj.x, y: obj.y }, basePoint, factor);
                        obj.x = newPt.x; obj.y = newPt.y;
                    } else if (obj.type === 'rectangle') {
                        const newTopLeft = scalePoint({ x: obj.x, y: obj.y }, basePoint, factor);
                        const newBottomRight = scalePoint({ x: obj.x + obj.width, y: obj.y + obj.height }, basePoint, factor);
                        obj.x = newTopLeft.x; obj.y = newTopLeft.y;
                        obj.width = newBottomRight.x - newTopLeft.x;
                        obj.height = newBottomRight.y - newTopLeft.y;
                        if (obj.width < 0) { obj.x += obj.width; obj.width *= -1; }
                        if (obj.height < 0) { obj.y += obj.height; obj.height *= -1; }
                    }
                });
            }
            
            function initTransformTools() {
                transformValuesDiv = document.getElementById('transformValues');
            }

            function activateTransformTool(mode) {
                if (selectedObjectIds.length === 0) { 
                    toolStatusDiv.textContent = `${mode === 'rotate' ? 'Rotar' : 'Escalar'}: Primero seleccione objetos.`;
                    if(currentTool !== 'select') setTool('select'); 
                    return;
                }
                
                exitAllToolModes(mode); 
                
                transformState.active = true;
                transformState.mode = mode;
                transformState.objectsToTransform = [...selectedObjectIds];
                transformState.originalObjectStates.clear();
                
                transformState.objectsToTransform.forEach(id => {
                    const objToCopy = objects.find(o => o.id === id);
                    if (objToCopy) transformState.originalObjectStates.set(id, JSON.parse(JSON.stringify(objToCopy)));
                });
                
                transformState.center = calculateCentroid(transformState.objectsToTransform);
                if (!transformState.center) { 
                    console.warn("No se pudo calcular el centroide para la transformaci√≥n (sin objetos v√°lidos).");
                    exitTransformTool(false); 
                    return;
                }

                transformState.dragStartPoint = null; 
                transformState.currentAngleRad = 0;
                transformState.initialHandleAngleRad = 0; 
                transformState.currentFactor = 1;
                transformState.initialHandleDistance = 1; 
                
                currentTool = mode; 
                drawing = true; 
                updateToolStatusAndCursor();
                showTransformValues();
                redrawCanvas();
            }

            function exitTransformTool(applyChanges = false) {
                if (!transformState.active) return;

                if (!applyChanges) { 
                    transformState.objectsToTransform.forEach(id => {
                        const originalState = transformState.originalObjectStates.get(id);
                        const currentObjIndex = objects.findIndex(o => o.id === id);
                        if (originalState && currentObjIndex !== -1) {
                            objects[currentObjIndex] = JSON.parse(JSON.stringify(originalState));
                        }
                    });
                }
                
                resetTransformStateOnly(); 
                
                if(currentTool === 'rotate' || currentTool === 'scale') {
                   // La herramienta se cambiar√° a 'select' a trav√©s de la l√≥gica de Enter/Esc o cambio de herramienta
                }

                hideTransformValues();
                redrawCanvas(); 
            }
            
            function resetTransformStateOnly() {
                 transformState.active = false;
                transformState.mode = null;
                transformState.center = null;
                transformState.dragStartPoint = null;
                transformState.currentAngleRad = 0;
                transformState.initialHandleAngleRad = 0;
                transformState.currentFactor = 1;
                transformState.initialHandleDistance = 1;
                transformState.isSnapping = false;
            }


            function calculateCentroid(objectIds) {
                if (!objectIds || objectIds.length === 0) return null;

                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                let foundValidBounds = false;

                objectIds.forEach(id => {
                    const obj = objects.find(o => o.id === id);
                    if (!obj) return;

                    let objBounds = { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity }; 
                    
                    if (obj.type === 'point') {
                        objBounds = { minX: obj.x, minY: obj.y, maxX: obj.x, maxY: obj.y };
                    } else if (obj.type === 'line') {
                        objBounds = {
                            minX: Math.min(obj.startX, obj.endX), minY: Math.min(obj.startY, obj.endY),
                            maxX: Math.max(obj.startX, obj.endX), maxY: Math.max(obj.startY, obj.endY)
                        };
                    } else if (obj.type === 'circle') {
                        objBounds = {
                            minX: obj.centerX - obj.radius, minY: obj.centerY - obj.radius,
                            maxX: obj.centerX + obj.radius, maxY: obj.centerY + obj.radius
                        };
                    } else if (obj.type === 'ellipse') {
                        const { centerX, centerY, radiusX, radiusY, rotation = 0 } = obj;
                        const cosR = Math.cos(rotation);
                        const sinR = Math.sin(rotation);
                        const extentsX = Math.sqrt(radiusX*radiusX * cosR*cosR + radiusY*radiusY * sinR*sinR);
                        const extentsY = Math.sqrt(radiusX*radiusX * sinR*sinR + radiusY*radiusY * cosR*cosR);
                        objBounds = {
                            minX: centerX - extentsX, minY: centerY - extentsY,
                            maxX: centerX + extentsX, maxY: centerY + extentsY
                        };
                    } else if (obj.type === 'rectangle') {
                        objBounds = {
                            minX: obj.x, minY: obj.y,
                            maxX: obj.x + obj.width, maxY: obj.y + obj.height
                        };
                    } else if (obj.type === 'arc' || obj.type === 'arcCenterStartEnd') {
                        const pointsOnArc = [
                            {x: obj.centerX + obj.radius * Math.cos(obj.startAngle), y: obj.centerY + obj.radius * Math.sin(obj.startAngle)},
                            {x: obj.centerX + obj.radius * Math.cos(obj.endAngle), y: obj.centerY + obj.radius * Math.sin(obj.endAngle)}
                        ];
                        const anglesToCheck = [0, Math.PI/2, Math.PI, 3*Math.PI/2]; 
                        let sNorm = (obj.startAngle % (2*Math.PI) + 2*Math.PI) % (2*Math.PI); 
                        let eNorm = (obj.endAngle % (2*Math.PI) + 2*Math.PI) % (2*Math.PI);
                        let isObjClockwise = obj.type === 'arc' ? obj.clockwise : !obj.counterClockwise; 
                        const epsilonAngle = 1e-5; 

                        anglesToCheck.forEach(angle => {
                            let inArc = false;
                            if (Math.abs(sNorm - eNorm) < epsilonAngle || Math.abs(Math.abs(sNorm - eNorm) - 2*Math.PI) < epsilonAngle) {
                                inArc = true; 
                            } else if (isObjClockwise) { 
                                if (sNorm >= eNorm) inArc = (angle <= sNorm + epsilonAngle && angle >= eNorm - epsilonAngle);
                                else inArc = (angle <= sNorm + epsilonAngle || angle >= eNorm - epsilonAngle); 
                            } else { 
                                if (sNorm <= eNorm) inArc = (angle >= sNorm - epsilonAngle && angle <= eNorm + epsilonAngle);
                                else inArc = (angle >= sNorm - epsilonAngle || angle <= eNorm + epsilonAngle); 
                            }
                            if (inArc) pointsOnArc.push({x: obj.centerX + obj.radius * Math.cos(angle), y: obj.centerY + obj.radius * Math.sin(angle)});
                        });
                        
                        pointsOnArc.forEach(p => {
                            objBounds.minX = Math.min(objBounds.minX, p.x); objBounds.minY = Math.min(objBounds.minY, p.y);
                            objBounds.maxX = Math.max(objBounds.maxX, p.x); objBounds.maxY = Math.max(objBounds.maxY, p.y);
                        });
                         if (objBounds.minX === Infinity) { 
                           objBounds = { minX: obj.centerX - obj.radius, minY: obj.centerY - obj.radius,
                                         maxX: obj.centerX + obj.radius, maxY: obj.centerY + obj.radius };
                        }
                    } else if (obj.points && obj.points.length > 0) { 
                        obj.points.forEach(p => {
                            objBounds.minX = Math.min(objBounds.minX, p.x); objBounds.minY = Math.min(objBounds.minY, p.y);
                            objBounds.maxX = Math.max(objBounds.maxX, p.x); objBounds.maxY = Math.max(objBounds.maxY, p.y);
                        });
                    }

                    if (objBounds.minX !== Infinity) { 
                        minX = Math.min(minX, objBounds.minX);
                        minY = Math.min(minY, objBounds.minY);
                        maxX = Math.max(maxX, objBounds.maxX);
                        maxY = Math.max(maxY, objBounds.maxY);
                        foundValidBounds = true;
                    }
                });

                if (!foundValidBounds) return (objects.length > 0 && objects[0].centerX !== undefined) ? {x: objects[0].centerX, y: objects[0].centerY} : {x:0, y:0}; 
                return { x: (minX + maxX) / 2, y: (minY + maxY) / 2 };
            }
            
            function handleTransformMouseDown(event) { 
                if (!transformState.active || event.button !== 0) return false; 
                
                const handleInfo = getTransformHandleAtPosition(mousePosWorld);

                if (handleInfo) { 
                    transformState.dragStartPoint = { ...mousePosWorld, handleType: handleInfo.type, handleIndex: handleInfo.index }; 
                    
                    if (transformState.mode === 'rotate') {
                        transformState.initialHandleAngleRad = Math.atan2(
                            mousePosWorld.y - transformState.center.y,
                            mousePosWorld.x - transformState.center.x
                        );
                    } else if (transformState.mode === 'scale') {
                        transformState.initialHandleDistance = distance(transformState.center, mousePosWorld);
                        if (transformState.initialHandleDistance < 1e-6 / scale) transformState.initialHandleDistance = 1; 
                    }
                    return true; 
                }
                return false; 
            }

            function handleTransformMouseMove(event) { 
                if (!transformState.active || !transformState.dragStartPoint) return false;

                transformState.isSnapping = event.shiftKey; 

                transformState.objectsToTransform.forEach(id => {
                    const originalToolActivationState = transformState.originalObjectStates.get(id); 
                    const currentObjIndex = objects.findIndex(o => o.id === id);
                    if (originalToolActivationState && currentObjIndex !== -1) {
                        objects[currentObjIndex] = JSON.parse(JSON.stringify(originalToolActivationState));
                    }
                });

                if (transformState.mode === 'rotate') {
                    const currentMouseAngleRad = Math.atan2(
                        mousePosWorld.y - transformState.center.y,
                        mousePosWorld.x - transformState.center.x
                    );
                    let deltaAngleRad = currentMouseAngleRad - transformState.initialHandleAngleRad;

                    if (transformState.isSnapping) {
                        const snapRad = (transformState.snapAngleDeg * Math.PI) / 180;
                        deltaAngleRad = Math.round(deltaAngleRad / snapRad) * snapRad;
                    }
                    transformState.currentAngleRad = deltaAngleRad; 
                    applyRotationToObjects(transformState.objectsToTransform, transformState.center, transformState.currentAngleRad);

                } else if (transformState.mode === 'scale') {
                    const currentMouseDistance = distance(transformState.center, mousePosWorld);
                    let factor = transformState.initialHandleDistance > 1e-6 / scale ? currentMouseDistance / transformState.initialHandleDistance : 1;
                    
                    if (factor < 0.01) factor = 0.01; 

                    if (transformState.isSnapping) {
                        factor = Math.round(factor / transformState.snapScaleFactor) * transformState.snapScaleFactor;
                        if (factor < 0.01) factor = Math.max(0.01, transformState.snapScaleFactor); 
                    }
                    transformState.currentFactor = factor;
                    applyScalingToObjects(transformState.objectsToTransform, transformState.center, transformState.currentFactor, transformState.uniformScale);
                }
                
                showTransformValues(); 
                return true;
            }

            function handleTransformMouseUp(event) {
                if (!transformState.active || !transformState.dragStartPoint || event.button !== 0) return false;
                transformState.dragStartPoint = null; 
                redrawCanvas();
                return true;
            }

            function handleTransformKeydown(event) {
                if (!transformState.active || isInputFocused()) return false;
                let eventHandled = false;

                if (event.key === 'Escape') {
                    exitTransformTool(false); 
                    setTool('select'); 
                    eventHandled = true;
                } else if (event.key === 'Enter') {
                    exitTransformTool(true); 
                    setTool('select'); 
                    eventHandled = true;
                } else if (event.shiftKey && !transformState.isSnapping) { 
                    transformState.isSnapping = true;
                    if (transformState.dragStartPoint) { 
                         const pseudoEvent = new MouseEvent('mousemove', { 
                             clientX: lastKnownMouseScreenPos.x + canvas.getBoundingClientRect().left, 
                             clientY: lastKnownMouseScreenPos.y + canvas.getBoundingClientRect().top, 
                             shiftKey: true 
                         });
                         mousePosWorld = getMouseWorldPositionWithAids(pseudoEvent); 
                         handleTransformMouseMove(pseudoEvent); 
                    }
                    showTransformValues();
                    redrawCanvas();
                    eventHandled = true; 
                }

                if (eventHandled) {
                    event.preventDefault(); 
                    return true;
                }
                return false; 
            }

            function handleTransformKeyup(event) { 
                if (!transformState.active || isInputFocused() || event.key !== 'Shift') return false;
                let eventHandled = false;
                if (transformState.isSnapping) { 
                    transformState.isSnapping = false;
                    if (transformState.dragStartPoint) { 
                        const pseudoEvent = new MouseEvent('mousemove', { 
                            clientX: lastKnownMouseScreenPos.x + canvas.getBoundingClientRect().left, 
                            clientY: lastKnownMouseScreenPos.y + canvas.getBoundingClientRect().top, 
                            shiftKey: false 
                        });
                        mousePosWorld = getMouseWorldPositionWithAids(pseudoEvent);
                        handleTransformMouseMove(pseudoEvent); 
                    }
                    showTransformValues();
                    redrawCanvas();
                    eventHandled = true;
                }
                return eventHandled;
            }
            
            function drawTransformControls() {
                if (!transformState.active || !transformState.center || !transformState.showHandles) return;

                const { center, mode, currentAngleRad, currentFactor, initialHandleAngleRad, dragStartPoint } = transformState;
                const handleScreenRadius = 8; 
                const visualRadiusWorld = TRANSFORM_HANDLE_VISUAL_RADIUS / scale; 

                ctx.save();
                ctx.beginPath();
                ctx.arc(center.x, center.y, handleScreenRadius * 0.7 / scale, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 0, 255, 0.9)'; 
                ctx.fill();
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 1.5 / scale;
                ctx.stroke();

                ctx.beginPath();
                ctx.arc(center.x, center.y, visualRadiusWorld, 0, Math.PI * 2);
                ctx.strokeStyle = (mode === 'rotate') ? 'rgba(102, 204, 255, 0.5)' : 'rgba(102, 255, 153, 0.5)';
                ctx.setLineDash([5 / scale, 5 / scale]);
                ctx.stroke();
                ctx.setLineDash([]);

                let displayHandleAngle;
                if (mode === 'rotate') {
                    displayHandleAngle = (dragStartPoint ? Math.atan2(mousePosWorld.y - center.y, mousePosWorld.x - center.x) : (initialHandleAngleRad + currentAngleRad) );
                     if(!dragStartPoint && initialHandleAngleRad === 0 && currentAngleRad === 0 && transformState.objectsToTransform.length > 0) {
                        const firstObj = objects.find(o => o.id === transformState.objectsToTransform[0]);
                        if (firstObj && firstObj.centerX !== undefined) { 
                           displayHandleAngle = Math.atan2( (firstObj.centerY - visualRadiusWorld) - center.y, firstObj.centerX - center.x);
                        } else { 
                           displayHandleAngle = -Math.PI / 4; 
                        }
                     } else if (!dragStartPoint && initialHandleAngleRad === 0 && currentAngleRad === 0){ 
                         displayHandleAngle = -Math.PI / 4;
                     }

                } else { 
                    displayHandleAngle = (dragStartPoint ? Math.atan2(mousePosWorld.y - center.y, mousePosWorld.x - center.x) : -Math.PI / 4); 
                }
                
                const effectiveDisplayRadius = (mode === 'scale' && dragStartPoint) 
                    ? distance(center, mousePosWorld) 
                    : ( (mode === 'scale') ? visualRadiusWorld * currentFactor : visualRadiusWorld ); 
                
                const handleDisplayX = center.x + effectiveDisplayRadius * Math.cos(displayHandleAngle);
                const handleDisplayY = center.y + effectiveDisplayRadius * Math.sin(displayHandleAngle);

                ctx.beginPath();
                ctx.lineWidth = 1.5 / scale;
                ctx.strokeStyle = 'white';
                if (mode === 'rotate') {
                    ctx.arc(handleDisplayX, handleDisplayY, handleScreenRadius / scale, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(102, 204, 255, 0.8)'; 
                } else { 
                    const s = handleScreenRadius / scale;
                    ctx.rect(handleDisplayX - s/2, handleDisplayY - s/2, s, s); 
                    ctx.fillStyle = 'rgba(102, 255, 153, 0.8)'; 
                }
                ctx.fill(); ctx.stroke();
                
                ctx.restore();
            }

            function getTransformHandleAtPosition(pos) { 
                if (!transformState.active || !transformState.center || !transformState.showHandles) return null;

                const handleScreenRadius = 8; 
                const visualRadiusWorld = TRANSFORM_HANDLE_VISUAL_RADIUS / scale;
                const { center, mode, currentAngleRad, currentFactor, initialHandleAngleRad, dragStartPoint } = transformState;

                let handleAngleForHitTest;
                 if (mode === 'rotate') {
                    handleAngleForHitTest = (dragStartPoint ? Math.atan2(mousePosWorld.y - center.y, mousePosWorld.x - center.x) : (initialHandleAngleRad + currentAngleRad) );
                     if(!dragStartPoint && initialHandleAngleRad === 0 && currentAngleRad === 0 && transformState.objectsToTransform.length > 0) {
                        const firstObj = objects.find(o => o.id === transformState.objectsToTransform[0]);
                         if (firstObj && firstObj.centerX !== undefined) {
                           handleAngleForHitTest = Math.atan2( (firstObj.centerY - visualRadiusWorld) - center.y, firstObj.centerX - center.x);
                        } else {
                           handleAngleForHitTest = -Math.PI / 4;
                        }
                     } else if (!dragStartPoint && initialHandleAngleRad === 0 && currentAngleRad === 0){
                         handleAngleForHitTest = -Math.PI / 4;
                     }
                } else { 
                    handleAngleForHitTest = (dragStartPoint ? Math.atan2(mousePosWorld.y - center.y, mousePosWorld.x - center.x) : -Math.PI / 4);
                }

                const effectiveHitRadius = (mode === 'scale' && dragStartPoint) 
                    ? distance(center, mousePosWorld)
                    : ( (mode === 'scale') ? visualRadiusWorld * currentFactor : visualRadiusWorld );

                const handleX = center.x + effectiveHitRadius * Math.cos(handleAngleForHitTest);
                const handleY = center.y + effectiveHitRadius * Math.sin(handleAngleForHitTest);

                if (distance(pos, { x: handleX, y: handleY }) <= (handleScreenRadius * 1.8) / scale) { 
                    return { type: 'transform', index: 0 }; 
                }
                return null;
            }

            function showTransformValues() {
                if (!transformValuesDiv) return;
                if (!transformState.active || !transformState.center) {
                    transformValuesDiv.style.display = 'none';
                    return;
                }
                transformValuesDiv.style.display = 'block';
                let text = '';
                if (transformState.mode === 'rotate') {
                    const angleDegrees = (transformState.currentAngleRad * 180) / Math.PI;
                    text = `Rotar: ${angleDegrees.toFixed(1)}¬∞ ${transformState.isSnapping ? '[SNAP]' : ''}`;
                } else if (transformState.mode === 'scale') {
                    text = `Escalar: ${transformState.currentFactor.toFixed(2)}x ${transformState.isSnapping ? '[SNAP]' : ''}`;
                }
                transformValuesDiv.textContent = text;
            }
            function hideTransformValues() {
                if (transformValuesDiv) transformValuesDiv.style.display = 'none';
            }


            function resizeCanvas() { 
                requestAnimationFrame(() => { 
                    const dpr = window.devicePixelRatio || 1;
                    canvas.width = canvasContainer.clientWidth * dpr;
                    canvas.height = canvasContainer.clientHeight * dpr;
                    canvas.style.width = canvasContainer.clientWidth + 'px';
                    canvas.style.height = canvasContainer.clientHeight + 'px';
                    ctx.scale(dpr, dpr); 
                    
                    if (objects.length === 0 && dimensions.length === 0 && scale === 1.0 && !transformState.active) { 
                        offsetCanvas.x = (canvas.width / dpr) / 2;
                        offsetCanvas.y = (canvas.height / dpr) / 2;
                    }
                    redrawCanvas();
                });
            }
            window.addEventListener('resize', resizeCanvas);


            function getNewObjectId() { return nextObjectId++; }
            function getNewDimensionId() { return nextDimensionId++; }

            function screenToWorld(sX, sY) { return { x: (sX - offsetCanvas.x) / scale, y: (sY - offsetCanvas.y) / scale }; }
            function worldToScreen(wX, wY) { return { x: wX * scale + offsetCanvas.x, y: wY * scale + offsetCanvas.y }; }
            
            function distSq(p1, p2) { const dx = p1.x - p2.x; const dy = p1.y - p2.y; return dx * dx + dy * dy; }
            function distance(p1, p2) { return Math.hypot(p1.x - p2.x, p1.y - p2.y); }

            function calculateArcParameters(p1, p2, p3) { 
                const temp = p2.x * p2.x + p2.y * p2.y;
                const bc = (p1.x * p1.x + p1.y * p1.y - temp) / 2;
                const cd = (temp - p3.x * p3.x - p3.y * p3.y) / 2;
                const det = (p1.x - p2.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p2.y);

                if (Math.abs(det) < 1e-9) { return null; } 

                const idet = 1 / det;
                const centerX = (bc * (p2.y - p3.y) - cd * (p1.y - p2.y)) * idet;
                const centerY = (cd * (p1.x - p2.x) - bc * (p2.x - p3.x)) * idet;
                const radius = Math.hypot(p1.x - centerX, p1.y - centerY);

                let startAngle = Math.atan2(p1.y - centerY, p1.x - centerX);
                let midAngle = Math.atan2(p2.y - centerY, p2.x - centerX);
                let endAngle = Math.atan2(p3.y - centerY, p3.x - centerX);
                
                const PI2 = Math.PI * 2;
                startAngle = (startAngle % PI2 + PI2) % PI2;
                midAngle = (midAngle % PI2 + PI2) % PI2;
                endAngle = (endAngle % PI2 + PI2) % PI2;

                let clockwise = false; 
                if (startAngle < endAngle) { 
                    if (!(midAngle > startAngle && midAngle < endAngle)) {
                        clockwise = true;
                    }
                } else { 
                    if (!(midAngle > startAngle || midAngle < endAngle)) {
                        clockwise = true;
                    }
                }
                return { centerX, centerY, radius, startAngle, endAngle, clockwise: clockwise };
            }

            function applyOrthoMode(currentWorldPos, referenceWorldPos) { 
                 if (transformState.active || !orthoModeEnabled || !referenceWorldPos || 
                    !(drawing && !editModeActive && !isDraggingObject && 
                      (['line', 'circle', 'arc', 'spline', 'rectangle', 'arcCenterStartEnd', 'ellipse', 'hexagon', 'star'].includes(currentTool) || 
                       ((currentTool === 'dimHorizontal' || currentTool === 'dimVertical') && startPoint && !definingPoint2) 
                      )
                     )
                   ) return currentWorldPos; 
                const dX = Math.abs(currentWorldPos.x - referenceWorldPos.x); 
                const dY = Math.abs(currentWorldPos.y - referenceWorldPos.y); 
                if (dX > dY) return { x: currentWorldPos.x, y: referenceWorldPos.y }; 
                else return { x: referenceWorldPos.x, y: currentWorldPos.y }; 
            }

            function snapToGrid(worldPos) {
                if (!snapToGridEnabled) return worldPos;
                return {
                    x: Math.round(worldPos.x / GRID_SIZE) * GRID_SIZE,
                    y: Math.round(worldPos.y / GRID_SIZE) * GRID_SIZE
                };
            }

            function getLineSegmentIntersection(l1, l2) { 
                const x1 = l1.p1.x, y1 = l1.p1.y, x2 = l1.p2.x, y2 = l1.p2.y;
                const x3 = l2.p1.x, y3 = l2.p1.y, x4 = l2.p2.x, y4 = l2.p2.y;
                const den = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
                if (den === 0) return null; 
                const tNum = (x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4);
                const uNum = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3));
                const t = tNum / den; const u = uNum / den;
                const epsilon = 1e-6; 
                if (t >= -epsilon && t <= 1 + epsilon && u >= -epsilon && u <= 1 + epsilon) { 
                    return { x: x1 + t * (x2 - x1), y: y1 + t * (y2 - y1) };
                }
                return null; 
            }

            function getNearestPointOnLineSegment(p, lineStart, lineEnd) {
                const l2 = distSq(lineStart, lineEnd);
                if (l2 === 0) return { ...lineStart }; 
                let t = ((p.x - lineStart.x) * (lineEnd.x - lineStart.x) + (p.y - lineStart.y) * (lineEnd.y - lineStart.y)) / l2;
                t = Math.max(0, Math.min(1, t)); 
                return { x: lineStart.x + t * (lineEnd.x - lineStart.x), y: lineStart.y + t * (lineEnd.y - lineStart.y) };
            }

            function getTangentPointsFromPointToCircle(extPt, circleCenter, radius) {
                const dSq = distSq(extPt, circleCenter);
                const rSq = radius * radius;
                if (dSq < rSq - 1e-9) return []; 
                if (Math.abs(dSq - rSq) < 1e-9) return [{...extPt}]; 

                const d = Math.sqrt(dSq);
                const K = Math.sqrt(dSq - rSq); 
                
                const tangentPoints = [];
                const angle_ep_c = Math.atan2(circleCenter.y - extPt.y, circleCenter.x - extPt.x);
                const angle_delta = Math.acos(K / d) ; 

                const tp1_angle = angle_ep_c + angle_delta;
                tangentPoints.push({
                    x: extPt.x + K * Math.cos(tp1_angle),
                    y: extPt.y + K * Math.sin(tp1_angle)
                });

                const tp2_angle = angle_ep_c - angle_delta;
                 tangentPoints.push({
                    x: extPt.x + K * Math.cos(tp2_angle),
                    y: extPt.y + K * Math.sin(tp2_angle)
                });
                return tangentPoints.filter(p => !isNaN(p.x) && !isNaN(p.y)); 
            }

            function findSnaps(worldMousePos, drawingStartPoint = null) {
                if (transformState.active && transformState.dragStartPoint) return null;

                const snapToleranceWorldSq = (SNAP_TOLERANCE_SCREEN / scale) * (SNAP_TOLERANCE_SCREEN / scale);
                let closestSnap = null;
                let minDistanceSq = snapToleranceWorldSq;

                function updateClosestSnap(snap, dSq) {
                    if (dSq < minDistanceSq) {
                        minDistanceSq = dSq;
                        closestSnap = snap;
                    }
                }
                 objects.forEach(obj => {
                    if (obj.isPreview) return; 

                    if (obj.type === 'line') {
                        const p1 = { x: obj.startX, y: obj.startY };
                        const p2 = { x: obj.endX, y: obj.endY };
                        if (refEndpointCb.checked) {
                            updateClosestSnap({ type: 'endpoint', x: p1.x, y: p1.y, text: 'P. Final' }, distSq(worldMousePos, p1));
                            updateClosestSnap({ type: 'endpoint', x: p2.x, y: p2.y, text: 'P. Final' }, distSq(worldMousePos, p2));
                        }
                        if (refMidpointCb.checked) {
                            const mid = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
                            updateClosestSnap({ type: 'midpoint', x: mid.x, y: mid.y, text: 'P. Medio' }, distSq(worldMousePos, mid));
                        }
                        if (refNearestCb.checked) {
                            const nearest = getNearestPointOnLineSegment(worldMousePos, p1, p2);
                            if (!refEndpointCb.checked || (distance(nearest, p1) > 1e-6 && distance(nearest, p2) > 1e-6)) {
                                updateClosestSnap({ type: 'nearest', x: nearest.x, y: nearest.y, text: 'Cercano' }, distSq(worldMousePos, nearest));
                            }
                        }
                    } else if (obj.type === 'circle') {
                        const center = { x: obj.centerX, y: obj.centerY };
                        if (refCenterCb.checked) {
                            updateClosestSnap({ type: 'center', x: center.x, y: center.y, text: 'Centro' }, distSq(worldMousePos, center));
                        }
                        if (refQuadrantCb.checked) {
                            const qPoints = [
                                { x: center.x, y: center.y - obj.radius, name: 'N' }, { x: center.x + obj.radius, y: center.y, name: 'E' },
                                { x: center.x, y: center.y + obj.radius, name: 'S' }, { x: center.x - obj.radius, y: center.y, name: 'O' }
                            ];
                            qPoints.forEach(q => updateClosestSnap({ type: 'quadrant', x: q.x, y: q.y, text: `Cuadrante` }, distSq(worldMousePos, q)));
                        }
                        if (refTangentCb.checked && drawingStartPoint && (currentTool === 'line' || (currentTool === 'spline' && currentSplinePoints.length > 0))) {
                            const tangentPoints = getTangentPointsFromPointToCircle(drawingStartPoint, center, obj.radius);
                            tangentPoints.forEach(tp => updateClosestSnap({ type: 'tangent', x: tp.x, y: tp.y, text: 'Tangente' }, distSq(worldMousePos, tp)));
                        }
                    } else if (obj.type === 'arc' || obj.type === 'arcCenterStartEnd') {
                        const center = { x: obj.centerX, y: obj.centerY };
                        if (refCenterCb.checked) {
                            updateClosestSnap({ type: 'center', x: center.x, y: center.y, text: 'Centro (Arco)' }, distSq(worldMousePos, center));
                        }
                        if (refEndpointCb.checked) {
                            const p1_arc = { x: obj.centerX + obj.radius * Math.cos(obj.startAngle), y: obj.centerY + obj.radius * Math.sin(obj.startAngle) };
                            const p3_arc = { x: obj.centerX + obj.radius * Math.cos(obj.endAngle), y: obj.centerY + obj.radius * Math.sin(obj.endAngle) };
                            updateClosestSnap({ type: 'endpoint', x: p1_arc.x, y: p1_arc.y, text: 'P. Final (Arco)' }, distSq(worldMousePos, p1_arc));
                            updateClosestSnap({ type: 'endpoint', x: p3_arc.x, y: p3_arc.y, text: 'P. Final (Arco)' }, distSq(worldMousePos, p3_arc));
                        }
                         if (refQuadrantCb.checked) {
                            const qPoints = [ 
                                { x: center.x, y: center.y - obj.radius }, { x: center.x + obj.radius, y: center.y },
                                { x: center.x, y: center.y + obj.radius }, { x: center.x - obj.radius, y: center.y }
                            ];
                            qPoints.forEach(q => {
                                let angle = Math.atan2(q.y - center.y, q.x - center.x);
                                let sA = obj.startAngle, eA = obj.endAngle;
                                const twoPi = 2 * Math.PI;
                                angle = (angle % twoPi + twoPi) % twoPi; 
                                sA = (sA % twoPi + twoPi) % twoPi;
                                eA = (eA % twoPi + twoPi) % twoPi;

                                let isOnArc;
                                const isObjClockwise = obj.type === 'arc' ? obj.clockwise : !obj.counterClockwise;

                                if (isObjClockwise) { 
                                    if (sA >= eA) isOnArc = (angle <= sA && angle >= eA);
                                    else isOnArc = (angle <= sA || angle >= eA); 
                                } else { 
                                    if (sA <= eA) isOnArc = (angle >= sA && angle <= eA);
                                    else isOnArc = (angle >= sA || angle <= eA); 
                                }
                                if (isOnArc) {
                                    updateClosestSnap({ type: 'quadrant', x: q.x, y: q.y, text: `Cuadrante (Arco)` }, distSq(worldMousePos, q));
                                }
                            });
                        }
                    } else if (obj.type === 'point') {
                        if (refEndpointCb.checked || refNearestCb.checked) { 
                             updateClosestSnap({ type: 'endpoint', x: obj.x, y: obj.y, text: 'Punto' }, distSq(worldMousePos, {x: obj.x, y: obj.y}));
                        }
                    } else if (obj.type === 'rectangle' || obj.type === 'hexagon' || obj.type === 'star') {
                        if (obj.points && obj.points.length > 0) {
                            obj.points.forEach((pt, index) => {
                                if (refEndpointCb.checked) { 
                                    updateClosestSnap({ type: 'endpoint', x: pt.x, y: pt.y, text: 'V√©rtice' }, distSq(worldMousePos, pt));
                                }
                                if (refMidpointCb.checked && obj.points.length > 1) { 
                                    const pNext = obj.points[(index + 1) % obj.points.length];
                                    const mid = { x: (pt.x + pNext.x) / 2, y: (pt.y + pNext.y) / 2 };
                                    updateClosestSnap({ type: 'midpoint', x: mid.x, y: mid.y, text: 'P. Medio' }, distSq(worldMousePos, mid));
                                }
                            });
                            if (refCenterCb.checked && obj.centerX && obj.centerY) { 
                                updateClosestSnap({ type: 'center', x: obj.centerX, y: obj.centerY, text: 'Centro' }, distSq(worldMousePos, {x: obj.centerX, y: obj.centerY}));
                            }
                        }
                    } else if (obj.type === 'ellipse') {
                        if (refCenterCb.checked) {
                            updateClosestSnap({ type: 'center', x: obj.centerX, y: obj.centerY, text: 'Centro (Elipse)' }, distSq(worldMousePos, {x:obj.centerX, y:obj.centerY}));
                        }
                        if (refQuadrantCb.checked) {
                            const rot = obj.rotation || 0;
                            const cosR = Math.cos(rot); const sinR = Math.sin(rot);
                            const qx1 = obj.centerX + obj.radiusX * cosR; const qy1 = obj.centerY + obj.radiusX * sinR;
                            const qx2 = obj.centerX - obj.radiusX * cosR; const qy2 = obj.centerY - obj.radiusX * sinR;
                            const qx3 = obj.centerX - obj.radiusY * sinR; const qy3 = obj.centerY + obj.radiusY * cosR; 
                            const qx4 = obj.centerX + obj.radiusY * sinR; const qy4 = obj.centerY - obj.radiusY * cosR;
                            updateClosestSnap({ type: 'quadrant', x: qx1, y: qy1, text: 'Cuadrante' }, distSq(worldMousePos, {x:qx1, y:qy1}));
                            updateClosestSnap({ type: 'quadrant', x: qx2, y: qy2, text: 'Cuadrante' }, distSq(worldMousePos, {x:qx2, y:qy2}));
                            updateClosestSnap({ type: 'quadrant', x: qx3, y: qy3, text: 'Cuadrante' }, distSq(worldMousePos, {x:qx3, y:qy3}));
                            updateClosestSnap({ type: 'quadrant', x: qx4, y: qy4, text: 'Cuadrante' }, distSq(worldMousePos, {x:qx4, y:qy4}));
                        }
                    }
                });

                if (refIntersectionCb.checked) {
                    for (let i = 0; i < objects.length; i++) {
                        if (objects[i].type !== 'line' || objects[i].isPreview) continue;
                        for (let j = i + 1; j < objects.length; j++) {
                            if (objects[j].type !== 'line' || objects[j].isPreview) continue;
                            const line1 = { p1: {x: objects[i].startX, y: objects[i].startY}, p2: {x: objects[i].endX, y: objects[i].endY} };
                            const line2 = { p1: {x: objects[j].startX, y: objects[j].startY}, p2: {x: objects[j].endX, y: objects[j].endY} };
                            const intersectionPt = getLineSegmentIntersection(line1, line2);
                            if (intersectionPt) {
                                updateClosestSnap({ type: 'intersection', x: intersectionPt.x, y: intersectionPt.y, text: 'Intersecci√≥n' }, distSq(worldMousePos, intersectionPt));
                            }
                        }
                    }
                }
                return closestSnap;
            }

            function showSnapIndicator() {
                snapIndicatorDiv.innerHTML = ''; 

                const isGeometricDrawingToolActive = ['line', 'circle', 'spline', 'arc', 'point', 'rectangle', 'arcCenterStartEnd', 'ellipse', 'hexagon', 'star'].includes(currentTool);
                const isTransformToolDefiningPoints = (transformState.active && !transformState.dragStartPoint); 
                
                const isDimToolDefiningPoints = drawing && (currentTool === 'dimHorizontal' || currentTool === 'dimVertical') && (!definingPoint2 || !startPoint); 
                
                const shouldShowObjectSnapIndicator = 
                    (currentSnap && currentSnap.type !== 'grid' && (isGeometricDrawingToolActive || isDimToolDefiningPoints || isTransformToolDefiningPoints));
                
                const isGridSnapRelevant = currentSnap && currentSnap.type === 'grid' &&
                    ( ((currentTool === 'dimHorizontal' || currentTool === 'dimVertical') && startPoint && definingPoint2) || 
                      (isGeometricDrawingToolActive && (!drawing || !startPoint || (currentTool==='spline' && currentSplinePoints.length===0) || (currentTool==='arcCenterStartEnd' && !arcCenterPoint) || (currentTool === 'ellipse' && !ellipseCenter) )) || 
                      (isTransformToolDefiningPoints) || 
                      ((currentTool === 'dimHorizontal' || currentTool === 'dimVertical') && (!drawing || !startPoint)) 
                    );

                if (!currentSnap || !(shouldShowObjectSnapIndicator || isGridSnapRelevant)) {
                    snapIndicatorDiv.style.opacity = '0';
                    return;
                }

                const screenPos = worldToScreen(currentSnap.x, currentSnap.y);
                let snapTextElement = document.createElement('div');
                snapTextElement.className = 'snap-text';
                snapTextElement.innerText = currentSnap.text;
                snapIndicatorDiv.appendChild(snapTextElement);

                const canvasRect = canvas.getBoundingClientRect();
                const containerRect = canvasContainer.getBoundingClientRect(); 
                snapIndicatorDiv.style.left = (screenPos.x - (canvasRect.left - containerRect.left)) + 'px';
                snapIndicatorDiv.style.top = (screenPos.y - (canvasRect.top - containerRect.top)) + 'px';
                snapIndicatorDiv.style.opacity = '1';


                const dpr = window.devicePixelRatio || 1;
                ctx.save();
                ctx.setTransform(dpr, 0, 0, dpr, 0, 0); 
                ctx.translate(offsetCanvas.x, offsetCanvas.y); 
                ctx.scale(scale, scale); 
                
                ctx.translate(currentSnap.x, currentSnap.y); 
                ctx.lineWidth = 1.5 / scale; 
                ctx.beginPath();

                switch (currentSnap.type) {
                    case 'endpoint': ctx.strokeStyle = '#ff4136'; ctx.rect(-SNAP_SYMBOL_SIZE/(2*scale), -SNAP_SYMBOL_SIZE/(2*scale), SNAP_SYMBOL_SIZE/scale, SNAP_SYMBOL_SIZE/scale); break;
                    case 'midpoint': ctx.strokeStyle = '#2ecc40'; ctx.moveTo(0, -SNAP_SYMBOL_SIZE/(2*scale)); ctx.lineTo(SNAP_SYMBOL_SIZE/(2*scale), SNAP_SYMBOL_SIZE/(2*scale)); ctx.lineTo(-SNAP_SYMBOL_SIZE/(2*scale), SNAP_SYMBOL_SIZE/(2*scale)); ctx.closePath(); break;
                    case 'center': ctx.strokeStyle = '#0074d9'; ctx.arc(0, 0, SNAP_SYMBOL_SIZE/(1.5*scale), 0, Math.PI * 2); break;
                    case 'quadrant': ctx.strokeStyle = '#b10dc9'; ctx.moveTo(0,-SNAP_SYMBOL_SIZE/(2*scale));ctx.lineTo(SNAP_SYMBOL_SIZE/(2*scale),0);ctx.lineTo(0,SNAP_SYMBOL_SIZE/(2*scale));ctx.lineTo(-SNAP_SYMBOL_SIZE/(2*scale),0);ctx.closePath(); break;
                    case 'intersection': ctx.strokeStyle = '#ff851b'; const cs = SNAP_SYMBOL_SIZE/(1.5*scale); ctx.moveTo(-cs,-cs);ctx.lineTo(cs,cs);ctx.moveTo(cs,-cs);ctx.lineTo(-cs,cs); break;
                    case 'tangent': ctx.strokeStyle = '#ffdc00'; ctx.arc(0,0,SNAP_SYMBOL_SIZE/(2*scale),0,Math.PI*2); ctx.moveTo(0,-SNAP_SYMBOL_SIZE*0.8/scale);ctx.lineTo(0,SNAP_SYMBOL_SIZE*0.8/scale); break;
                    case 'nearest': ctx.strokeStyle = '#7fdbff'; const hs=SNAP_SYMBOL_SIZE/(2*scale); ctx.moveTo(-hs,-hs);ctx.lineTo(hs,hs); ctx.moveTo(hs,-hs);ctx.lineTo(-hs,hs); ctx.moveTo(-hs,0);ctx.lineTo(hs,0); ctx.moveTo(0,-hs);ctx.lineTo(0,hs); break;
                    case 'grid': ctx.fillStyle = '#aaaaaa'; ctx.arc(0,0, 2/scale,0,Math.PI*2); ctx.fill(); ctx.restore(); return; 
                }
                ctx.stroke();
                ctx.restore();
            }

            function getMouseWorldPositionWithAids(event) {
                const r = canvas.getBoundingClientRect();
                const sX = event.clientX - r.left; const sY = event.clientY - r.top;
                const rawWp = screenToWorld(sX, sY); 
                let wp = { ...rawWp }; 
                currentSnap = null; 

                let referencePointForDrawing = null; 
                if (drawing || transformState.active) { 
                    if ((currentTool === 'line' || currentTool === 'circle' || currentTool === 'rectangle' || currentTool === 'hexagon' || currentTool === 'star') && startPoint) {
                        referencePointForDrawing = startPoint;
                    } else if (currentTool === 'spline' && currentSplinePoints.length > 0) {
                        referencePointForDrawing = currentSplinePoints[currentSplinePoints.length - 1];
                    } else if (currentTool === 'arc') { 
                        if (definingPoint2) referencePointForDrawing = definingPoint2;
                        else if (startPoint) referencePointForDrawing = startPoint;
                    } else if (currentTool === 'arcCenterStartEnd') { 
                        if (startPoint) referencePointForDrawing = startPoint; 
                        else if (arcCenterPoint) referencePointForDrawing = arcCenterPoint; 
                    } else if (currentTool === 'ellipse') {
                        if (ellipseRadiusXPoint) referencePointForDrawing = ellipseRadiusXPoint; 
                        else if (ellipseCenter) referencePointForDrawing = ellipseCenter; 
                    }
                    else if ((currentTool === 'dimHorizontal' || currentTool === 'dimVertical') && startPoint && !definingPoint2) {
                        referencePointForDrawing = startPoint; 
                    } else if (transformState.active && transformState.center) {
                        referencePointForDrawing = transformState.center;
                    }
                }
                
                const isGeometricDrawingToolActive = ['line', 'circle', 'spline', 'arc', 'point', 'rectangle', 'arcCenterStartEnd', 'ellipse', 'hexagon', 'star'].includes(currentTool);
                const isTransformToolDefiningPoints = (transformState.active && !transformState.dragStartPoint); 

                const isDimToolDefiningFirstOrSecondPoint = drawing && (currentTool === 'dimHorizontal' || currentTool === 'dimVertical') && (!definingPoint2 || !startPoint);

                const shouldActivateObjectSnaps = !transformState.dragStartPoint && 
                    (isGeometricDrawingToolActive || isDimToolDefiningFirstOrSecondPoint || isTransformToolDefiningPoints);


                if (shouldActivateObjectSnaps && !editModeActive && !isDraggingObject) {
                    const potentialSnap = findSnaps(rawWp, referencePointForDrawing);
                    if (potentialSnap) {
                        let allowSnap = true;
                        if (referencePointForDrawing && distance(potentialSnap, referencePointForDrawing) < 1e-6 / scale) {
                             if (potentialSnap.type === 'nearest' && objects.filter(o => !o.isPreview).length < 1) {
                                allowSnap = false;
                             }
                        }
                        if (allowSnap) {
                            currentSnap = potentialSnap;
                            wp = { x: currentSnap.x, y: currentSnap.y };
                        }
                    }
                }
                
                if (!currentSnap) { 
                    const isPlacingDimLine = (currentTool === 'dimHorizontal' || currentTool === 'dimVertical') && startPoint && definingPoint2;
                    const isPlacingDimRadiusText = currentTool === 'dimRadius' && drawing; 
                    
                    if (isDraggingControlPoint || isDraggingObject) { 
                        if (snapToGridEnabled) wp = snapToGrid(rawWp); 
                    } else if (!editModeActive) { 
                        if (!transformState.active && (drawing) && referencePointForDrawing && orthoModeEnabled && (isGeometricDrawingToolActive || isDimToolDefiningFirstOrSecondPoint )) {
                            wp = applyOrthoMode(rawWp, referencePointForDrawing);
                            if (snapToGridEnabled) { 
                                const gridSnappedAfterOrtho = snapToGrid(wp);
                                if(gridSnappedAfterOrtho.x !== wp.x || gridSnappedAfterOrtho.y !== wp.y) {
                                    wp = gridSnappedAfterOrtho;
                                }
                            }
                        } 
                        else if (snapToGridEnabled) {
                            const conditionForGridSnap = 
                                (isGeometricDrawingToolActive && (!startPoint || currentTool === 'spline' || (currentTool === 'arcCenterStartEnd' && !arcCenterPoint && !startPoint) || (currentTool === 'ellipse' && !ellipseCenter && !ellipseRadiusXPoint) )) || 
                                (isGeometricDrawingToolActive && startPoint) || 
                                isPlacingDimLine ||
                                isPlacingDimRadiusText ||
                                isTransformToolDefiningPoints || 
                                ((currentTool === 'dimHorizontal' || currentTool === 'dimVertical') && (!startPoint || !definingPoint2));

                            if (conditionForGridSnap) {
                                const snappedGridWp = snapToGrid(rawWp);
                                if (snappedGridWp.x !== rawWp.x || snappedGridWp.y !== rawWp.y) { 
                                   currentSnap = { type: 'grid', x: snappedGridWp.x, y: snappedGridWp.y, text: 'Rejilla' };
                                   wp = { ...currentSnap };
                                }
                            }
                        }
                    }
                }
                return wp;
            }

            function updateToolStatusAndCursor() {
                let sMsg = `Herramienta: ${currentTool.charAt(0).toUpperCase() + currentTool.slice(1).replace(/_/g, ' ')}`; 
                if (editModeActive && editableObject) {
                    sMsg = `Editando Puntos (ID: ${editableObject.id}, Tipo: ${editableObject.type}). Ctrl+Click para multiselect. Esc para salir.`;
                } else if (transformState.active) { 
                    if (transformState.mode === 'rotate') {
                        sMsg = "Rotar: Arrastre el manejador. Shift para snap. Enter para aplicar, Esc para cancelar.";
                    } else if (transformState.mode === 'scale') {
                        sMsg = "Escalar: Arrastre el manejador. Shift para snap. Enter para aplicar, Esc para cancelar.";
                    }
                } else if (currentTool === 'spline') {
                    let splineStatusText = splineInterpolationSelect.options[splineInterpolationSelect.selectedIndex].text;
                    if (drawing) {
                        if (currentSplineInterpolation === 'bezier') {
                            const numPts = currentSplinePoints.length;
                            if (numPts === 0) splineStatusText += " (Inicio)";
                            else if (numPts === 1) splineStatusText += " (CP1)";
                            else if ((numPts - 1) % 3 === 0 ) splineStatusText += " (Siguiente Pto. Ancla)"; 
                            else if ((numPts - 1) % 3 === 1 ) splineStatusText += " (Control 1)";
                            else if ((numPts - 1) % 3 === 2 ) splineStatusText += " (Control 2)";
                        }
                        sMsg = `Dibujando Spline (${splineStatusText} - ${currentSplinePoints.length} puntos. Enter para finalizar, Esc para cancelar)`;
                    } else { 
                         sMsg = `Herramienta: Spline (${splineStatusText}). Click para iniciar.`;
                    }
                } else if (currentTool === 'arc') { 
                    if (!drawing) sMsg = `Herramienta: Arco (3P). Defina punto inicial.`
                    else if (!definingPoint2) sMsg = `Arco (3P): Defina punto intermedio (Esc para cancelar)`;
                    else sMsg = `Arco (3P): Defina punto final (Esc para cancelar)`;
                } else if (currentTool === 'point') {
                    sMsg = "Herramienta: Punto. Click para crear un punto.";
                } else if (currentTool === 'rectangle') {
                    if (drawing) sMsg = "Dibujando Rect√°ngulo: Defina esquina opuesta (Esc para cancelar)";
                    else sMsg = "Herramienta: Rect√°ngulo. Defina primera esquina.";
                } else if (currentTool === 'arcCenterStartEnd') { 
                    if (!arcCenterPoint) sMsg = "Arco (C,I,F): Defina el CENTRO";
                    else if (!startPoint) sMsg = `Arco (C,I,F): Centro en (${arcCenterPoint.x.toFixed(1)}, ${arcCenterPoint.y.toFixed(1)}). Defina PUNTO INICIAL`;
                    else sMsg = `Arco (C,I,F): Centro en (${arcCenterPoint.x.toFixed(1)}, ${arcCenterPoint.y.toFixed(1)}), Inicio en (${startPoint.x.toFixed(1)}, ${startPoint.y.toFixed(1)}). Defina PUNTO FINAL (Ctrl para invertir direcci√≥n)`;
                } else if (currentTool === 'ellipse') {
                    if (!ellipseCenter) sMsg = "Elipse: Defina el CENTRO.";
                    else if (!ellipseRadiusXPoint) sMsg = `Elipse: Centro en (${ellipseCenter.x.toFixed(1)}, ${ellipseCenter.y.toFixed(1)}). Defina radio en EJE X.`;
                    else sMsg = `Elipse: Centro en (${ellipseCenter.x.toFixed(1)}, ${ellipseCenter.y.toFixed(1)}), Radio X definido. Defina radio en EJE Y.`;
                } else if (currentTool === 'hexagon') {
                    if (!startPoint) sMsg = "Hex√°gono: Defina el CENTRO.";
                    else sMsg = `Hex√°gono: Centro en (${startPoint.x.toFixed(1)}, ${startPoint.y.toFixed(1)}). Defina un V√âRTICE (radio).`;
                } else if (currentTool === 'star') {
                    if (!startPoint) sMsg = "Estrella: Defina el CENTRO.";
                    else sMsg = `Estrella (${starNumPoints} puntas): Centro en (${startPoint.x.toFixed(1)}, ${startPoint.y.toFixed(1)}). Defina RADIO EXTERIOR (punta).`;
                } else if (currentTool === 'offset') {
                    sMsg = `Equidistancia (Seleccione objeto. Lado: ${offsetSide === "left" ? "Izquierdo" : offsetSide === "right" ? "Derecho" : "Ambos"})`;
                    if (objectToOffset) {
                        sMsg = `Equidistancia (ID: ${objectToOffset.id}. Click para aplicar o Enter. Lado: ${offsetSide === "left" ? "Izquierdo" : offsetSide === "right" ? "Derecho" : "Ambos"})`;
                    }
                } else if (currentTool === 'trim') {
                    sMsg = "Recortar - ";
                    if (trimState.phase === 0 || trimState.phase === 1) sMsg += `Seleccione ${trimState.boundaries.length > 0 ? trimState.boundaries.length : ''} objetos l√≠mite (Enter para confirmar)`;
                    else if (trimState.phase === 2) sMsg += "Seleccione objeto a recortar";
                    else if (trimState.phase === 3) sMsg += "Haga clic en la parte a eliminar";
                } else if (currentTool === 'extend') {
                     if (!extendState.objectToExtendId) {
                        sMsg = "Alargar: Seleccione l√≠nea a alargar (cerca del extremo)";
                    } else if (!extendState.boundaryId && extendState.previewPoint) { 
                        sMsg = `Alargar (ID: ${extendState.objectToExtendId}): Seleccione objeto l√≠mite o Click/Enter para alargar al m√°s cercano`;
                    } else if (extendState.boundaryId && extendState.previewPoint) { 
                         sMsg = `Alargar (ID: ${extendState.objectToExtendId}): Click para alargar al l√≠mite (ID: ${extendState.boundaryId})`;
                    }
                     else if (!extendState.previewPoint && extendState.objectToExtendId) { 
                        sMsg = `Alargar (ID: ${extendState.objectToExtendId}): No hay l√≠mite de extensi√≥n. Seleccione objeto l√≠mite o Esc.`;
                    }
                } else if (currentTool === 'dimHorizontal') {
                    if (!drawing) sMsg = "Cota Horizontal: Defina primer punto (snap a objeto)";
                    else if (!definingPoint2) sMsg = "Cota Horizontal: Defina segundo punto (snap a objeto)";
                    else sMsg = "Cota Horizontal: Defina posici√≥n de l√≠nea de cota (snap a rejilla opcional)";
                } else if (currentTool === 'dimVertical') {
                    if (!drawing) sMsg = "Cota Vertical: Defina primer punto (snap a objeto)";
                    else if (!definingPoint2) sMsg = "Cota Vertical: Defina segundo punto (snap a objeto)";
                    else sMsg = "Cota Vertical: Defina posici√≥n de l√≠nea de cota (snap a rejilla opcional)";
                } else if (currentTool === 'dimRadius') {
                    const selCircle = getSelectedCircleForRadiusDim();
                    if (!selCircle) sMsg = "Cota Radio: Primero seleccione un c√≠rculo, luego active esta herramienta.";
                    else {
                        sMsg = `Cota Radio (para c√≠rculo ID: ${selCircle.id}): Defina posici√≥n del texto/directriz.`;
                        if(!drawing) drawing = true; 
                    }
                }
                toolStatusDiv.textContent = sMsg;

                ['select', 'line', 'circle', 'arc', 'arcCenterStartEnd', 'spline', 'point', 'rectangle', 'ellipse', 'hexagon', 'star', 'rotate', 'scale', 'offset', 'trim', 'extend', 'dimHorizontal', 'dimVertical', 'dimRadius'].forEach(t => {
                    const btn = document.getElementById(t + 'ToolBtn');
                    if (btn) btn.classList.remove('active');
                });
                editPointsBtn.classList.remove('edit-mode-active');

                if(currentTool.startsWith('edit_points_active')) { 
                    editPointsBtn.classList.add('edit-mode-active');
                } else {
                    const currentBtn = document.getElementById(currentTool + 'ToolBtn');
                    if (currentBtn) currentBtn.classList.add('active');
                }

                const singleEditableObjSelected = selectedObjectIds.length === 1 && objects.find(obj => obj.id === selectedObjectIds[0] && ['line', 'circle', 'spline', 'point', 'rectangle', 'arc', 'arcCenterStartEnd', 'ellipse', 'hexagon', 'star'].includes(obj.type));
                if (editModeActive && editableObject) {
                    editPointsBtn.style.display = 'inline-block'; editPointsBtn.disabled = false;
                    editPointsBtn.classList.add('edit-mode-active'); editPointsBtn.innerHTML = "<span class='icon'>‚úé</span>Finalizar Edici√≥n";
                } else if (singleEditableObjSelected && currentTool === 'select') {
                    editPointsBtn.style.display = 'inline-block'; editPointsBtn.disabled = false;
                    editPointsBtn.innerHTML = "<span class='icon'>‚úé</span>Editar Geometr√≠a";
                } else {
                    editPointsBtn.style.display = 'none';
                    if (editModeActive) exitEditMode(); 
                }

                splineOptionsContainer.style.display = (currentTool === 'spline' && !editModeActive) ? 'contents' : 'none';
                offsetControlsContainer.style.display = (currentTool === 'offset' && !editModeActive) ? 'flex' : 'none';

                if (isPanning || (isDraggingObject && !editModeActive) || (isDraggingControlPoint && editModeActive) || (transformState.active && transformState.dragStartPoint)) {
                    canvas.style.cursor = 'grabbing';
                } else if (editModeActive) {
                    canvas.style.cursor = 'default'; 
                } else if (transformState.active) { 
                    canvas.style.cursor = 'default'; 
                } else if (currentTool === 'select') {
                    canvas.style.cursor = 'default';
                } else if (['line', 'circle', 'arc', 'arcCenterStartEnd', 'spline', 'point', 'rectangle', 'ellipse', 'hexagon', 'star', 'offset', 'trim', 'extend', 'dimHorizontal', 'dimVertical', 'dimRadius'].includes(currentTool)) {
                    canvas.style.cursor = 'crosshair';
                } else {
                    canvas.style.cursor = 'default';
                }
            }


            function drawGrid() { 
                 const dpr = window.devicePixelRatio || 1;
                ctx.beginPath(); ctx.strokeStyle = '#353a40'; 
                ctx.lineWidth = 1 / (scale * dpr); 

                const wVMin = screenToWorld(0,0);
                const wVMax = screenToWorld(canvas.width / dpr, canvas.height / dpr);

                let dGridSize = GRID_SIZE;
                if(scale<0.5)dGridSize*=2; if(scale<0.25)dGridSize*=2; 
                if(scale>2)dGridSize/=2; if(scale>4)dGridSize/=2;    
                dGridSize = Math.max(dGridSize,1); 

                for(let x=Math.floor(wVMin.x/dGridSize)*dGridSize; x<wVMax.x; x+=dGridSize){ ctx.moveTo(x,wVMin.y);ctx.lineTo(x,wVMax.y); }
                for(let y=Math.floor(wVMin.y/dGridSize)*dGridSize; y<wVMax.y; y+=dGridSize){ ctx.moveTo(wVMin.x,y);ctx.lineTo(wVMax.x,y); }
                ctx.stroke();
            }
            function drawSplinePath(pathPoints, interpolationType) {
                if (!pathPoints || pathPoints.length === 0) return;
                ctx.moveTo(pathPoints[0].x, pathPoints[0].y);
                if (interpolationType === 'linear') {
                    if (pathPoints.length < 2) return;
                    for (let i = 1; i < pathPoints.length; i++) ctx.lineTo(pathPoints[i].x, pathPoints[i].y);
                } else if (interpolationType === 'cardinal' || interpolationType === 'catmull-rom') { 
                    if (pathPoints.length < 2) return;
                    if (pathPoints.length === 2) { ctx.lineTo(pathPoints[1].x, pathPoints[1].y); return; } 
                    for (let i = 0; i < pathPoints.length - 1; i++) {
                        const p0 = (i === 0) ? pathPoints[i] : pathPoints[i - 1]; 
                        const p1 = pathPoints[i];
                        const p2 = pathPoints[i + 1];
                        const p3 = (i === pathPoints.length - 2) ? pathPoints[i + 1] : pathPoints[i + 2]; 
                        const cp1x = p1.x + (p2.x - p0.x) / 6;
                        const cp1y = p1.y + (p2.y - p0.y) / 6;
                        const cp2x = p2.x - (p3.x - p1.x) / 6;
                        const cp2y = p2.y - (p3.y - p1.y) / 6;
                        ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, p2.x, p2.y);
                    }
                } else if (interpolationType === 'bezier') {
                    if (pathPoints.length < 4 || (pathPoints.length - 1) % 3 !== 0) {
                        for (let i = 1; i < pathPoints.length; i++) ctx.lineTo(pathPoints[i].x, pathPoints[i].y);
                        return;
                    }
                    for (let i = 0; i < pathPoints.length - 1; i += 3) {
                        if (pathPoints[i+3]) { 
                            ctx.bezierCurveTo(pathPoints[i+1].x, pathPoints[i+1].y, pathPoints[i+2].x, pathPoints[i+2].y, pathPoints[i+3].x, pathPoints[i+3].y);
                        } else { 
                            for (let j = i + 1; j < pathPoints.length; j++) ctx.lineTo(pathPoints[j].x, pathPoints[j].y);
                            break;
                        }
                    }
                }
            }

            function drawAllObjects() {
                objects.forEach(obj => {
                    const isSelGeneral = selectedObjectIds.includes(obj.id) && !editModeActive && !transformState.active && currentTool !== 'offset' && currentTool !== 'trim' && currentTool !== 'extend';
                    const isBeingEdited = editModeActive && editableObject && obj.id === editableObject.id;
                    const isBeingOffset = currentTool === 'offset' && objectToOffset && obj.id === objectToOffset.id;
                    const isTrimBoundary = currentTool === 'trim' && (trimState.phase === 0 || trimState.phase === 1) && trimState.boundaries.includes(obj.id);
                    const isObjectToTrim = currentTool === 'trim' && (trimState.phase === 2 || trimState.phase === 3) && trimState.objectToTrimId === obj.id;
                    const isObjectToExtend = currentTool === 'extend' && extendState.objectToExtendId === obj.id;
                    const isExtendBoundaryHovered = currentTool === 'extend' && extendState.objectToExtendId && !extendState.boundaryId && extendState.possibleExtensions.length > 0 && extendState.possibleExtensions[0].boundaryId === obj.id;
                    const isExtendBoundarySelected = currentTool === 'extend' && extendState.boundaryId === obj.id;
                    const isSelectedForRadiusDim = currentTool === 'dimRadius' && getSelectedCircleForRadiusDim()?.id === obj.id;
                    const isSelectedForTransform = transformState.active && transformState.objectsToTransform.includes(obj.id); 


                    ctx.beginPath();
                    let lW = 2; let sS = '#d4d4d4'; 

                    if (isBeingEdited) { lW = 2.5; sS = '#e67e22'; } 
                    else if (isBeingOffset) { lW = 3; sS = '#3db8d8'; } 
                    else if (isTrimBoundary) { lW = 3; sS = '#4ec9b0'; } 
                    else if (isObjectToTrim) { lW = 3; sS = '#ce9178'; } 
                    else if (isObjectToExtend) { lW = 3; sS = '#d7ba7d'; } 
                    else if (isExtendBoundarySelected) {lW = 3; sS = '#4caf50'; } 
                    else if (isExtendBoundaryHovered) {lW = 2.5; sS = '#8bc34a';} 
                    else if (isSelectedForRadiusDim) { lW = 3; sS = '#b294bb'; } 
                    else if (isSelectedForTransform) { lW = 3; sS = '#f0ad4e'; } 
                    else if (isSelGeneral) { lW = 3; sS = '#007acc'; } 

                    ctx.lineWidth = lW / scale; ctx.strokeStyle = sS;

                     if (obj.type === 'line') { ctx.moveTo(obj.startX, obj.startY); ctx.lineTo(obj.endX, obj.endY); }
                    else if (obj.type === 'circle') { ctx.arc(obj.centerX, obj.centerY, obj.radius, 0, Math.PI * 2); }
                    else if (obj.type === 'arc') { 
                        ctx.arc(obj.centerX, obj.centerY, obj.radius, obj.startAngle, obj.endAngle, !obj.clockwise); 
                    } else if (obj.type === 'arcCenterStartEnd') {
                        ctx.arc(obj.centerX, obj.centerY, obj.radius, obj.startAngle, obj.endAngle, obj.counterClockwise);
                    } else if (obj.type === 'spline') { drawSplinePath(obj.points, obj.interpolationType); }
                    else if (obj.type === 'point') {
                        const pointRadius = Math.max(1.5, 3 / scale); 
                        ctx.arc(obj.x, obj.y, pointRadius, 0, Math.PI * 2);
                        ctx.fillStyle = sS; 
                        ctx.fill();
                    } else if (obj.type === 'rectangle') {
                        ctx.rect(obj.x, obj.y, obj.width, obj.height);
                    } else if (obj.type === 'ellipse') {
                        ctx.ellipse(obj.centerX, obj.centerY, obj.radiusX, obj.radiusY, obj.rotation || 0, 0, 2 * Math.PI);
                    } else if (obj.type === 'hexagon' || obj.type === 'star') {
                        if (obj.points && obj.points.length > 1) {
                            ctx.moveTo(obj.points[0].x, obj.points[0].y);
                            for (let i = 1; i < obj.points.length; i++) {
                                ctx.lineTo(obj.points[i].x, obj.points[i].y);
                            }
                            ctx.closePath();
                        }
                    }
                    
                    if (obj.type !== 'point') { 
                         ctx.stroke();
                    }

                    if (isObjectToExtend && extendState.whichEnd) {
                        ctx.beginPath(); ctx.fillStyle = '#f44747'; 
                        const endToMark = extendState.whichEnd === 'start' ? {x: obj.startX, y: obj.startY} : {x: obj.endX, y: obj.endY};
                        ctx.arc(endToMark.x, endToMark.y, Math.max(3, CONTROL_POINT_RADIUS_SCREEN) / scale, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });
                
                if (currentTool === 'trim' && trimState.phase >= 2 && trimState.objectToTrimId) {
                    ctx.fillStyle = '#f44747'; 
                    trimState.intersections.forEach(p => {
                        ctx.beginPath(); ctx.arc(p.x, p.y, 4 / scale, 0, Math.PI * 2); ctx.fill();
                    });
                    if (trimState.previewSegment) {
                        ctx.beginPath(); ctx.strokeStyle = '#dcdcaa'; ctx.lineWidth = 3 / scale; 
                        ctx.setLineDash([3/scale, 3/scale]);
                        if (trimState.previewSegment.type === 'line') {
                            ctx.moveTo(trimState.previewSegment.startX, trimState.previewSegment.startY);
                            ctx.lineTo(trimState.previewSegment.endX, trimState.previewSegment.endY);
                        }
                        ctx.stroke(); ctx.setLineDash([]);
                    }
                }
            }
            
            function drawArrow(context, x, y, angle, size) { 
                context.save();
                context.translate(x, y);
                context.rotate(angle);
                context.beginPath();
                context.moveTo(0, 0);
                context.lineTo(-size, -size / 2.5); 
                context.lineTo(-size * 0.75, 0); 
                context.lineTo(-size, size / 2.5);
                context.closePath();
                context.fill();
                context.restore();
            }
            function drawAllDimensions() { 
                const dimTxtSize = DIM_TEXT_SIZE_SCREEN / scale;
                const dimArrowSize = DIM_ARROW_SIZE_SCREEN / scale;
                const extLineGap = DIM_EXT_LINE_GAP_SCREEN / scale; 
                const extLineOvershoot = DIM_EXT_LINE_OVERSHOOT_SCREEN / scale; 
                const textOffsetFromDimLine = DIM_OFFSET_FROM_LINE_SCREEN / scale;

                dimensions.forEach(dim => {
                    const isSelected = selectedDimensionIds.includes(dim.id);
                    ctx.strokeStyle = isSelected ? DIM_SELECTED_COLOR : DIM_COLOR;
                    ctx.fillStyle = isSelected ? DIM_SELECTED_COLOR : DIM_COLOR; 
                    ctx.lineWidth = (isSelected ? 1.5 : 1) / scale;
                    ctx.font = `bold ${dimTxtSize}px Arial`;
                    
                    if (dim.type === 'dimHorizontal') {
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'bottom'; 

                        ctx.beginPath();
                        ctx.moveTo(dim.p1.x, dim.p1.y - Math.sign(dim.p1.y - dim.offsetY) * extLineGap);
                        ctx.lineTo(dim.p1.x, dim.offsetY + Math.sign(dim.p1.y - dim.offsetY) * extLineOvershoot);
                        ctx.moveTo(dim.p2.x, dim.p2.y - Math.sign(dim.p2.y - dim.offsetY) * extLineGap);
                        ctx.lineTo(dim.p2.x, dim.offsetY + Math.sign(dim.p2.y - dim.offsetY) * extLineOvershoot);
                        ctx.stroke();

                        ctx.beginPath();
                        ctx.moveTo(dim.p1.x, dim.offsetY);
                        ctx.lineTo(dim.p2.x, dim.offsetY);
                        ctx.stroke();
                        
                        drawArrow(ctx, dim.p1.x, dim.offsetY, Math.atan2(0, dim.p2.x - dim.p1.x), dimArrowSize); 
                        drawArrow(ctx, dim.p2.x, dim.offsetY, Math.atan2(0, dim.p1.x - dim.p2.x), dimArrowSize); 
                        
                        ctx.fillText(dim.value.toFixed(1), (dim.p1.x + dim.p2.x) / 2, dim.offsetY - textOffsetFromDimLine);
                    } 
                    else if (dim.type === 'dimVertical') {
                        ctx.textBaseline = 'middle'; 

                        ctx.beginPath();
                        ctx.moveTo(dim.p1.x - Math.sign(dim.p1.x - dim.offsetX) * extLineGap, dim.p1.y);
                        ctx.lineTo(dim.offsetX + Math.sign(dim.p1.x - dim.offsetX) * extLineOvershoot, dim.p1.y);
                        ctx.moveTo(dim.p2.x - Math.sign(dim.p2.x - dim.offsetX) * extLineGap, dim.p2.y);
                        ctx.lineTo(dim.offsetX + Math.sign(dim.p2.x - dim.offsetX) * extLineOvershoot, dim.p2.y);
                        ctx.stroke();

                        ctx.beginPath();
                        ctx.moveTo(dim.offsetX, dim.p1.y);
                        ctx.lineTo(dim.offsetX, dim.p2.y);
                        ctx.stroke();

                        drawArrow(ctx, dim.offsetX, dim.p1.y, Math.atan2(dim.p2.y - dim.p1.y, 0), dimArrowSize); 
                        drawArrow(ctx, dim.offsetX, dim.p2.y, Math.atan2(dim.p1.y - dim.p2.y, 0), dimArrowSize); 

                        ctx.save();
                        const textX = dim.offsetX - textOffsetFromDimLine * (Math.sign(dim.p1.x - dim.offsetX) || 1); 
                        ctx.textAlign = (Math.sign(dim.p1.x - dim.offsetX) || 1) > 0 ? 'right' : 'left'; 
                        ctx.translate(textX, (dim.p1.y + dim.p2.y) / 2);
                        ctx.rotate(-Math.PI / 2);
                        ctx.textAlign = 'center'; 
                        ctx.fillText(dim.value.toFixed(1), 0, 0);
                        ctx.restore();
                    }
                    else if (dim.type === 'dimRadius') {
                        ctx.textAlign = 'left'; 
                        ctx.textBaseline = 'middle';

                        ctx.beginPath();
                        ctx.moveTo(dim.center.x, dim.center.y);
                        ctx.lineTo(dim.pointOnCircle.x, dim.pointOnCircle.y);
                        
                        let textDisplayX = dim.textPos.x;
                        let textDisplayY = dim.textPos.y;

                        if(dim.hasExtension) {
                           ctx.lineTo(dim.textPos.x, dim.textPos.y); 
                        }
                        ctx.stroke();
                        
                        const angleToPoint = Math.atan2(dim.pointOnCircle.y - dim.center.y, dim.pointOnCircle.x - dim.center.x);
                        drawArrow(ctx, dim.pointOnCircle.x, dim.pointOnCircle.y, angleToPoint + Math.PI, dimArrowSize); 

                        if (!dim.hasExtension) {
                             const textOffsetFromCirc = dimArrowSize + textOffsetFromDimLine;
                             textDisplayX = dim.pointOnCircle.x + textOffsetFromCirc * Math.cos(angleToPoint);
                             textDisplayY = dim.pointOnCircle.y + textOffsetFromCirc * Math.sin(angleToPoint);
                             
                             const cosAngle = Math.cos(angleToPoint);
                             const sinAngle = Math.sin(angleToPoint);

                             if (cosAngle < -0.1) ctx.textAlign = 'right'; else if (cosAngle > 0.1) ctx.textAlign = 'left'; else ctx.textAlign = 'center';
                             if (sinAngle < -0.707) ctx.textBaseline = 'top'; else if (sinAngle > 0.707) ctx.textBaseline = 'bottom'; else ctx.textBaseline = 'middle';
                        } else { 
                            const dxTextLeader = dim.textPos.x - dim.pointOnCircle.x;
                            if (Math.abs(dxTextLeader) < dimTxtSize * 0.2) ctx.textAlign = 'center'; 
                            else if (dxTextLeader > 0) ctx.textAlign = 'left'; 
                            else ctx.textAlign = 'right'; 
                        }
                        ctx.fillText(`R${dim.value.toFixed(1)}`, textDisplayX, textDisplayY);
                    }
                });
            }
            
            function drawPreview() { 
                if (transformState.active || currentTool === 'offset' || currentTool === 'trim' || currentTool === 'extend' || editModeActive ) return;
                 if (!drawing && currentTool !== 'point' && !(currentTool === 'arcCenterStartEnd' && arcCenterPoint) && !(currentTool === 'ellipse' && ellipseCenter) && currentTool !== 'spline' && currentTool !== 'hexagon' && currentTool !== 'star' ) return;
                if (currentTool !== 'spline' && currentTool !== 'point' && !(currentTool === 'arcCenterStartEnd' && arcCenterPoint) && !(currentTool === 'ellipse' && ellipseCenter) && !startPoint && currentSplinePoints.length === 0) return;


                ctx.strokeStyle = '#9cdcfe'; 
                ctx.lineWidth = 1 / scale; ctx.setLineDash([5 / scale, 5 / scale]); ctx.beginPath();
                if (currentTool === 'line' && startPoint) { 
                    ctx.moveTo(startPoint.x, startPoint.y); ctx.lineTo(mousePosWorld.x, mousePosWorld.y);
                } else if (currentTool === 'circle' && startPoint) { 
                    const radius = distance(startPoint, mousePosWorld);
                    ctx.arc(startPoint.x, startPoint.y, radius, 0, Math.PI * 2);
                } else if (currentTool === 'arc' && startPoint) { 
                    if (startPoint && !definingPoint2) { 
                        ctx.moveTo(startPoint.x, startPoint.y);
                        ctx.lineTo(mousePosWorld.x, mousePosWorld.y); 
                        ctx.stroke(); 
                        ctx.beginPath(); 
                        ctx.arc(startPoint.x, startPoint.y, 2 / scale, 0, Math.PI * 2); 
                        ctx.fillStyle = '#9cdcfe'; ctx.fill(); 
                    } else if (startPoint && definingPoint2) { 
                        const arcParams = calculateArcParameters(startPoint, definingPoint2, mousePosWorld);
                        if (arcParams) {
                            ctx.arc(arcParams.centerX, arcParams.centerY, arcParams.radius,
                                   arcParams.startAngle, arcParams.endAngle, !arcParams.clockwise); 
                        } else { 
                            ctx.moveTo(startPoint.x, startPoint.y);
                            ctx.lineTo(definingPoint2.x, definingPoint2.y);
                            ctx.lineTo(mousePosWorld.x, mousePosWorld.y);
                        }
                        ctx.stroke(); 
                        ctx.beginPath(); 
                        ctx.arc(startPoint.x, startPoint.y, 2 / scale, 0, Math.PI * 2); 
                        ctx.arc(definingPoint2.x, definingPoint2.y, 2 / scale, 0, Math.PI * 2); 
                        ctx.fillStyle = '#9cdcfe'; ctx.fill(); 
                    }
                } else if (currentTool === 'point' && mousePosWorld) { 
                    ctx.arc(mousePosWorld.x, mousePosWorld.y, 3 / scale, 0, Math.PI * 2);
                    ctx.fillStyle = '#9cdcfe'; ctx.fill();
                } else if (currentTool === 'rectangle' && startPoint && mousePosWorld) { 
                    ctx.rect(startPoint.x, startPoint.y, mousePosWorld.x - startPoint.x, mousePosWorld.y - startPoint.y);
                } else if (currentTool === 'arcCenterStartEnd') { 
                    if (arcCenterPoint && !startPoint && mousePosWorld) { 
                        ctx.moveTo(arcCenterPoint.x, arcCenterPoint.y);
                        ctx.lineTo(mousePosWorld.x, mousePosWorld.y); 
                        ctx.stroke(); 
                        ctx.beginPath(); 
                        ctx.arc(mousePosWorld.x, mousePosWorld.y, 2 / scale, 0, Math.PI * 2); 
                        ctx.fillStyle = '#9cdcfe'; ctx.fill();
                    } else if (arcCenterPoint && startPoint && mousePosWorld) { 
                        const radius = distance(arcCenterPoint, startPoint);
                        if (radius > 1e-6 / scale) { 
                            let sAngle = Math.atan2(startPoint.y - arcCenterPoint.y, startPoint.x - arcCenterPoint.x);
                            let eAngle = Math.atan2(mousePosWorld.y - arcCenterPoint.y, mousePosWorld.x - arcCenterPoint.x);
                            ctx.arc(arcCenterPoint.x, arcCenterPoint.y, radius, sAngle, eAngle, false); 
                        }
                    }
                    if (arcCenterPoint) {
                         ctx.stroke(); ctx.beginPath(); 
                        ctx.arc(arcCenterPoint.x, arcCenterPoint.y, 2 / scale, 0, Math.PI * 2);
                        ctx.fillStyle = '#ff00ff'; ctx.fill(); 
                    }
                    if (startPoint) { 
                        ctx.stroke(); ctx.beginPath(); 
                        ctx.arc(startPoint.x, startPoint.y, 2 / scale, 0, Math.PI * 2);
                        ctx.fillStyle = '#00ff00'; ctx.fill(); 
                    }
                } else if (currentTool === 'ellipse') {
                    if (ellipseCenter && !ellipseRadiusXPoint && mousePosWorld) { 
                        ctx.moveTo(ellipseCenter.x, ellipseCenter.y);
                        ctx.lineTo(mousePosWorld.x, ellipseCenter.y); 
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.arc(ellipseCenter.x, ellipseCenter.y, 2 / scale, 0, Math.PI * 2); 
                        ctx.fillStyle = '#9cdcfe'; ctx.fill();
                    } else if (ellipseCenter && ellipseRadiusXPoint && mousePosWorld) { 
                        const radiusX = Math.abs(ellipseRadiusXPoint.x - ellipseCenter.x);
                        const radiusY = Math.abs(mousePosWorld.y - ellipseCenter.y); 
                        if (radiusX > 1e-6 / scale && radiusY > 1e-6 / scale) {
                            ctx.ellipse(ellipseCenter.x, ellipseCenter.y, radiusX, radiusY, 0, 0, 2 * Math.PI);
                        }
                        ctx.stroke(); ctx.beginPath();
                        ctx.arc(ellipseCenter.x, ellipseCenter.y, 2 / scale, 0, Math.PI * 2);
                        ctx.fillStyle = '#ff00ff'; ctx.fill(); 
                        ctx.beginPath();
                        ctx.arc(ellipseRadiusXPoint.x, ellipseCenter.y, 2 / scale, 0, Math.PI * 2);
                        ctx.fillStyle = '#00ff00'; ctx.fill(); 
                    } else if (ellipseCenter) { 
                         ctx.beginPath();
                        ctx.arc(ellipseCenter.x, ellipseCenter.y, 2 / scale, 0, Math.PI * 2);
                        ctx.fillStyle = '#9cdcfe'; ctx.fill();
                    }
                } else if (currentTool === 'hexagon' && startPoint && mousePosWorld) { 
                    const radius = distance(startPoint, mousePosWorld);
                    if (radius > 1e-6 / scale) {
                        const initialAngle = Math.atan2(mousePosWorld.y - startPoint.y, mousePosWorld.x - startPoint.x);
                        for (let i = 0; i < 6; i++) {
                            const angle = (Math.PI / 3) * i + initialAngle;
                            const x = startPoint.x + radius * Math.cos(angle);
                            const y = startPoint.y + radius * Math.sin(angle);
                            if (i === 0) ctx.moveTo(x, y);
                            else ctx.lineTo(x, y);
                        }
                        ctx.closePath();
                    }
                    ctx.stroke(); ctx.beginPath();
                    ctx.arc(startPoint.x, startPoint.y, 2 / scale, 0, Math.PI * 2); 
                    ctx.fillStyle = '#9cdcfe'; ctx.fill();
                } else if (currentTool === 'star' && startPoint && mousePosWorld) { 
                    const outerRadius = distance(startPoint, mousePosWorld);
                    if (outerRadius > 1e-6 / scale) {
                        const innerRadius = outerRadius * starInnerRadiusFactor;
                        const angleStep = Math.PI / starNumPoints;
                        let rotation = Math.atan2(mousePosWorld.y - startPoint.y, mousePosWorld.x - startPoint.x); 

                        ctx.moveTo(startPoint.x + outerRadius * Math.cos(rotation), startPoint.y + outerRadius * Math.sin(rotation) );
                        for (let i = 0; i < starNumPoints * 2; i++) {
                            rotation += angleStep;
                            const currentRadius = (i % 2 === 0) ? outerRadius : innerRadius; 
                            ctx.lineTo( startPoint.x + currentRadius * Math.cos(rotation), startPoint.y + currentRadius * Math.sin(rotation) );
                        }
                        ctx.closePath();
                    }
                    ctx.stroke(); ctx.beginPath();
                    ctx.arc(startPoint.x, startPoint.y, 2 / scale, 0, Math.PI * 2); 
                    ctx.fillStyle = '#9cdcfe'; ctx.fill();
                } else if (currentTool === 'spline') {
                    if (currentSplinePoints.length === 0) { 
                        if (mousePosWorld) { ctx.arc(mousePosWorld.x, mousePosWorld.y, 2 / scale, 0, Math.PI * 2); }
                    } else { 
                        const previewPoints = [...currentSplinePoints, mousePosWorld];
                        if (currentSplineInterpolation === 'bezier') { 
                            ctx.moveTo(currentSplinePoints[0].x, currentSplinePoints[0].y);
                            for (let i = 1; i < currentSplinePoints.length; i++) ctx.lineTo(currentSplinePoints[i].x, currentSplinePoints[i].y);
                            if (mousePosWorld) ctx.lineTo(mousePosWorld.x, mousePosWorld.y);
                        } else { 
                            drawSplinePath(previewPoints, currentSplineInterpolation);
                        }
                    }
                } else if (currentTool === 'dimHorizontal' && startPoint) { 
                    if (!definingPoint2) { 
                        ctx.moveTo(startPoint.x, startPoint.y);
                        ctx.lineTo(mousePosWorld.x, mousePosWorld.y); 
                         ctx.stroke(); ctx.beginPath(); ctx.arc(startPoint.x, startPoint.y, 2/scale, 0, Math.PI*2); ctx.fillStyle = '#9cdcfe'; ctx.fill();
                    } else { 
                        const yOffset = mousePosWorld.y;
                        const extLineGap = DIM_EXT_LINE_GAP_SCREEN / scale;
                        const extLineOvershoot = DIM_EXT_LINE_OVERSHOOT_SCREEN / scale;

                        ctx.moveTo(startPoint.x, startPoint.y - Math.sign(startPoint.y - yOffset) * extLineGap);
                        ctx.lineTo(startPoint.x, yOffset + Math.sign(startPoint.y - yOffset) * extLineOvershoot);
                        ctx.moveTo(definingPoint2.x, definingPoint2.y - Math.sign(definingPoint2.y - yOffset) * extLineGap);
                        ctx.lineTo(definingPoint2.x, yOffset + Math.sign(definingPoint2.y - yOffset) * extLineOvershoot);
                        ctx.moveTo(startPoint.x, yOffset);
                        ctx.lineTo(definingPoint2.x, yOffset);
                    }
                }
                else if (currentTool === 'dimVertical' && startPoint) { 
                     if (!definingPoint2) { 
                        ctx.moveTo(startPoint.x, startPoint.y);
                        ctx.lineTo(mousePosWorld.x, mousePosWorld.y);
                        ctx.stroke(); ctx.beginPath(); ctx.arc(startPoint.x, startPoint.y, 2/scale, 0, Math.PI*2); ctx.fillStyle = '#9cdcfe'; ctx.fill();
                    } else { 
                        const xOffset = mousePosWorld.x;
                        const extLineGap = DIM_EXT_LINE_GAP_SCREEN / scale;
                        const extLineOvershoot = DIM_EXT_LINE_OVERSHOOT_SCREEN / scale;

                        ctx.moveTo(startPoint.x - Math.sign(startPoint.x - xOffset) * extLineGap, startPoint.y);
                        ctx.lineTo(xOffset + Math.sign(startPoint.x - xOffset) * extLineOvershoot, startPoint.y);
                        ctx.moveTo(definingPoint2.x - Math.sign(definingPoint2.x - xOffset) * extLineGap, definingPoint2.y);
                        ctx.lineTo(xOffset + Math.sign(definingPoint2.x - xOffset) * extLineOvershoot, definingPoint2.y);
                        ctx.moveTo(xOffset, startPoint.y);
                        ctx.lineTo(xOffset, definingPoint2.y);
                    }
                }
                else if (currentTool === 'dimRadius') { 
                    const circle = getSelectedCircleForRadiusDim();
                    if (circle) {
                        const dxMouse = mousePosWorld.x - circle.centerX;
                        const dyMouse = mousePosWorld.y - circle.centerY;
                        const distMouse = Math.hypot(dxMouse, dyMouse);
                        
                        if (distMouse > 1e-6) { 
                            const leaderEndX = circle.centerX + (dxMouse / distMouse) * circle.radius;
                            const leaderEndY = circle.centerY + (dyMouse / distMouse) * circle.radius;
                            
                            ctx.moveTo(circle.centerX, circle.centerY);
                            ctx.lineTo(leaderEndX, leaderEndY);
                            
                            const textPreviewDistThreshold = circle.radius * 0.2; 
                            if (Math.hypot(mousePosWorld.x - leaderEndX, mousePosWorld.y - leaderEndY) > textPreviewDistThreshold) {
                                ctx.lineTo(mousePosWorld.x, mousePosWorld.y);
                            }
                        }
                    }
                }
                
                if (currentTool !== 'point' && 
                    !(currentTool === 'arc' && startPoint && !definingPoint2) && 
                    !(currentTool === 'arcCenterStartEnd' && arcCenterPoint) && 
                    !(currentTool === 'ellipse' && ellipseCenter)) { 
                    ctx.stroke(); 
                }
                ctx.setLineDash([]);
            }


            function drawOffsetPreviewInternal() { 
                if (currentTool !== 'offset' || !objectToOffset || offsetPreviewObjects.length === 0) return;
                ctx.save(); ctx.strokeStyle = "#4ec9b0"; ctx.lineWidth = 1.5 / scale; 
                ctx.setLineDash([4 / scale, 4 / scale]);
                offsetPreviewObjects.forEach(previewObj => {
                    if (!previewObj) return;
                    ctx.beginPath();
                    if (previewObj.type === "line") { ctx.moveTo(previewObj.startX, previewObj.startY); ctx.lineTo(previewObj.endX, previewObj.endY); }
                    else if (previewObj.type === "circle") { ctx.arc(previewObj.centerX, previewObj.centerY, previewObj.radius, 0, Math.PI * 2); }
                    ctx.stroke();
                });
                ctx.setLineDash([]); ctx.restore();
            }
            function drawExtendPreview() {
                 if (currentTool !== 'extend' || !extendState.objectToExtendId || !extendState.previewPoint) return;
                const obj = objects.find(o => o.id === extendState.objectToExtendId);
                if (obj && obj.type === 'line') {
                    ctx.beginPath(); ctx.strokeStyle = '#d7ba7d'; ctx.lineWidth = 2 / scale; 
                    ctx.setLineDash([4 / scale, 4 / scale]);
                    const originalPoint = extendState.whichEnd === 'start' ? {x: obj.startX, y: obj.startY} : {x: obj.endX, y: obj.endY};
                    ctx.moveTo(originalPoint.x, originalPoint.y); ctx.lineTo(extendState.previewPoint.x, extendState.previewPoint.y);
                    ctx.stroke(); ctx.setLineDash([]);
                }
            }
            function drawControlPointHandles() {
                if (!editModeActive || !editableObject || !controlPointHandles) return;
                const dpr = window.devicePixelRatio || 1; 
                controlPointHandles.forEach(h => {
                    const sPos = worldToScreen(h.x, h.y); 
                    ctx.save();
                    ctx.setTransform(dpr, 0, 0, dpr, 0, 0); 
                    ctx.translate(sPos.x, sPos.y); 

                    ctx.beginPath();
                    ctx.arc(0, 0, CONTROL_POINT_RADIUS_SCREEN, 0, Math.PI * 2);
                    let fC = '#007bff'; let sC = '#ffffff'; let lW = 1; 
                    if (h.role === 'cp1' || h.role === 'cp2') fC = '#28a745'; 
                    else if (h.role === 'center') fC = '#6f42c1'; 
                    else if (h.role === 'radius') fC = '#17a2b8'; 
                    if (h.selected) { fC = '#fd7e14'; sC = '#333333'; lW = 2; } 
                    
                    ctx.fillStyle = fC; ctx.fill(); 
                    ctx.strokeStyle = sC; ctx.lineWidth = lW; ctx.stroke();
                    ctx.restore(); 
                });
            }

            function redrawCanvas() {
                const dpr = window.devicePixelRatio || 1;
                ctx.save();
                ctx.setTransform(dpr, 0, 0, dpr, 0, 0); 
                ctx.clearRect(0, 0, canvas.width / dpr, canvas.height / dpr); 
                ctx.restore();

                ctx.save();
                ctx.translate(offsetCanvas.x, offsetCanvas.y);
                ctx.scale(scale, scale);

                drawGrid();
                drawAllObjects();
                drawAllDimensions(); 
                drawPreview(); 
                
                if (transformState.active) { 
                    drawTransformControls();
                }

                drawOffsetPreviewInternal();
                drawExtendPreview(); 
                ctx.restore(); 

                showSnapIndicator(); 
                drawControlPointHandles(); 
            }


            function distanceToSegment(p,v,w) { return distance(p, getNearestPointOnLineSegment(p,v,w));}
            function distanceToCurve(p, cPts, iType) { 
                const worldHitTol = HIT_TOLERANCE_SCREEN / scale;
                if (!cPts || cPts.length < 2) return Infinity;
                if (iType === 'linear') {
                     for (let j = 0; j < cPts.length - 1; j++) {
                        if (distanceToSegment(p, cPts[j], cPts[j+1]) < worldHitTol) return 0; 
                    } return Infinity;
                }
                const numSegApprox = 20; let minDist = Infinity;
                if (iType === 'cardinal' || iType === 'catmull-rom') {
                    if (cPts.length === 2) return distanceToSegment(p, cPts[0], cPts[1]);
                    for (let i = 0; i < cPts.length - 1; i++) {
                        const p0 = (i === 0) ? cPts[i] : cPts[i - 1]; const p1 = cPts[i];
                        const p2 = cPts[i + 1]; const p3 = (i === cPts.length - 2) ? cPts[i + 1] : cPts[i + 2];
                        const cp1x = p1.x + (p2.x - p0.x) / 6; const cp1y = p1.y + (p2.y - p0.y) / 6;
                        const cp2x = p2.x - (p3.x - p1.x) / 6; const cp2y = p2.y - (p3.y - p1.y) / 6;
                        let prevPt = p1;
                        for (let k = 1; k <= numSegApprox; k++) {
                            const t = k / numSegApprox; const t_1 = 1 - t;
                            const B0 = t_1*t_1*t_1; const B1 = 3*t*t_1*t_1; const B2 = 3*t*t*t_1; const B3 = t*t*t;
                            const cPtVal = { x: B0*p1.x + B1*cp1x + B2*cp2x + B3*p2.x, y: B0*p1.y + B1*cp1y + B2*cp2y + B3*p2.y };
                            minDist = Math.min(minDist, distanceToSegment(p, prevPt, cPtVal)); if (minDist < worldHitTol) return minDist;
                            prevPt = cPtVal;
                        }
                    }
                } else if (iType === 'bezier') {
                    if (cPts.length < 4 || (cPts.length - 1) % 3 !== 0) return Infinity; 
                    for (let i = 0; i < cPts.length - 1; i += 3) {
                        const p1 = cPts[i]; const cp1 = cPts[i+1]; const cp2 = cPts[i+2]; const p2 = cPts[i+3];
                        if (!p2) break; 
                        let prevPt = p1;
                        for (let k = 1; k <= numSegApprox; k++) {
                            const t = k / numSegApprox; const t_1 = 1-t;
                            const B0=t_1*t_1*t_1; const B1=3*t*t_1*t_1; const B2=3*t*t*t_1; const B3=t*t*t;
                            const cPtVal = { x: B0*p1.x + B1*cp1.x + B2*cp2.x + B3*p2.x, y: B0*p1.y + B1*cp1.y + B2*cp2.y + B3*p2.y };
                            minDist = Math.min(minDist, distanceToSegment(p, prevPt, cPtVal)); if (minDist < worldHitTol) return minDist;
                            prevPt = cPtVal;
                        }
                    }
                } return minDist;
            }
            function distanceToArc(p, arc) { 
                const dx_center = p.x - arc.centerX;
                const dy_center = p.y - arc.centerY;
                const distToCenter = Math.hypot(dx_center, dy_center);
                
                let angleToPoint = Math.atan2(dy_center, dx_center);

                let sAngle = arc.startAngle;
                let eAngle = arc.endAngle;
                let arcIsClockwise = arc.type === 'arc' ? arc.clockwise : !arc.counterClockwise; 

                const normalize = (angle) => {
                    angle = angle % (2 * Math.PI);
                    if (angle < 0) angle += (2 * Math.PI);
                    return angle;
                };
                sAngle = normalize(sAngle);
                eAngle = normalize(eAngle);
                angleToPoint = normalize(angleToPoint);

                let angleInArc = false;
                const epsilon = 1e-5; 

                if (!arcIsClockwise) { 
                    if (sAngle < eAngle) { 
                        angleInArc = angleToPoint >= sAngle - epsilon && angleToPoint <= eAngle + epsilon;
                    } else { 
                        angleInArc = (angleToPoint >= sAngle - epsilon || angleToPoint <= eAngle + epsilon);
                    }
                } else { 
                    if (sAngle > eAngle) { 
                        angleInArc = angleToPoint <= sAngle + epsilon && angleToPoint >= eAngle - epsilon;
                    } else { 
                        angleInArc = (angleToPoint <= sAngle + epsilon || angleToPoint >= eAngle - epsilon);
                    }
                }
                
                let angularSpan = arcIsClockwise ? sAngle - eAngle : eAngle - sAngle;
                if (angularSpan < 0) angularSpan += 2 * Math.PI; 
                if (Math.abs(angularSpan) < epsilon * 10 || Math.abs(angularSpan - 2*Math.PI) < epsilon*10) angleInArc = true; 

                if (angleInArc) {
                    return Math.abs(distToCenter - arc.radius);
                } else {
                    const startArcPoint = { x: arc.centerX + arc.radius * Math.cos(arc.startAngle), y: arc.centerY + arc.radius * Math.sin(arc.startAngle) };
                    const endArcPoint   = { x: arc.centerX + arc.radius * Math.cos(arc.endAngle),   y: arc.centerY + arc.radius * Math.sin(arc.endAngle)   };
                    const distToStart = distance(p, startArcPoint);
                    const distToEnd   = distance(p, endArcPoint);
                    return Math.min(distToStart, distToEnd);
                }
            }

            function getObjectAtPosition(wp) { 
                if (editModeActive) return null; 
                const wHT = HIT_TOLERANCE_SCREEN / scale; 
                for (let i = objects.length - 1; i >= 0; i--) {
                    const obj = objects[i];
                    if (obj.isPreview) continue; 
                    if (obj.type === 'line') { if (distanceToSegment(wp, {x:obj.startX,y:obj.startY},{x:obj.endX,y:obj.endY}) < wHT) return obj; }
                    else if (obj.type === 'circle') { const dTC = distance(wp, {x:obj.centerX,y:obj.centerY}); if (Math.abs(dTC-obj.radius) < wHT) return obj; }
                    else if (obj.type === 'arc' || obj.type === 'arcCenterStartEnd') { 
                         if (distanceToArc(wp, obj) < wHT) return obj;
                    }
                    else if (obj.type === 'spline') { if (distanceToCurve(wp, obj.points, obj.interpolationType) < wHT) return obj; }
                    else if (obj.type === 'point') {
                        if (distance(wp, {x: obj.x, y: obj.y}) < wHT + (3 / scale)) return obj;
                    }
                    else if (obj.type === 'rectangle') {
                        const p1 = {x: obj.x, y: obj.y};
                        const p2 = {x: obj.x + obj.width, y: obj.y};
                        const p3 = {x: obj.x + obj.width, y: obj.y + obj.height};
                        const p4 = {x: obj.x, y: obj.y + obj.height};
                        if (distanceToSegment(wp, p1, p2) < wHT ||
                            distanceToSegment(wp, p2, p3) < wHT ||
                            distanceToSegment(wp, p3, p4) < wHT ||
                            distanceToSegment(wp, p4, p1) < wHT) return obj;
                    } else if (obj.type === 'ellipse') {
                        const dx = wp.x - obj.centerX;
                        const dy = wp.y - obj.centerY;
                        const rot = -(obj.rotation || 0); 
                        const cosR = Math.cos(rot); const sinR = Math.sin(rot);
                        const dx_rot = dx * cosR - dy * sinR;
                        const dy_rot = dx * sinR + dy * cosR;

                        const dist_norm_sq = (dx_rot / obj.radiusX)**2 + (dy_rot / obj.radiusY)**2;
                        const toleranceFactor = 0.15; 
                        if (Math.abs(dist_norm_sq - 1) < toleranceFactor * (wHT / Math.min(obj.radiusX, obj.radiusY)) ) { 
                            return obj;
                        }
                    } else if (obj.type === 'hexagon' || obj.type === 'star') {
                        if (obj.points && obj.points.length > 1) {
                            for (let k = 0; k < obj.points.length; k++) {
                                const p_current = obj.points[k];
                                const p_next = obj.points[(k + 1) % obj.points.length];
                                if (distanceToSegment(wp, p_current, p_next) < wHT) return obj;
                            }
                        }
                    }
                } return null; 
            }

            function getDimensionAtPosition(wp) { 
                if (editModeActive) return null;
                const worldHitTol = HIT_TOLERANCE_SCREEN / scale;
                const dimTxtSizeScaled = DIM_TEXT_SIZE_SCREEN / scale;
                const textOffsetFromDimLineScaled = DIM_OFFSET_FROM_LINE_SCREEN / scale;

                for (let i = dimensions.length - 1; i >= 0; i--) {
                    const dim = dimensions[i];
                    if (dim.type === 'dimHorizontal') {
                        if (Math.abs(wp.y - dim.offsetY) < worldHitTol &&
                            wp.x >= Math.min(dim.p1.x, dim.p2.x) - worldHitTol &&
                            wp.x <= Math.max(dim.p1.x, dim.p2.x) + worldHitTol) return dim;
                        
                        const textCenterX = (dim.p1.x + dim.p2.x) / 2;
                        const textCenterY = dim.offsetY - textOffsetFromDimLineScaled; 
                        const textWidthApprox = String(dim.value.toFixed(1)).length * dimTxtSizeScaled * 0.55; 
                        if (Math.abs(wp.y - textCenterY) < dimTxtSizeScaled / 1.5 && 
                            Math.abs(wp.x - textCenterX) < textWidthApprox / 2) return dim;
                    } else if (dim.type === 'dimVertical') {
                        if (Math.abs(wp.x - dim.offsetX) < worldHitTol &&
                            wp.y >= Math.min(dim.p1.y, dim.p2.y) - worldHitTol &&
                            wp.y <= Math.max(dim.p1.y, dim.p2.y) + worldHitTol) return dim;
                        
                        const textRotatedCenterX = dim.offsetX - textOffsetFromDimLineScaled * (Math.sign(dim.p1.x - dim.offsetX) || 1);
                        const textRotatedCenterY = (dim.p1.y + dim.p2.y) / 2;
                        if (distance(wp, {x: textRotatedCenterX, y: textRotatedCenterY}) < dimTxtSizeScaled * 1.2) return dim;

                    } else if (dim.type === 'dimRadius') {
                        if (distanceToSegment(wp, dim.center, dim.pointOnCircle) < worldHitTol) return dim;
                        if (dim.hasExtension && distanceToSegment(wp, dim.pointOnCircle, dim.textPos) < worldHitTol) return dim;
                        
                        let textDisplayX = dim.textPos.x;
                        let textDisplayY = dim.textPos.y;
                        if (!dim.hasExtension) { 
                             const angleToPoint = Math.atan2(dim.pointOnCircle.y - dim.center.y, dim.pointOnCircle.x - dim.center.x);
                             const textOffsetFromCirc = (DIM_ARROW_SIZE_SCREEN / scale) + (DIM_OFFSET_FROM_LINE_SCREEN / scale);
                             textDisplayX = dim.pointOnCircle.x + textOffsetFromCirc * Math.cos(angleToPoint);
                             textDisplayY = dim.pointOnCircle.y + textOffsetFromCirc * Math.sin(angleToPoint);
                        }
                        if (distance(wp, {x: textDisplayX, y: textDisplayY}) < dimTxtSizeScaled) return dim; 
                    }
                }
                return null;
            }
            
            function getControlPointHandleAtPosition(wp) { 
                if (!editModeActive || !controlPointHandles || !controlPointHandles.length) return null;
                const sMp = worldToScreen(wp.x, wp.y); 
                for (let i = controlPointHandles.length - 1; i >= 0; i--) { 
                    const h = controlPointHandles[i]; const hSp = worldToScreen(h.x, h.y); 
                    const d = distance(sMp, hSp); 
                    if (d <= CONTROL_POINT_RADIUS_SCREEN + (HIT_TOLERANCE_SCREEN / 2)) return h; 
                } return null;
            }

            function enterEditMode(objectToEdit) { 
                if (!objectToEdit || !['line', 'circle', 'spline', 'point', 'rectangle', 'arc', 'arcCenterStartEnd', 'ellipse', 'hexagon', 'star'].includes(objectToEdit.type)) return;
                exitAllToolModes(); 
                editModeActive = true;
                editableObject = objectToEdit;
                currentTool = `edit_points_active_${objectToEdit.type}`; 
                controlPointHandles = [];

                if (objectToEdit.type === 'line') {
                    controlPointHandles.push({ x: objectToEdit.startX, y: objectToEdit.startY, role: 'start', originalIndex: 0, selected: false });
                    controlPointHandles.push({ x: objectToEdit.endX,   y: objectToEdit.endY,   role: 'end',   originalIndex: 1, selected: false });
                } else if (objectToEdit.type === 'circle') {
                    controlPointHandles.push({ x: objectToEdit.centerX, y: objectToEdit.centerY, role: 'center', originalIndex: 0, selected: false });
                    const radiusHandleX = objectToEdit.centerX + objectToEdit.radius; 
                    const radiusHandleY = objectToEdit.centerY;
                    controlPointHandles.push({ x: radiusHandleX, y: radiusHandleY, role: 'radius', originalIndex: 1, selected: false });
                } else if (objectToEdit.type === 'spline') {
                    objectToEdit.points.forEach((p, idx) => {
                        let role = 'anchor'; 
                        if (objectToEdit.interpolationType === 'bezier') {
                            if (idx % 3 === 0) role = 'anchor'; 
                            else if ((idx - 1) % 3 === 0) role = 'cp1'; 
                            else if ((idx - 2) % 3 === 0) role = 'cp2'; 
                        }
                        controlPointHandles.push({ x: p.x, y: p.y, originalIndex: idx, role: role, selected: false });
                    });
                } else if (objectToEdit.type === 'point') {
                    controlPointHandles.push({ x: objectToEdit.x, y: objectToEdit.y, role: 'point', originalIndex: 0, selected: false });
                }

                selectedObjectIds = [objectToEdit.id]; 
                updateToolStatusAndCursor(); redrawCanvas();
            }
            function exitEditMode() { 
                if (!editModeActive) return;
                editModeActive = false; editableObject = null; currentSnap = null;
                if (controlPointHandles) controlPointHandles.forEach(h => h.selected = false); 
                controlPointHandles = []; isDraggingControlPoint = false; dragStartHandlePositions.clear();
                if (currentTool.startsWith('edit_points_active')) {
                    currentTool = 'select';
                }
                updateToolStatusAndCursor(); redrawCanvas();
            }

             function getPerpendicularVector(startX, startY, endX, endY, sideFactor = 1) { 
                const dx = endX - startX;
                const dy = endY - startY;
                const length = Math.hypot(dx, dy);
                if (length === 0) return { x: 0, y: 0 };
                return {
                    x: sideFactor * (-dy / length), 
                    y: sideFactor * (dx / length)
                };
            }
            function calculateOffsetForObject(obj, distanceVal, singleSide) { 
                if (obj.type === "line") {
                    const sideFactor = singleSide === "left" ? 1 : -1;
                    const perp = getPerpendicularVector(obj.startX, obj.startY, obj.endX, obj.endY, sideFactor);
                    return {
                        type: "line", isPreview: true,
                        startX: obj.startX + perp.x * distanceVal,
                        startY: obj.startY + perp.y * distanceVal,
                        endX: obj.endX + perp.x * distanceVal,
                        endY: obj.endY + perp.y * distanceVal,
                    };
                } else if (obj.type === "circle") {
                    const radiusChange = singleSide === "left" ? distanceVal : -distanceVal; 
                    const newRadius = Math.max(0.1 / scale, obj.radius + radiusChange); 
                    return {
                        type: "circle", isPreview: true,
                        centerX: obj.centerX,
                        centerY: obj.centerY,
                        radius: newRadius
                    };
                }
                console.warn(`Offset para ${obj.type} a√∫n no implementado.`);
                return null;
            }
            function updateOffsetPreview() { 
                if (!objectToOffset) {
                    offsetPreviewObjects = []; redrawCanvas(); return;
                }
                const distanceVal = parseFloat(offsetDistanceInput.value);
                if (isNaN(distanceVal) || distanceVal <= 0) { 
                    offsetPreviewObjects = []; redrawCanvas(); return;
                }
                offsetPreviewObjects = [];
                if (offsetSide === "left" || offsetSide === "right") {
                    const preview = calculateOffsetForObject(objectToOffset, distanceVal, offsetSide);
                    if (preview) offsetPreviewObjects.push(preview);
                } else if (offsetSide === "both") {
                    const previewLeft = calculateOffsetForObject(objectToOffset, distanceVal, "left");
                    const previewRight = calculateOffsetForObject(objectToOffset, distanceVal, "right");
                    if (previewLeft) offsetPreviewObjects.push(previewLeft);
                    if (previewRight) offsetPreviewObjects.push(previewRight);
                }
                redrawCanvas();
            }
            function applyCurrentOffset() { 
                if (offsetPreviewObjects.length > 0) {
                    offsetPreviewObjects.forEach(preview => {
                        if (preview) { 
                            objects.push({ ...preview, id: getNewObjectId(), isPreview: false });
                        }
                    });
                    selectedObjectIds = []; objectToOffset = null; offsetPreviewObjects = [];
                }
                redrawCanvas(); updateToolStatusAndCursor(); 
            }
            function setOffsetSideUI(side) { 
                offsetSide = side;
                offsetLeftBtn.classList.toggle("active", side === "left");
                offsetRightBtn.classList.toggle("active", side === "right");
                offsetBothBtn.classList.toggle("active", side === "both");
                if (objectToOffset) updateOffsetPreview(); 
                updateToolStatusAndCursor();
            }
            function resetTrimState() { 
                trimState.phase = 0; trimState.boundaries = []; trimState.objectToTrimId = null;
                trimState.intersections = []; trimState.previewSegment = null; currentSnap = null;
            }
            function lineLineIntersection(lineObj1, lineObj2, forTrimSegmentCheck = true) { 
                const x1 = lineObj1.startX, y1 = lineObj1.startY, x2 = lineObj1.endX, y2 = lineObj1.endY;
                const x3 = lineObj2.startX, y3 = lineObj2.startY, x4 = lineObj2.endX, y4 = lineObj2.endY;
                const den = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
                if (den === 0) return null; 
                const tNum = (x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4);
                const uNum = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3));
                const t = tNum / den; const u = uNum / den;

                if (forTrimSegmentCheck) { 
                     if (t >= -1e-9 && t <= 1.0 + 1e-9 && u >= -1e-9 && u <= 1.0 + 1e-9) {
                        return { x: x1 + t * (x2 - x1), y: y1 + t * (y2 - y1) };
                    }
                } else { 
                     return { x: x1 + t * (x2 - x1), y: y1 + t * (y2 - y1), t: t, u: u };
                }
                return null;
            }
            function calculateTrimIntersections() { 
                if (!trimState.objectToTrimId || trimState.boundaries.length === 0) return;
                const objToTrim = objects.find(o => o.id === trimState.objectToTrimId);
                if (!objToTrim || objToTrim.type !== 'line') { 
                    trimState.intersections = []; return;
                }
                trimState.intersections = [];
                trimState.boundaries.forEach(boundaryId => {
                    const boundaryObj = objects.find(o => o.id === boundaryId);
                    if (boundaryObj && boundaryObj.id !== objToTrim.id && boundaryObj.type === 'line') {
                        const intersect = lineLineIntersection(objToTrim, boundaryObj, true); 
                        if (intersect) trimState.intersections.push(intersect);
                    }
                });
                if (objToTrim.type === 'line' && trimState.intersections.length > 0) {
                    trimState.intersections.sort((a, b) => distance(a, {x:objToTrim.startX, y:objToTrim.startY}) - distance(b, {x:objToTrim.startX, y:objToTrim.startY}));
                }
            }
            function getTrimPreviewSegment(mouseWPos) { 
                if (!trimState.objectToTrimId || trimState.intersections.length === 0) return null;
                const objToTrim = objects.find(o => o.id === trimState.objectToTrimId);
                if (!objToTrim || objToTrim.type !== 'line') return null;

                let closestSegment = null; let minDistToMouse = Infinity;
                const worldHitTol = HIT_TOLERANCE_SCREEN / scale;
                const segments = [];
                let currentStart = {x: objToTrim.startX, y: objToTrim.startY};
                for (const intersect of trimState.intersections) {
                    segments.push({ type: 'line', startX: currentStart.x, startY: currentStart.y, endX: intersect.x, endY: intersect.y});
                    currentStart = intersect;
                }
                segments.push({ type: 'line', startX: currentStart.x, startY: currentStart.y, endX: objToTrim.endX, endY: objToTrim.endY});

                segments.forEach((seg, index) => {
                    if (distance({x:seg.startX,y:seg.startY}, {x:seg.endX,y:seg.endY}) < 1e-6 / scale) return;
                    const distVal = distanceToSegment(mouseWPos, {x: seg.startX, y: seg.startY}, {x: seg.endX, y: seg.endY});
                    if (distVal < minDistToMouse) {
                        minDistToMouse = distVal;
                        closestSegment = { ...seg, part: index }; 
                    }
                });
                if (minDistToMouse > worldHitTol * 2) return null; 
                return closestSegment;
            }
            function applyActualTrim() { 
                if (!trimState.objectToTrimId || !trimState.previewSegment) return;
                const objIndex = objects.findIndex(o => o.id === trimState.objectToTrimId);
                if (objIndex === -1) return;
                const objToModify = objects[objIndex];
                const partToRemove = trimState.previewSegment;

                if (objToModify.type === 'line') {
                    const segLengthThreshold = 1e-6 / scale; 
                    if (distance(partToRemove, {x:objToModify.startX, y:objToModify.startY}) < segLengthThreshold &&
                        distance({x:partToRemove.endX, y:partToRemove.endY}, {x:objToModify.endX, y:objToModify.endY}) < segLengthThreshold) {
                        objects.splice(objIndex, 1); 
                    }
                    else if (distance(partToRemove, {x:objToModify.startX, y:objToModify.startY}) < segLengthThreshold) {
                        objToModify.startX = partToRemove.endX; objToModify.startY = partToRemove.endY; 
                    }
                    else if (distance({x:partToRemove.endX, y:partToRemove.endY}, {x:objToModify.endX, y:objToModify.endY}) < segLengthThreshold) {
                        objToModify.endX = partToRemove.startX; objToModify.endY = partToRemove.startY; 
                    }
                    else {
                        const originalEnd = {x: objToModify.endX, y: objToModify.endY};
                        objToModify.endX = partToRemove.startX; objToModify.endY = partToRemove.startY; 
                        objects.push({ 
                            id: getNewObjectId(), type: 'line',
                            startX: partToRemove.endX, startY: partToRemove.endY,
                            endX: originalEnd.x, endY: originalEnd.y
                        });
                    }
                    if (distance({x:objToModify.startX, y:objToModify.startY}, {x:objToModify.endX, y:objToModify.endY}) < segLengthThreshold) {
                        objects.splice(objIndex, 1); 
                    }
                }
                resetTrimState(); setTool('trim'); 
                if (trimState.objectToTrimId && objects.find(o => o.id === trimState.objectToTrimId)) {
                    calculateTrimIntersections();
                } else { 
                    trimState.phase = (trimState.boundaries.length > 0) ? 2 : 0; 
                }
                redrawCanvas(); updateToolStatusAndCursor();
            }
            function resetExtendState() { 
                extendState = { objectToExtendId: null, boundaryId: null, whichEnd: null, previewPoint: null, possibleExtensions: [] };
                currentSnap = null;
            }
            function getClosestLineEnd(line, point) { 
                const distToStart = distance({ x: line.startX, y: line.startY }, point);
                const distToEnd = distance({ x: line.endX, y: line.endY }, point);
                if (Math.abs(distToStart - distToEnd) < (HIT_TOLERANCE_SCREEN / scale)) { 
                     const lineVector = {x: line.endX - line.startX, y: line.endY - line.startY};
                     const pointVector = {x: point.x - line.startX, y: point.y - line.startY};
                     const dotProduct = lineVector.x * pointVector.x + lineVector.y * pointVector.y;
                     return dotProduct > (Math.hypot(lineVector.x, lineVector.y)**2 / 2) ? 'end' : 'start';
                }
                return distToStart < distToEnd ? 'start' : 'end';
            }
            function getLineCircleIntersections(lineStart, lineEnd, circle) { 
                const cx = circle.centerX; const cy = circle.centerY; const r = circle.radius;
                const x1 = lineStart.x, y1 = lineStart.y; const x2 = lineEnd.x, y2 = lineEnd.y; 
                const dx = x2 - x1; const dy = y2 - y1;
                const A = dx * dx + dy * dy;
                const B = 2 * (dx * (x1 - cx) + dy * (y1 - cy));
                const C = (x1 - cx) * (x1 - cx) + (y1 - cy) * (y1 - cy) - r * r;
                const det = B * B - 4 * A * C; 
                if (A <= 1e-9 || det < -1e-9) { return []; } 
                else {
                    const results = [];
                    if (Math.abs(det) < 1e-9) { 
                        const t = -B / (2 * A); results.push({ x: x1 + t * dx, y: y1 + t * dy, t: t });
                    } else { 
                        const t1 = (-B + Math.sqrt(det)) / (2 * A); const t2 = (-B - Math.sqrt(det)) / (2 * A);
                        results.push({ x: x1 + t1 * dx, y: y1 + t1 * dy, t: t1 });
                        results.push({ x: x1 + t2 * dx, y: y1 + t2 * dy, t: t2 });
                    }
                    return results;
                }
            }
            function calculatePossibleExtensions() { 
                extendState.possibleExtensions = [];
                if (!extendState.objectToExtendId || !extendState.whichEnd) return;
                const targetLine = objects.find(o => o.id === extendState.objectToExtendId);
                if (!targetLine || targetLine.type !== 'line') return;

                let p0, dirVect; 
                if (extendState.whichEnd === 'start') {
                    p0 = { x: targetLine.startX, y: targetLine.startY };
                    dirVect = { x: targetLine.startX - targetLine.endX, y: targetLine.startY - targetLine.endY };
                } else {
                    p0 = { x: targetLine.endX, y: targetLine.endY };
                    dirVect = { x: targetLine.endX - targetLine.startX, y: targetLine.endY - targetLine.startY };
                }
                const lenDir = Math.hypot(dirVect.x, dirVect.y);
                if (lenDir < 1e-9) return; 
                const p1Ray = { x: p0.x + dirVect.x / lenDir * 1000000, y: p0.y + dirVect.y / lenDir * 1000000 }; 
                const lineToExtendRay = { startX: p0.x, startY: p0.y, endX: p1Ray.x, endY: p1Ray.y };

                objects.forEach(boundaryObj => {
                    if (boundaryObj.id === targetLine.id || boundaryObj.isPreview) return; 
                    if (boundaryObj.type === 'line') {
                        const intersect = lineLineIntersection(lineToExtendRay, boundaryObj, false); 
                        if (intersect && intersect.t > 1e-9 && intersect.u >= -1e-9 && intersect.u <= 1.0 + 1e-9) { 
                             extendState.possibleExtensions.push({
                                boundaryId: boundaryObj.id, point: { x: intersect.x, y: intersect.y },
                                distance: distance(p0, {x: intersect.x, y: intersect.y})
                            });
                        }
                    } else if (boundaryObj.type === 'circle') {
                        const intersects = getLineCircleIntersections(p0, p1Ray, boundaryObj);
                        intersects.forEach(intersect => {
                            if (intersect.t > 1e-9) { 
                                extendState.possibleExtensions.push({
                                    boundaryId: boundaryObj.id, point: { x: intersect.x, y: intersect.y },
                                    distance: distance(p0, {x: intersect.x, y: intersect.y})
                                });
                            }
                        });
                    }
                });
                extendState.possibleExtensions.sort((a,b) => a.distance - b.distance);
            }
            function updateExtendPreview() { 
                if (!extendState.objectToExtendId || !extendState.whichEnd) {
                    extendState.previewPoint = null; redrawCanvas(); return;
                }
                calculatePossibleExtensions();
                if (extendState.boundaryId) { 
                    const specificExt = extendState.possibleExtensions.find(ext => ext.boundaryId === extendState.boundaryId);
                    extendState.previewPoint = specificExt ? specificExt.point : null;
                } else if (extendState.possibleExtensions.length > 0) { 
                    extendState.previewPoint = extendState.possibleExtensions[0].point;
                } else {
                    extendState.previewPoint = null; 
                }
                redrawCanvas(); 
            }
            function applyActualExtend() { 
                if (!extendState.objectToExtendId || !extendState.whichEnd || !extendState.previewPoint) return;
                const targetObj = objects.find(o => o.id === extendState.objectToExtendId);
                if (!targetObj || targetObj.type !== 'line') return;

                if (extendState.whichEnd === 'start') { targetObj.startX = extendState.previewPoint.x; targetObj.startY = extendState.previewPoint.y; }
                else { targetObj.endX = extendState.previewPoint.x; targetObj.endY = extendState.previewPoint.y; }
                setTool('extend'); 
                redrawCanvas(); updateToolStatusAndCursor();
            }


            function getSelectedCircleForRadiusDim() {
                if (selectedObjectIds.length === 1) {
                    const obj = objects.find(o => o.id === selectedObjectIds[0]);
                    if (obj && obj.type === 'circle') return obj;
                }
                return null;
            }


            function exitAllToolModes(exceptTool = null) {
                if (editModeActive && exceptTool !== 'edit') exitEditMode();
                
                if (transformState.active && (exceptTool !== 'rotate' && exceptTool !== 'scale')) {
                    exitTransformTool(true); 
                }

                const isMultiStepToolInProgress = 
                    (currentTool === 'spline' && drawing && currentSplinePoints.length > 0 && exceptTool === 'spline') ||
                    (currentTool === 'arcCenterStartEnd' && drawing && (arcCenterPoint || startPoint) && exceptTool === 'arcCenterStartEnd') ||
                    (currentTool === 'ellipse' && drawing && (ellipseCenter || ellipseRadiusXPoint) && exceptTool === 'ellipse');


                if (!isMultiStepToolInProgress) {
                    if (drawing && exceptTool !== 'drawing' && !transformState.active) { 
                        if (currentTool === 'spline') cancelSplineDrawing(); 
                        else if (['arc', 'arcCenterStartEnd', 'ellipse', 'hexagon', 'star', 'rectangle'].includes(currentTool) || currentTool.startsWith('dim')) { 
                            drawing = false; startPoint = null; definingPoint2 = null; arcCenterPoint = null; ellipseCenter = null; ellipseRadiusXPoint = null;
                        }
                        else { drawing = false; startPoint = null; } 
                    }
                }


                if (objectToOffset && exceptTool !== 'offset') { objectToOffset = null; offsetPreviewObjects = []; }
                if ((trimState.phase > 0 || trimState.objectToTrimId) && exceptTool !== 'trim') resetTrimState();
                if (extendState.objectToExtendId && exceptTool !== 'extend') resetExtendState();
                
                isDraggingObject = false; isDraggingControlPoint = false; currentSnap = null;

                if (exceptTool !== 'arcCenterStartEnd') {
                    arcCenterPoint = null; 
                }
                if (exceptTool !== 'ellipse') {
                    ellipseCenter = null; ellipseRadiusXPoint = null;
                }
            }

            canvas.addEventListener('wheel', (e) => { 
                e.preventDefault(); 
                const r = canvas.getBoundingClientRect();
                const sX = event.clientX - r.left; const sY = event.clientY - r.top; 
                const wPMB = screenToWorld(sX,sY); 
                const zF = e.deltaY < 0 ? 1.1 : 1/1.1; 
                const newScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, scale * zF));
                if (newScale === scale) return; 
                
                const oldScale = scale;
                scale = newScale;

                offsetCanvas.x = sX - (sX - offsetCanvas.x) * (newScale / oldScale);
                offsetCanvas.y = sY - (sY - offsetCanvas.y) * (newScale / oldScale);
                
                redrawCanvas(); 
            });

            canvas.addEventListener('mousedown', (event) => {
                 const rawMousePosWorld = screenToWorld(event.clientX - canvas.getBoundingClientRect().left, event.clientY - canvas.getBoundingClientRect().top);
                 mousePosWorld = getMouseWorldPositionWithAids(event); 
                 
                 if (event.button === 1 || (event.button === 0 && event.altKey)) { 
                    isPanning = true;
                    const r = canvas.getBoundingClientRect();
                    panStartMousePos_Screen = {x:event.clientX-r.left,y:event.clientY-r.top};
                    event.preventDefault();
                 } else if (event.button === 0) { 
                    if (transformState.active) {
                        if (handleTransformMouseDown(event)) { 
                            redrawCanvas(); updateToolStatusAndCursor(); return; 
                        }
                    }
                    else if (editModeActive) { 
                        const cH = getControlPointHandleAtPosition(rawMousePosWorld); 
                        if (cH) {
                            if (!event.ctrlKey && !event.metaKey) controlPointHandles.forEach(h => h.selected = (h === cH));
                            else cH.selected = !cH.selected; 
                            isDraggingControlPoint = true; 
                            dragStartMousePos_World = { ...mousePosWorld }; 
                            dragStartHandlePositions.clear();
                            controlPointHandles.forEach(h => { if (h.selected) dragStartHandlePositions.set(h.originalIndex, {x:h.x,y:h.y}); });
                        } else controlPointHandles.forEach(h => h.selected = false); 
                    } else if (currentTool === 'offset') { 
                        const clickedObjectForOffset = getObjectAtPosition(rawMousePosWorld);
                        if (clickedObjectForOffset) {
                            if (objectToOffset && objectToOffset.id === clickedObjectForOffset.id) applyCurrentOffset(); 
                            else { 
                                objectToOffset = clickedObjectForOffset; selectedObjectIds = [objectToOffset.id]; updateOffsetPreview();
                            }
                        } else {
                             if (objectToOffset && offsetPreviewObjects.length > 0) applyCurrentOffset(); 
                             else { 
                                 objectToOffset = null; offsetPreviewObjects = []; selectedObjectIds = [];
                             }
                        }
                    } else if (currentTool === 'trim') { 
                        const clickedTrimObject = getObjectAtPosition(rawMousePosWorld);
                        if (trimState.phase === 0 || trimState.phase === 1) { 
                            if (clickedTrimObject) {
                                const index = trimState.boundaries.indexOf(clickedTrimObject.id);
                                if (index > -1) trimState.boundaries.splice(index, 1); else trimState.boundaries.push(clickedTrimObject.id);
                                selectedObjectIds = [...trimState.boundaries]; trimState.phase = 1; 
                            }
                        } else if (trimState.phase === 2) { 
                            if (clickedTrimObject && !trimState.boundaries.includes(clickedTrimObject.id)) {
                                trimState.objectToTrimId = clickedTrimObject.id; selectedObjectIds = [clickedTrimObject.id, ...trimState.boundaries];
                                calculateTrimIntersections(); trimState.phase = 3; 
                            }
                        } else if (trimState.phase === 3) { if (trimState.previewSegment) applyActualTrim(); }
                    } else if (currentTool === 'extend') { 
                        const clickedExtendObject = getObjectAtPosition(rawMousePosWorld);
                        if (!extendState.objectToExtendId) { 
                            if (clickedExtendObject && clickedExtendObject.type === 'line') {
                                extendState.objectToExtendId = clickedExtendObject.id;
                                extendState.whichEnd = getClosestLineEnd(clickedExtendObject, rawMousePosWorld);
                                selectedObjectIds = [clickedExtendObject.id]; updateExtendPreview();
                            }
                        } else { 
                            if (clickedExtendObject && clickedExtendObject.id !== extendState.objectToExtendId) {
                                extendState.boundaryId = clickedExtendObject.id; updateExtendPreview(); 
                                if (extendState.previewPoint) applyActualExtend(); 
                                else { extendState.boundaryId = null; updateExtendPreview(); } 
                            } else if (extendState.previewPoint) { 
                                if (extendState.possibleExtensions.length > 0 && distance(extendState.previewPoint, extendState.possibleExtensions[0].point) < 1e-6/scale) {
                                    extendState.boundaryId = extendState.possibleExtensions[0].boundaryId; 
                                    applyActualExtend();
                                }
                            }
                        }
                    } else if (currentTool === 'arc') { 
                        if (!drawing) { 
                            startPoint = { ...mousePosWorld };
                            definingPoint2 = null; 
                            drawing = true;
                        } else if (!definingPoint2) { 
                            if (distance(startPoint, mousePosWorld) > 1e-6 / scale) { 
                                definingPoint2 = { ...mousePosWorld };
                            } else { console.warn("Punto medio del arco (3P) demasiado cerca del punto inicial.");}
                        } else { 
                            if (distance(definingPoint2, mousePosWorld) > 1e-6 / scale && distance(startPoint, mousePosWorld) > 1e-6 / scale) {
                                const arcParams = calculateArcParameters(startPoint, definingPoint2, mousePosWorld);
                                if (arcParams && arcParams.radius > 0.1 / scale) { 
                                    objects.push({
                                        id: getNewObjectId(), type: 'arc',
                                        p1: { ...startPoint }, p2: { ...definingPoint2 }, p3: { ...mousePosWorld }, 
                                        centerX: arcParams.centerX, centerY: arcParams.centerY,
                                        radius: arcParams.radius,
                                        startAngle: arcParams.startAngle, endAngle: arcParams.endAngle,
                                        clockwise: arcParams.clockwise 
                                    });
                                } else { console.warn("No se pudo crear el arco (3P). Puntos colineales o radio muy peque√±o."); }
                            } else { console.warn("Punto final del arco (3P) demasiado cerca de los puntos anteriores."); }
                            drawing = false; startPoint = null; definingPoint2 = null; currentSnap = null;
                        }
                    } else if (currentTool === 'arcCenterStartEnd') { 
                        if (!arcCenterPoint) { 
                            arcCenterPoint = { ...mousePosWorld };
                            drawing = true; 
                        } else if (!startPoint) { 
                            if (distance(arcCenterPoint, mousePosWorld) > 1e-6 / scale) { 
                                startPoint = { ...mousePosWorld };
                            } else { console.warn("Punto inicial del arco (C,I,F) coincide con el centro."); }
                        } else { 
                            const radius = distance(arcCenterPoint, startPoint);
                            if (radius > 1e-6 / scale && distance(arcCenterPoint, mousePosWorld) > 1e-6 / scale) { 
                                let sAngle = Math.atan2(startPoint.y - arcCenterPoint.y, startPoint.x - arcCenterPoint.x);
                                let eAngle = Math.atan2(mousePosWorld.y - arcCenterPoint.y, mousePosWorld.x - arcCenterPoint.x);
                                let isCCW = !event.ctrlKey; 

                                objects.push({
                                    id: getNewObjectId(), type: 'arcCenterStartEnd',
                                    centerX: arcCenterPoint.x, centerY: arcCenterPoint.y,
                                    radius: radius,
                                    startAngle: sAngle, endAngle: eAngle,
                                    counterClockwise: isCCW, 
                                    pCenter: {...arcCenterPoint}, pStart: {...startPoint}, pEnd: {...mousePosWorld} 
                                });
                            } else { console.warn("Punto final del arco (C,I,F) inv√°lido (radio cero o coincide con centro)."); }
                            drawing = false; arcCenterPoint = null; startPoint = null; currentSnap = null;
                        }
                    } else if (currentTool === 'point') { 
                        objects.push({ id: getNewObjectId(), type: 'point', x: mousePosWorld.x, y: mousePosWorld.y });
                    } else if (currentTool === 'rectangle') { 
                        if (!drawing) { 
                            startPoint = { ...mousePosWorld };
                            drawing = true;
                        } else { 
                            const width = mousePosWorld.x - startPoint.x;
                            const height = mousePosWorld.y - startPoint.y;
                            if (Math.abs(width) > 1e-6 / scale && Math.abs(height) > 1e-6 / scale) { 
                                objects.push({
                                    id: getNewObjectId(), type: 'rectangle',
                                    x: Math.min(startPoint.x, mousePosWorld.x), 
                                    y: Math.min(startPoint.y, mousePosWorld.y),
                                    width: Math.abs(width),
                                    height: Math.abs(height)
                                });
                            }
                            drawing = false; startPoint = null; currentSnap = null;
                        }
                    } else if (currentTool === 'ellipse') {
                        if (!ellipseCenter) { 
                            ellipseCenter = { ...mousePosWorld };
                            drawing = true;
                        } else if (!ellipseRadiusXPoint) { 
                            if (Math.abs(mousePosWorld.x - ellipseCenter.x) > 1e-6 / scale) { 
                                ellipseRadiusXPoint = { x: mousePosWorld.x, y: ellipseCenter.y }; 
                            } else { console.warn("Radio X de la elipse no puede ser cero."); }
                        } else { 
                            const radiusX = Math.abs(ellipseRadiusXPoint.x - ellipseCenter.x);
                            const radiusY = Math.abs(mousePosWorld.y - ellipseCenter.y); 
                            if (radiusX > 1e-6 / scale && radiusY > 1e-6 / scale) { 
                                objects.push({
                                    id: getNewObjectId(), type: 'ellipse',
                                    centerX: ellipseCenter.x, centerY: ellipseCenter.y,
                                    radiusX: radiusX, radiusY: radiusY,
                                    rotation: 0 
                                });
                            } else { console.warn("Radios de la elipse inv√°lidos."); }
                            drawing = false; ellipseCenter = null; ellipseRadiusXPoint = null; currentSnap = null;
                        }
                    } else if (currentTool === 'hexagon') {
                        if (!startPoint) { 
                            startPoint = { ...mousePosWorld };
                            drawing = true;
                        } else { 
                            const radius = distance(startPoint, mousePosWorld);
                            if (radius > 1e-6 / scale) {
                                const hexPoints = [];
                                const initialAngle = Math.atan2(mousePosWorld.y - startPoint.y, mousePosWorld.x - startPoint.x); 
                                for (let i = 0; i < 6; i++) {
                                    const angle = (Math.PI / 3) * i + initialAngle;
                                    hexPoints.push({
                                        x: startPoint.x + radius * Math.cos(angle),
                                        y: startPoint.y + radius * Math.sin(angle)
                                    });
                                }
                                objects.push({
                                    id: getNewObjectId(), type: 'hexagon',
                                    centerX: startPoint.x, centerY: startPoint.y, 
                                    radius: radius, 
                                    points: hexPoints 
                                });
                            }
                            drawing = false; startPoint = null; currentSnap = null;
                        }
                    } else if (currentTool === 'star') {
                        if (!startPoint) { 
                            startPoint = { ...mousePosWorld };
                            drawing = true;
                        } else { 
                            const outerRadius = distance(startPoint, mousePosWorld);
                            if (outerRadius > 1e-6 / scale) {
                                const innerRadius = outerRadius * starInnerRadiusFactor;
                                const starPoints = [];
                                let rotation = Math.atan2(mousePosWorld.y - startPoint.y, mousePosWorld.x - startPoint.x); 
                                const angleStep = Math.PI / starNumPoints;

                                for (let i = 0; i < starNumPoints * 2; i++) {
                                    const currentRadius = (i % 2 === 0) ? outerRadius : innerRadius; 
                                    starPoints.push({
                                        x: startPoint.x + currentRadius * Math.cos(rotation),
                                        y: startPoint.y + currentRadius * Math.sin(rotation)
                                    });
                                    rotation += angleStep;
                                }
                                objects.push({
                                    id: getNewObjectId(), type: 'star',
                                    centerX: startPoint.x, centerY: startPoint.y,
                                    outerRadius: outerRadius, innerRadius: innerRadius,
                                    numPoints: starNumPoints,
                                    points: starPoints
                                });
                            }
                            drawing = false; startPoint = null; currentSnap = null;
                        }
                    } else if (currentTool === 'dimHorizontal' || currentTool === 'dimVertical') { 
                        if (!drawing) { 
                            startPoint = { ...mousePosWorld }; 
                            drawing = true;
                            definingPoint2 = null;
                        } else if (!definingPoint2) { 
                            if (distance(startPoint, mousePosWorld) > 1e-6 / scale) { 
                                definingPoint2 = { ...mousePosWorld };
                            } else { console.warn("Segundo punto de cota coincide con el primero."); }
                        } else { 
                            const value = (currentTool === 'dimHorizontal') ? 
                                          Math.abs(startPoint.x - definingPoint2.x) : 
                                          Math.abs(startPoint.y - definingPoint2.y);
                            if (value > 1e-6 / scale) { 
                                dimensions.push({
                                    id: getNewDimensionId(),
                                    type: currentTool, 
                                    p1: { ...startPoint },
                                    p2: { ...definingPoint2 },
                                    offsetY: (currentTool === 'dimHorizontal') ? mousePosWorld.y : null, 
                                    offsetX: (currentTool === 'dimVertical') ? mousePosWorld.x : null,   
                                    value: value
                                });
                            } else { console.warn("Cota de longitud cero."); }
                            drawing = false; startPoint = null; definingPoint2 = null; currentSnap = null;
                        }
                    } else if (currentTool === 'dimRadius') { 
                        const circle = getSelectedCircleForRadiusDim();
                        if (circle && drawing) { 
                            const dxMouse = mousePosWorld.x - circle.centerX; 
                            const dyMouse = mousePosWorld.y - circle.centerY;
                            const distMouse = Math.hypot(dxMouse, dyMouse);
                            
                            let pointOnCircle, textPos, hasExtension = false;

                            if (distMouse > 1e-6) { 
                                pointOnCircle = {
                                    x: circle.centerX + (dxMouse / distMouse) * circle.radius,
                                    y: circle.centerY + (dyMouse / distMouse) * circle.radius
                                };
                                
                                const textDistFromCircumference = Math.hypot(mousePosWorld.x - pointOnCircle.x, mousePosWorld.y - pointOnCircle.y);
                                const extensionThreshold = circle.radius * 0.1 + (DIM_ARROW_SIZE_SCREEN + DIM_TEXT_SIZE_SCREEN*2) / scale;


                                if (textDistFromCircumference > extensionThreshold ) {
                                    hasExtension = true;
                                    textPos = { ...mousePosWorld }; 
                                } else {
                                    textPos = { ...mousePosWorld }; 
                                }
                                
                                dimensions.push({
                                    id: getNewDimensionId(),
                                    type: 'dimRadius',
                                    center: { x: circle.centerX, y: circle.centerY },
                                    radius: circle.radius, 
                                    value: circle.radius,  
                                    pointOnCircle: pointOnCircle, 
                                    textPos: textPos, 
                                    hasExtension: hasExtension
                                });
                                currentSnap = null; 
                                drawing = false; 
                            }
                        } else if (!circle) {
                            toolStatusDiv.textContent = "Cota Radio: Primero seleccione un c√≠rculo.";
                        }
                    } else { 
                        const clickedDimension = getDimensionAtPosition(rawMousePosWorld);
                        const objectForSelection = !clickedDimension ? getObjectAtPosition(rawMousePosWorld) : null;

                        if (clickedDimension && currentTool === 'select') { 
                            if (event.ctrlKey || event.metaKey) { 
                                const i = selectedDimensionIds.indexOf(clickedDimension.id);
                                if (i > -1) selectedDimensionIds.splice(i,1); else selectedDimensionIds.push(clickedDimension.id);
                            } else { 
                                selectedDimensionIds = [clickedDimension.id];
                                selectedObjectIds = []; 
                            }
                            isDraggingObject = true; 
                            dragStartMousePos_World = { ...mousePosWorld }; 
                            dragStartDimensionData.clear();
                            dragStartObjectPositions.clear(); 
                            dimensions.forEach(dim => {
                                if (selectedDimensionIds.includes(dim.id)) {
                                    if (dim.type === 'dimHorizontal') dragStartDimensionData.set(dim.id, { p1x: dim.p1.x, p1y: dim.p1.y, p2x: dim.p2.x, p2y:dim.p2.y, offsetY: dim.offsetY });
                                    else if (dim.type === 'dimVertical') dragStartDimensionData.set(dim.id, { p1x: dim.p1.x, p1y: dim.p1.y, p2x: dim.p2.x, p2y:dim.p2.y, offsetX: dim.offsetX });
                                    else if (dim.type === 'dimRadius') dragStartDimensionData.set(dim.id, { centerX: dim.center.x, centerY: dim.center.y, pointX: dim.pointOnCircle.x, pointY: dim.pointOnCircle.y, textX: dim.textPos.x, textY: dim.textPos.y });
                                }
                            });

                        } else if (objectForSelection && selectedObjectIds.includes(objectForSelection.id) && currentTool === 'select') { 
                            isDraggingObject = true; 
                            dragStartMousePos_World = { ...mousePosWorld };
                            dragStartObjectPositions.clear();
                            dragStartDimensionData.clear(); 
                            objects.forEach(obj => {
                                if (selectedObjectIds.includes(obj.id)) {
                                   if (obj.type==='line') dragStartObjectPositions.set(obj.id, {startX:obj.startX, startY:obj.startY, endX:obj.endX, endY:obj.endY});
                                    else if (obj.type==='circle') dragStartObjectPositions.set(obj.id, {centerX:obj.centerX, centerY:obj.centerY, radius:obj.radius});
                                    else if (obj.type==='arc' || obj.type==='arcCenterStartEnd') dragStartObjectPositions.set(obj.id, { 
                                        centerX: obj.centerX, centerY: obj.centerY,
                                        p1x: obj.p1?.x, p1y: obj.p1?.y, 
                                        p2x: obj.p2?.x, p2y: obj.p2?.y,
                                        p3x: obj.p3?.x, p3y: obj.p3?.y,
                                        pCenterX: obj.pCenter?.x, pCenterY: obj.pCenter?.y,
                                        pStartX: obj.pStart?.x, pStartY: obj.pStart?.y,
                                        pEndX: obj.pEnd?.x, pEndY: obj.pEnd?.y,
                                        startAngle: obj.startAngle, endAngle: obj.endAngle, radius: obj.radius
                                    });
                                    else if (obj.type==='spline') dragStartObjectPositions.set(obj.id, {points:JSON.parse(JSON.stringify(obj.points))}); 
                                    else if (obj.type==='point') dragStartObjectPositions.set(obj.id, {x: obj.x, y: obj.y});
                                    else if (obj.type==='rectangle') dragStartObjectPositions.set(obj.id, {x: obj.x, y: obj.y, width: obj.width, height: obj.height});
                                    else if (obj.type==='ellipse') dragStartObjectPositions.set(obj.id, {centerX: obj.centerX, centerY: obj.centerY, radiusX: obj.radiusX, radiusY: obj.radiusY, rotation: obj.rotation});
                                    else if (obj.type==='hexagon' || obj.type==='star') dragStartObjectPositions.set(obj.id, {centerX: obj.centerX, centerY: obj.centerY, radius: obj.radius, outerRadius: obj.outerRadius, points: JSON.parse(JSON.stringify(obj.points))});
                                }
                            });
                        } else if (objectForSelection && currentTool === 'select') { 
                            if (event.ctrlKey || event.metaKey) { 
                                const i = selectedObjectIds.indexOf(objectForSelection.id);
                                if(i>-1) selectedObjectIds.splice(i,1); else selectedObjectIds.push(objectForSelection.id);
                            } else { 
                                selectedObjectIds = [objectForSelection.id];
                                selectedDimensionIds = []; 
                            }
                        } else if (currentTool === 'select') { 
                            if (!(event.ctrlKey || event.metaKey)) { 
                                selectedObjectIds = [];
                                selectedDimensionIds = [];
                            }
                        }

                        if (['line', 'circle'].includes(currentTool)) {
                            if (!drawing) { 
                                startPoint = { ...mousePosWorld }; 
                                drawing = true; 
                            } else { 
                                if (currentTool === 'line') {
                                    if(distance(startPoint, mousePosWorld) > 1e-6 / scale) 
                                        objects.push({id:getNewObjectId(),type:'line',startX:startPoint.x,startY:startPoint.y,endX:mousePosWorld.x,endY:mousePosWorld.y});
                                } else if (currentTool === 'circle') {
                                    const radius = distance(startPoint, mousePosWorld); 
                                    if (radius > 0.1/scale) objects.push({id:getNewObjectId(),type:'circle',centerX:startPoint.x,centerY:startPoint.y,radius:radius});
                                }
                                startPoint = null; drawing = false; currentSnap = null; 
                            }
                        } else if (currentTool === 'spline') { 
                            currentSplinePoints.push({ ...mousePosWorld }); 
                            drawing = true; 
                        }
                     }
                 }
                 redrawCanvas(); updateToolStatusAndCursor();
            });

            canvas.addEventListener('mousemove', (event) => {
                const canvasRect = canvas.getBoundingClientRect();
                lastKnownMouseScreenPos = {x: event.clientX - canvasRect.left, y: event.clientY - canvasRect.top};
                const prevMousePosWorld = { ...mousePosWorld }; 
                mousePosWorld = getMouseWorldPositionWithAids(event); 

                if (isPanning) {
                    const r = canvas.getBoundingClientRect();
                    const cSX = event.clientX-r.left; const cSY = event.clientY-r.top;
                    const dX = cSX - panStartMousePos_Screen.x; const dY = cSY - panStartMousePos_Screen.y;
                    offsetCanvas.x += dX; offsetCanvas.y += dY;
                    panStartMousePos_Screen = {x:cSX,y:cSY}; 
                } else if (transformState.active && transformState.dragStartPoint) { 
                    handleTransformMouseMove(event);
                } else if (isDraggingControlPoint && editModeActive && editableObject && dragStartHandlePositions.size > 0) { 
                    const deltaX_world = mousePosWorld.x - dragStartMousePos_World.x; 
                    const deltaY_world = mousePosWorld.y - dragStartMousePos_World.y;
                    controlPointHandles.forEach(h => {
                        if (h.selected && dragStartHandlePositions.has(h.originalIndex)) {
                            const originalHandlePos = dragStartHandlePositions.get(h.originalIndex);
                            const newX = originalHandlePos.x + deltaX_world; const newY = originalHandlePos.y + deltaY_world;
                            h.x = newX; h.y = newY; 
                            if (editableObject.type === 'line') {
                                if (h.role === 'start') { editableObject.startX = newX; editableObject.startY = newY; }
                                else if (h.role === 'end') { editableObject.endX = newX; editableObject.endY = newY; }
                            } else if (editableObject.type === 'circle') {
                                if (h.role === 'center') {
                                    editableObject.centerX = newX; editableObject.centerY = newY;
                                    const radiusHandle = controlPointHandles.find(handle => handle.role === 'radius');
                                    if (radiusHandle && !radiusHandle.selected) { 
                                        const originalRadiusHandlePos = dragStartHandlePositions.get(radiusHandle.originalIndex) || {x: editableObject.centerX + editableObject.radius, y: editableObject.centerY}; 
                                        const originalCenterPos = dragStartHandlePositions.get(h.originalIndex); 
                                        let angle;
                                        if (originalCenterPos && originalRadiusHandlePos) angle = Math.atan2(originalRadiusHandlePos.y - originalCenterPos.y, originalRadiusHandlePos.x - originalCenterPos.x);
                                        else angle = Math.atan2(radiusHandle.y - newY, radiusHandle.x - newX); 
                                        radiusHandle.x = newX + editableObject.radius * Math.cos(angle);
                                        radiusHandle.y = newY + editableObject.radius * Math.sin(angle);
                                    }
                                } else if (h.role === 'radius') {
                                    editableObject.radius = Math.max(0.1/scale, distance({x:newX,y:newY}, {x:editableObject.centerX, y:editableObject.centerY}));
                                    const angle = Math.atan2(newY - editableObject.centerY, newX - editableObject.centerX);
                                    h.x = editableObject.centerX + editableObject.radius * Math.cos(angle);
                                    h.y = editableObject.centerY + editableObject.radius * Math.sin(angle);
                                }
                            } else if (editableObject.type === 'spline') {
                                editableObject.points[h.originalIndex] = { x: newX, y: newY };
                            }
                        }
                    });
                } else if (isDraggingObject && !editModeActive && dragStartMousePos_World) { 
                    const dX = mousePosWorld.x - dragStartMousePos_World.x; 
                    const dY = mousePosWorld.y - dragStartMousePos_World.y;
                    
                    objects.forEach(obj => {
                        if (selectedObjectIds.includes(obj.id) && dragStartObjectPositions.has(obj.id)) {
                            const oP = dragStartObjectPositions.get(obj.id); 
                            if(obj.type==='line'){obj.startX=oP.startX+dX;obj.startY=oP.startY+dY;obj.endX=oP.endX+dX;obj.endY=oP.endY+dY;}
                            else if(obj.type==='circle'){obj.centerX=oP.centerX+dX;obj.centerY=oP.centerY+dY;} 
                            else if(obj.type==='arc' || obj.type==='arcCenterStartEnd'){
                                obj.centerX = oP.centerX + dX; obj.centerY = oP.centerY + dY;
                                if (obj.type === 'arcCenterStartEnd' && obj.pStart && obj.pEnd) { 
                                    obj.pCenter.x = oP.pCenterX + dX; obj.pCenter.y = oP.pCenterY + dY;
                                    obj.pStart.x = oP.pStartX + dX;   obj.pStart.y = oP.pStartY + dY;
                                    obj.pEnd.x = oP.pEndX + dX;       obj.pEnd.y = oP.pEndY + dY;
                                    obj.startAngle = Math.atan2(obj.pStart.y - obj.centerY, obj.pStart.x - obj.centerX);
                                    obj.endAngle = Math.atan2(obj.pEnd.y - obj.centerY, obj.pEnd.x - obj.centerX);
                                } else if (obj.type === 'arc' && obj.p1 && obj.p3 && obj.p2){ 
                                    obj.p1.x = oP.p1x + dX; obj.p1.y = oP.p1y + dY;
                                    obj.p2.x = oP.p2x + dX; obj.p2.y = oP.p2y + dY;
                                    obj.p3.x = oP.p3x + dX; obj.p3.y = oP.p3y + dY;
                                    const newArcParams = calculateArcParameters(obj.p1, obj.p2, obj.p3);
                                    if(newArcParams) {
                                        obj.centerX = newArcParams.centerX; obj.centerY = newArcParams.centerY;
                                        obj.radius = newArcParams.radius; obj.startAngle = newArcParams.startAngle;
                                        obj.endAngle = newArcParams.endAngle; obj.clockwise = newArcParams.clockwise;
                                    }
                                }
                                if(oP.radius) obj.radius = oP.radius; 


                            }
                            else if(obj.type==='spline'){obj.points=oP.points.map(p=>({x:p.x+dX,y:p.y+dY}));}
                            else if(obj.type==='point') { obj.x = oP.x + dX; obj.y = oP.y + dY; }
                            else if(obj.type==='rectangle') { obj.x = oP.x + dX; obj.y = oP.y + dY; } 
                            else if(obj.type==='ellipse') { obj.centerX = oP.centerX + dX; obj.centerY = oP.centerY + dY; } 
                            else if(obj.type==='hexagon' || obj.type==='star') {
                                obj.centerX = oP.centerX + dX; obj.centerY = oP.centerY + dY;
                                obj.points = oP.points.map(p => ({x: p.x + dX, y: p.y + dY}));
                            }
                        }
                    });
                    dimensions.forEach(dim => {
                        if (selectedDimensionIds.includes(dim.id) && dragStartDimensionData.has(dim.id)) {
                            const oD = dragStartDimensionData.get(dim.id);
                            if (dim.type === 'dimHorizontal') {
                                dim.p1.x = oD.p1x + dX; dim.p1.y = oD.p1y + dY;
                                dim.p2.x = oD.p2x + dX; dim.p2.y = oD.p2y + dY;
                                dim.offsetY = oD.offsetY + dY;
                            } else if (dim.type === 'dimVertical') {
                                dim.p1.x = oD.p1x + dX; dim.p1.y = oD.p1y + dY;
                                dim.p2.x = oD.p2x + dX; dim.p2.y = oD.p2y + dY;
                                dim.offsetX = oD.offsetX + dX;
                            } else if (dim.type === 'dimRadius') {
                                dim.center.x = oD.centerX + dX; dim.center.y = oD.centerY + dY;
                                dim.pointOnCircle.x = oD.pointX + dX; dim.pointOnCircle.y = oD.pointY + dY;
                                dim.textPos.x = oD.textX + dX; dim.textPos.y = oD.textY + dY;
                            }
                        }
                    });

                } else if (currentTool === 'trim' && trimState.phase === 3 && trimState.objectToTrimId) {
                    const rawMouseForTrimPreview = screenToWorld(event.clientX - canvas.getBoundingClientRect().left, event.clientY - canvas.getBoundingClientRect().top);
                    trimState.previewSegment = getTrimPreviewSegment(rawMouseForTrimPreview);
                } else if (currentTool === 'extend' && extendState.objectToExtendId && !extendState.boundaryId) {
                    updateExtendPreview();
                }

                 if (isPanning || isDraggingObject || drawing || isDraggingControlPoint ||
                    (currentTool === 'offset' && objectToOffset) ||
                    (currentTool === 'trim' && trimState.phase === 3) ||
                    (currentTool === 'extend' && extendState.objectToExtendId) ||
                    (transformState.active && transformState.dragStartPoint) || 
                    currentSnap || 
                    (distance(mousePosWorld, prevMousePosWorld) > 1e-6 / scale && !currentSnap) 
                ) {
                    redrawCanvas();
                }
                updateToolStatusAndCursor(); 
            });

            canvas.addEventListener('mouseup', (e) => {
                if((e.button===1 || (e.button === 0 && e.altKey)) && isPanning) isPanning=false; 
                if(e.button===0){ 
                    if (transformState.active && transformState.dragStartPoint) { 
                        handleTransformMouseUp(e);
                    }
                    else if(isDraggingObject) { 
                        isDraggingObject=false;
                        dragStartObjectPositions.clear();
                        dragStartDimensionData.clear();
                    }
                    else if(isDraggingControlPoint) { 
                        isDraggingControlPoint=false; 
                        dragStartHandlePositions.clear();
                    }
                }
                redrawCanvas(); updateToolStatusAndCursor();
            });

            canvas.addEventListener('mouseleave', (e) => { 
                if(isPanning) isPanning=false;
                if (transformState.active && transformState.dragStartPoint) { 
                    handleTransformMouseUp(e); 
                }
                else if(isDraggingObject && !editModeActive) {
                     isDraggingObject=false;
                     dragStartObjectPositions.clear();
                     dragStartDimensionData.clear();
                }
                else if(isDraggingControlPoint && editModeActive) { isDraggingControlPoint=false; dragStartHandlePositions.clear(); }
                currentSnap = null; 
                redrawCanvas(); updateToolStatusAndCursor();
            });

            function resetSplineDrawingState(){currentSplinePoints=[];drawing=false; currentSnap = null;}
            function finalizeSpline(){
                if (currentTool !=='spline' || !drawing || editModeActive) return;
                let isValid = false; const len = currentSplinePoints.length;
                if (currentSplineInterpolation === 'linear' || currentSplineInterpolation === 'cardinal' || currentSplineInterpolation === 'catmull-rom') {
                    if (len >= 2) isValid = true;
                } else if (currentSplineInterpolation === 'bezier') {
                    if (len >= 4 && (len - 1) % 3 === 0) isValid = true;
                }
                if (isValid) { objects.push({id:getNewObjectId(), type:'spline', points:JSON.parse(JSON.stringify(currentSplinePoints)), interpolationType:currentSplineInterpolation});}
                else if (len > 0) { console.warn(`Spline (${currentSplineInterpolation}) no v√°lida con ${len} puntos. No guardada.`); }
                resetSplineDrawingState(); redrawCanvas(); updateToolStatusAndCursor();
            }
            function cancelSplineDrawing(){
                if (currentTool !=='spline' || !drawing || editModeActive) return;
                resetSplineDrawingState(); redrawCanvas(); updateToolStatusAndCursor();
            }

            toggleUIModeBtn.addEventListener('click', () => {
                isCompactUI = !isCompactUI;
                topInterfaceArea.classList.toggle('compact-ui', isCompactUI);
                toggleUIModeBtn.innerHTML = isCompactUI ? '<span class="icon">‚öôÔ∏è</span>UI+' : '<span class="icon">‚öôÔ∏è</span>UI';
                toggleUIModeBtn.title = isCompactUI ? "Alternar interfaz completa" : "Alternar interfaz compacta";
                resizeCanvas(); 
            });


            snapToGridBtn.addEventListener('click', () => { 
                snapToGridEnabled = !snapToGridEnabled;
                snapToGridBtn.innerHTML = `<span class="icon">‚ñ¶</span>Rejilla ${snapToGridEnabled ? 'On' : 'Off'}`;
                snapToGridBtn.classList.toggle('active', snapToGridEnabled);
                currentSnap = null; 
                const canvasRect = canvas.getBoundingClientRect();
                const pseudoEvent = new MouseEvent('mousemove', { clientX: lastKnownMouseScreenPos.x + canvasRect.left, clientY: lastKnownMouseScreenPos.y + canvasRect.top });
                mousePosWorld = getMouseWorldPositionWithAids(pseudoEvent);
                redrawCanvas(); 
            });
            orthoModeBtn.addEventListener('click', () => { 
                orthoModeEnabled = !orthoModeEnabled;
                orthoModeBtn.innerHTML = `<span class="icon">üìê</span>Orto ${orthoModeEnabled ? 'On' : 'Off'}`;
                orthoModeBtn.classList.toggle('active', orthoModeEnabled);
                currentSnap = null; 
                const canvasRect = canvas.getBoundingClientRect();
                const pseudoEvent = new MouseEvent('mousemove', { clientX: lastKnownMouseScreenPos.x + canvasRect.left, clientY: lastKnownMouseScreenPos.y + canvasRect.top });
                mousePosWorld = getMouseWorldPositionWithAids(pseudoEvent);
                redrawCanvas(); 
            });
            
            [refEndpointCb, refMidpointCb, refCenterCb, refQuadrantCb, refIntersectionCb, refTangentCb, refNearestCb].forEach(cb => {
                cb.addEventListener('change', () => {
                    currentSnap = null; 
                    const canvasRect = canvas.getBoundingClientRect();
                    const lastMouseEvent = new MouseEvent('mousemove', { 
                        clientX: lastKnownMouseScreenPos.x + canvasRect.left, 
                        clientY: lastKnownMouseScreenPos.y + canvasRect.top 
                    });
                    mousePosWorld = getMouseWorldPositionWithAids(lastMouseEvent);
                    redrawCanvas();
                });
            });

            splineInterpolationSelect.addEventListener('change', function(){ 
                if (drawing && currentTool==='spline' && currentSplinePoints.length>0) finalizeSpline(); 
                currentSplineInterpolation = this.value;
                if (currentTool==='spline' && !editModeActive) redrawCanvas(); 
                updateToolStatusAndCursor();
            });
            editPointsBtn.addEventListener('click', () => { 
                currentSnap = null; 
                if (editModeActive) exitEditMode();
                else if (selectedObjectIds.length === 1 && currentTool === 'select') {
                    const sO = objects.find(obj => obj.id === selectedObjectIds[0]);
                    if (sO && ['line','circle','spline', 'point', 'rectangle', 'arc', 'arcCenterStartEnd', 'ellipse', 'hexagon', 'star'].includes(sO.type)) enterEditMode(sO);
                }
            });

            offsetDistanceInput.addEventListener('input', updateOffsetPreview);
            offsetLeftBtn.addEventListener('click', () => setOffsetSideUI('left'));
            offsetRightBtn.addEventListener('click', () => setOffsetSideUI('right'));
            offsetBothBtn.addEventListener('click', () => setOffsetSideUI('both'));

            function setTool(tN) { 
                exitAllToolModes(tN); 
                
                const multiStepDrawingTools = ['spline', 'arcCenterStartEnd', 'ellipse'];
                if (multiStepDrawingTools.includes(currentTool) && drawing && tN !== currentTool) {
                    if (currentTool === 'spline') finalizeSpline();
                } else if (!multiStepDrawingTools.includes(tN) || !drawing) { 
                    if (tN !== 'rotate' && tN !== 'scale') { 
                       // CORRECCI√ìN: No establecer drawing a false aqu√≠ para herramientas de dos clics.
                       // Se maneja en mousedown.
                    }
                    // Mantener startPoint y definingPoint2 si se est√° en medio de una herramienta que los usa
                    // y no se cambia a una herramienta que los resetee.
                    if (!['line', 'circle', 'rectangle', 'arc', 'arcCenterStartEnd', 'ellipse', 'hexagon', 'star'].includes(tN) ||
                        (tN === 'arc' && !startPoint && !definingPoint2) || // Si se cambia a arco y no hay puntos
                        (tN === 'arcCenterStartEnd' && !arcCenterPoint && !startPoint) // Si se cambia a arco C,I,F y no hay puntos
                    ) {
                        startPoint = null;
                        definingPoint2 = null;
                    }
                }
                
                if (tN !== 'arcCenterStartEnd') arcCenterPoint = null;
                if (tN !== 'ellipse') { ellipseCenter = null; ellipseRadiusXPoint = null; }
                if (tN !== 'spline') currentSplinePoints = []; 
                
                if (tN !== 'select' && !tN.startsWith('edit_points_active') && tN !== 'offset' && tN !== 'trim' && tN !== 'extend' && tN !== 'rotate' && tN !== 'scale') {
                     if (tN === 'dimRadius') { if (!getSelectedCircleForRadiusDim()) selectedObjectIds = [];  } 
                     else { 
                        selectedObjectIds = []; 
                     }
                     selectedDimensionIds = []; 
                } else if (tN === 'offset' || tN === 'trim' || tN === 'extend') {
                    selectedObjectIds = [];  selectedDimensionIds = [];
                } else if (tN === 'rotate' || tN === 'scale') {
                }
                
                currentTool = tN; currentSnap = null; 

                // CORRECCI√ìN: 'drawing' solo se establece a true para herramientas que son *continuas*
                // o que tienen una fase de previsualizaci√≥n antes del primer clic (como spline, arc C,I,F, ellipse).
                if (['spline', 'arcCenterStartEnd', 'ellipse'].includes(tN)) {
                    drawing = true; 
                    if(tN === 'spline') currentSplineInterpolation = splineInterpolationSelect.value; 
                } else {
                    drawing = false; // Para herramientas de dos clics, el primer mousedown activar√° 'drawing'.
                }
                
                if (tN === 'dimRadius' && getSelectedCircleForRadiusDim()) { drawing = true; }

                updateToolStatusAndCursor();
                const canvasRect = canvas.getBoundingClientRect();
                const pseudoEvent = new MouseEvent('mousemove', { clientX: lastKnownMouseScreenPos.x + canvasRect.left, clientY: lastKnownMouseScreenPos.y + canvasRect.top });
                mousePosWorld = getMouseWorldPositionWithAids(pseudoEvent);
                redrawCanvas();
            }

            selectToolBtn.addEventListener('click', () => setTool('select'));
            lineToolBtn.addEventListener('click', () => setTool('line'));
            circleToolBtn.addEventListener('click', () => setTool('circle'));
            arcToolBtn.addEventListener('click', () => setTool('arc')); 
            arcCenterStartEndToolBtn.addEventListener('click', () => setTool('arcCenterStartEnd'));
            splineToolBtn.addEventListener('click', () => setTool('spline'));
            pointToolBtn.addEventListener('click', () => setTool('point'));
            rectangleToolBtn.addEventListener('click', () => setTool('rectangle'));
            ellipseToolBtn.addEventListener('click', () => setTool('ellipse'));
            hexagonToolBtn.addEventListener('click', () => setTool('hexagon'));
            starToolBtn.addEventListener('click', () => setTool('star'));
            
            rotateToolBtn.addEventListener('click', () => activateTransformTool('rotate'));
            scaleToolBtn.addEventListener('click', () => activateTransformTool('scale'));

            offsetToolBtn.addEventListener('click', () => setTool('offset'));
            trimToolBtn.addEventListener('click', () => setTool('trim'));
            extendToolBtn.addEventListener('click', () => setTool('extend'));
            dimHorizontalBtn.addEventListener('click', () => setTool('dimHorizontal'));
            dimVerticalBtn.addEventListener('click', () => setTool('dimVertical'));
            dimRadiusBtn.addEventListener('click', () => setTool('dimRadius'));

            function resetApplicationState(resetView = true) {
                exitAllToolModes();
                objects = []; selectedObjectIds = [];
                dimensions = []; selectedDimensionIds = [];
                drawing = false; startPoint = null; currentSplinePoints = [];
                definingPoint2 = null; arcCenterPoint = null; ellipseCenter = null; ellipseRadiusXPoint = null;
                
                resetTransformStateOnly();
                hideTransformValues();

                isDraggingObject = false; isPanning = false; nextObjectId = 1; nextDimensionId = 1;
                objectToOffset = null; offsetPreviewObjects = [];
                resetTrimState(); resetExtendState();
                if (editModeActive) exitEditMode();
                currentSnap = null;
                
                if (resetView) {
                    scale = 1.0;
                    const dpr = window.devicePixelRatio || 1;
                    const canvasWidthCSS = canvas.width / dpr;
                    const canvasHeightCSS = canvas.height / dpr;
                    offsetCanvas.x = canvasWidthCSS / 2;
                    offsetCanvas.y = canvasHeightCSS / 2;
                }
            }
            
            clearBtn.addEventListener('click', () => { 
                resetApplicationState(true);
                setTool('select'); 
                redrawCanvas(); 
                updateToolStatusAndCursor();
            });

            saveFileBtn.addEventListener('click', () => {
                const drawingData = {
                    objects: objects,
                    dimensions: dimensions,
                    nextObjectId: nextObjectId,
                    nextDimensionId: nextDimensionId,
                    view: {
                        scale: scale,
                        offsetCanvasX: offsetCanvas.x,
                        offsetCanvasY: offsetCanvas.y
                    },
                };
                const jsonString = JSON.stringify(drawingData, null, 2);
                const blob = new Blob([jsonString], {type: 'application/json'});
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'xoconodo_drawing.xoccad'; 
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                toolStatusDiv.textContent = "Dibujo guardado como xoconodo_drawing.xoccad";
            });

            openFileBtn.addEventListener('click', () => {
                fileInput.click(); 
            });

            fileInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (!file) {
                    return;
                }
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const fileContent = e.target.result;
                        const loadedData = JSON.parse(fileContent);

                        resetApplicationState(false); 

                        objects = loadedData.objects || [];
                        dimensions = loadedData.dimensions || [];
                        nextObjectId = loadedData.nextObjectId || 1;
                        nextDimensionId = loadedData.nextDimensionId || 1;

                        if (loadedData.view) {
                            scale = loadedData.view.scale || 1.0;
                            offsetCanvas.x = loadedData.view.offsetCanvasX || (canvas.width / (window.devicePixelRatio || 1)) / 2;
                            offsetCanvas.y = loadedData.view.offsetCanvasY || (canvas.height / (window.devicePixelRatio || 1)) / 2;
                        } else { 
                            scale = 1.0;
                            const dpr = window.devicePixelRatio || 1;
                            const canvasWidthCSS = canvas.width / dpr;
                            const canvasHeightCSS = canvas.height / dpr;
                            offsetCanvas.x = canvasWidthCSS / 2;
                            offsetCanvas.y = canvasHeightCSS / 2;
                        }

                        setTool('select'); 
                        redrawCanvas();
                        updateToolStatusAndCursor();
                        toolStatusDiv.textContent = `Dibujo '${file.name}' cargado.`;

                    } catch (error) {
                        console.error("Error al abrir o parsear el archivo:", error);
                        alert(`Error al abrir el archivo: ${error.message}`);
                        toolStatusDiv.textContent = "Error al cargar el archivo.";
                    } finally {
                        fileInput.value = null; 
                    }
                };
                reader.readAsText(file);
            });


            document.addEventListener('keydown', (e) => {
                if (transformState.active) {
                    if (handleTransformKeydown(e)) return; 
                }
                 if ((e.key==='Delete'||e.key==='Backspace') && !isInputFocused()) {
                    let changed = false;
                    if (editModeActive && editableObject) { 
                        objects = objects.filter(o => o.id !== editableObject.id);
                        selectedObjectIds=[]; exitEditMode(); changed = true;
                    } else { 
                        if (selectedObjectIds.length > 0) {
                            objects = objects.filter(o => !selectedObjectIds.includes(o.id));

                            if (transformState.active) {
                                const remainingTransformObjects = transformState.objectsToTransform.filter(id => objects.some(o => o.id === id));
                                if (remainingTransformObjects.length === 0) {
                                    exitTransformTool(false); 
                                    setTool('select');
                                } else {
                                    transformState.objectsToTransform = remainingTransformObjects;
                                    if(transformState.center) { 
                                       transformState.center = calculateCentroid(transformState.objectsToTransform);
                                       if (!transformState.center) exitTransformTool(false); 
                                    }
                                }
                            }
                            selectedObjectIds = []; 

                            if (objectToOffset && !objects.find(o => o.id === objectToOffset.id)) { 
                                objectToOffset = null; 
                                offsetPreviewObjects = []; 
                            }
                            if (trimState.objectToTrimId && !objects.find(o => o.id === trimState.objectToTrimId)) {
                            }
                            trimState.boundaries = trimState.boundaries.filter(id => objects.some(o => o.id === id));
                            if (currentTool === 'trim') {
                                if (!objects.some(o => o.id === trimState.objectToTrimId)) { 
                                    trimState.objectToTrimId = null;
                                    trimState.intersections = [];
                                    trimState.previewSegment = null;
                                    trimState.phase = trimState.boundaries.length > 0 ? 1 : 0; 
                                } else if (trimState.boundaries.length === 0 && !trimState.objectToTrimId) {
                                     trimState.phase = 0; 
                                }
                            }


                            if (extendState.objectToExtendId && !objects.find(o => o.id === extendState.objectToExtendId)) {
                                resetExtendState();
                            }
                            if (extendState.boundaryId && !objects.some(o => o.id === extendState.boundaryId)) {
                                extendState.boundaryId = null; 
                            }
                            if (currentTool === 'extend' && extendState.objectToExtendId) {
                                updateExtendPreview(); 
                            }
                            
                            changed = true;
                        }
                        if (selectedDimensionIds.length > 0) {
                            dimensions = dimensions.filter(d => !selectedDimensionIds.includes(d.id));
                            selectedDimensionIds = [];
                            changed = true;
                        }
                    }
                    if (changed) { currentSnap = null; redrawCanvas(); updateToolStatusAndCursor(); }
                }
                if (e.key === 'Escape' && !isInputFocused()) {
                    currentSnap = null; 
                    if (isDraggingControlPoint) { 
                        isDraggingControlPoint=false;
                        controlPointHandles.forEach(h => {
                            if(dragStartHandlePositions.has(h.originalIndex)) {
                                const originalPos = dragStartHandlePositions.get(h.originalIndex);
                                h.x = originalPos.x; h.y = originalPos.y;
                            }
                        });
                        dragStartHandlePositions.clear();
                    }
                    else if (editModeActive) exitEditMode(); 
                    else if (currentTool === 'offset' && objectToOffset) { objectToOffset = null; offsetPreviewObjects = []; selectedObjectIds = [];} 
                    else if (currentTool === 'trim') { 
                        if (trimState.phase === 3 || trimState.phase === 2) { 
                            trimState.objectToTrimId = null; trimState.intersections = []; trimState.previewSegment = null;
                            trimState.phase = (trimState.boundaries.length > 0) ? 1 : 0; 
                            selectedObjectIds = [...trimState.boundaries]; 
                        } else if (trimState.phase === 1) { resetTrimState(); selectedObjectIds = []; } 
                        else { setTool('select'); } 
                    }
                    else if (currentTool === 'extend') { 
                        if (extendState.objectToExtendId) { resetExtendState(); selectedObjectIds = []; }
                        else { setTool('select'); }
                    }
                    else if (currentTool==='spline'&&drawing) cancelSplineDrawing(); 
                    else if ((['arc', 'arcCenterStartEnd', 'ellipse', 'hexagon', 'star', 'rectangle'].includes(currentTool) || currentTool.startsWith('dim')) && drawing) {
                        drawing=false; startPoint=null; definingPoint2=null; arcCenterPoint = null; ellipseCenter = null; ellipseRadiusXPoint = null;
                    }
                    else if (drawing) { drawing=false; startPoint=null; } 
                    else if (isDraggingObject) { 
                        isDraggingObject = false; 
                        objects.forEach(obj => {
                            if (dragStartObjectPositions.has(obj.id)) {
                                const originalState = dragStartObjectPositions.get(obj.id);
                                Object.assign(obj, originalState); 
                            }
                        });
                        dimensions.forEach(dim => {
                            if (dragStartDimensionData.has(dim.id)) {
                                const originalState = dragStartDimensionData.get(dim.id);
                                Object.assign(dim, originalState);
                            }
                        });
                        dragStartObjectPositions.clear();
                        dragStartDimensionData.clear();
                    }
                    else if (isPanning) isPanning = false; 
                    else if (selectedObjectIds.length > 0 || selectedDimensionIds.length > 0) { 
                        selectedObjectIds = []; selectedDimensionIds = [];
                    }
                    else setTool('select'); 
                    redrawCanvas(); updateToolStatusAndCursor();
                }
                if (e.key === 'Enter' && !isInputFocused()) {
                    if (currentTool==='spline'&&drawing&&!editModeActive) finalizeSpline(); 
                    else if (editModeActive) exitEditMode(); 
                    else if (currentTool === 'offset' && objectToOffset && offsetPreviewObjects.length > 0) applyCurrentOffset(); 
                    else if (currentTool === 'trim' && trimState.phase === 1 && trimState.boundaries.length > 0) {
                        trimState.phase = 2; selectedObjectIds = [...trimState.boundaries]; 
                    }
                     else if (currentTool === 'extend' && extendState.objectToExtendId && extendState.previewPoint && !extendState.boundaryId) {
                        if (extendState.possibleExtensions.length > 0) {
                            extendState.boundaryId = extendState.possibleExtensions[0].boundaryId; 
                            applyActualExtend();
                        }
                     }
                    currentSnap = null; redrawCanvas(); updateToolStatusAndCursor(); 
                }
            });
           
           
            document.addEventListener('keyup', (e) => { 
                if (transformState.active) {
                    if (handleTransformKeyup(e)) return; 
                }
            });
            
            function isInputFocused() {
                return document.activeElement && 
                       (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'SELECT');
            }

            function initAll() {
                initTransformTools(); 
                
                splineInterpolationSelect.value = currentSplineInterpolation;
                setOffsetSideUI(offsetSide); 
                resizeCanvas(); 
                updateToolStatusAndCursor(); 
            }
            
            initAll(); 
        });
    </script>
</body>
</html>
