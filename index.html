<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XOCONODO CAD</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.32.3/ace.js" integrity="sha512-2NBkHNBARpQQ0Z87uQo2/Y3C8DAEOiF2pM3fL3D2b3y3PDRY0jYxQnEwQ0/pG5mJqOOD8m24X2/8+q7Z9kHWA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <style>
        /* Variables CSS para Temas */
        :root {
            /* Colores principales */
            --primary: #4c84ff;
            --primary-hover: #639aff;
            --primary-focus: #3a71e6;
            --accent: #ff7d45; /* Used for edit mode, some highlights */
            --accent-hover: #ff8f5f;
            --danger: #ff5a5a;
            
            /* Tema claro (predeterminado) */
            --app-bg: #ebedfb;
            --content-bg: #f3f5ff;
            --canvas-bg: #e8ebff;
            --toolbar-bg: rgba(255, 255, 255, 0.75);
            --sidebar-bg: rgba(255, 255, 255, 0.75);
            
            /* Elementos UI */
            --surface-1: rgba(255, 255, 255, 0.9);
            --surface-2: rgba(249, 250, 255, 0.85);
            --surface-3: rgba(243, 245, 255, 0.8);
            
            /* Texto */
            --text-primary: #1a1a2e;    /* Main text, default object color */
            --text-secondary: #454564; /* Muted text, some UI elements */
            --text-muted: #7e7e9a;     /* Very muted text, labels */
            
            /* Bordes */
            --border-color: rgba(203, 213, 225, 0.5);
            --border-focus: #4c84ff;
            
            /* Canvas */
            --grid-lines: rgba(203, 213, 225, 0.8);
            --grid-dots: rgba(180, 190, 210, 0.9); /* New for dots pattern */
            --grid-size: 20px; /* Synced with JS GRID_SIZE */
            
            /* Sombras */
            --shadow-sm: 0 1px 2px rgba(30, 41, 59, 0.05);
            --shadow: 0 2px 8px rgba(30, 41, 59, 0.08);
            --shadow-md: 0 4px 12px rgba(30, 41, 59, 0.1);
            --shadow-lg: 0 12px 24px rgba(30, 41, 59, 0.12);
            
            /* Efectos */
            --blur: blur(12px);

            /* Specific CAD colors from old theme, mapped */
            --cad-selection-color: var(--primary);
            --cad-edit-mode-color: var(--accent);
            --cad-dimension-color: var(--primary);
            --cad-dimension-selected-color: var(--accent);
            --cad-transform-handle-color: var(--primary);
            --cad-snap-indicator-color: var(--primary);
            --cad-button-disabled-bg: #e0e0e0; /* Light theme disabled */
            --cad-button-disabled-text: #aaaaaa; /* Light theme disabled */
            --cad-input-bg: #ffffff;
            --cad-input-text: #1a1a2e;
        }

        .dark-theme {
            --app-bg: #101022;
            --content-bg: #16162c;
            --canvas-bg: #12122a;
            --toolbar-bg: rgba(30, 30, 60, 0.75);
            --sidebar-bg: rgba(30, 30, 60, 0.75);
            
            --surface-1: rgba(40, 40, 70, 0.8);
            --surface-2: rgba(50, 50, 80, 0.75);
            --surface-3: rgba(60, 60, 90, 0.7);
            
            --text-primary: #f8fafc;
            --text-secondary: #e2e8f0;
            --text-muted: #94a3b8;
            
            --border-color: rgba(100, 116, 139, 0.3);
            
            --grid-lines: rgba(100, 116, 139, 0.2);
            --grid-dots: rgba(120, 130, 150, 0.25);

            /* Specific CAD colors for dark theme */
            --cad-selection-color: var(--primary); 
            --cad-edit-mode-color: var(--accent);
            --cad-dimension-color: var(--primary);
            --cad-dimension-selected-color: var(--accent);
            --cad-transform-handle-color: var(--primary);
            --cad-snap-indicator-color: var(--primary);
            --cad-button-disabled-bg: #333333;
            --cad-button-disabled-text: #6a6a6a;
            --cad-input-bg: #3c3c3c;
            --cad-input-text: #cccccc;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        html, body {
            height: 100%;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            font-size: 14px;
            color: var(--text-primary);
            background-color: var(--app-bg);
            overflow: hidden;
        }

        .app-container { display: flex; flex-direction: column; height: 100vh; width: 100vw; }

        .top-toolbar {
            height: 50px; 
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 10px;
            background-color: var(--toolbar-bg);
            backdrop-filter: var(--blur);
            -webkit-backdrop-filter: var(--blur);
            z-index: 50;
            box-shadow: var(--shadow);
            flex-shrink: 0;
        }

        .logo-section { display: flex; align-items: center; gap: 10px; }
        .logo {
            font-size: 18px; font-weight: 700;
            background: linear-gradient(90deg, var(--primary), var(--accent));
            -webkit-background-clip: text; background-clip: text; color: transparent;
            letter-spacing: -0.5px;
        }

        .tools-section { display: flex; gap: 6px; flex-wrap: nowrap; overflow-x: auto; }
        .tool-group {
            display: flex; background-color: var(--surface-1);
            border-radius: 10px; padding: 4px; box-shadow: var(--shadow-sm);
        }
        .action-section { display: flex; align-items: center; gap: 6px; }

        .tool-btn, .action-btn {
            width: 32px; height: 32px; border-radius: 8px; border: none;
            background-color: transparent; color: var(--text-secondary);
            cursor: pointer; display: flex; align-items: center; justify-content: center;
            transition: all 0.2s ease; font-size: 14px; 
        }
        .tool-btn:hover, .action-btn:hover { background-color: var(--surface-2); color: var(--text-primary); }
        .tool-btn.active { background-color: var(--primary); color: white !important; }
        .tool-btn.edit-mode-active { background-color: var(--accent); color: white !important; }
        .tool-btn:disabled, .action-btn:disabled {
            background-color: var(--cad-button-disabled-bg) !important;
            color: var(--cad-button-disabled-text) !important;
            cursor: not-allowed;
        }


        .main-container { flex: 1; display: flex; position: relative; background-color: var(--content-bg); }

        .canvas-container {
            flex: 1; position: relative;
            background-color: var(--canvas-bg);
            overflow: hidden;
        }
        .canvas-container.grid-pattern {
            background-image:
                linear-gradient(var(--grid-lines) 1px, transparent 1px),
                linear-gradient(90deg, var(--grid-lines) 1px, transparent 1px);
            /* background-size and background-position set by JS */
        }
        .canvas-container.dots-pattern {
             background-image: radial-gradient(var(--grid-dots) 1.5px, transparent 1.5px);
             /* background-size and background-position set by JS */
        }


        #cadCanvas { width: 100%; height: 100%; display: block; background-color: transparent; }

        .right-sidebar {
            width: 52px; height: 100%; background-color: var(--sidebar-bg);
            backdrop-filter: var(--blur); -webkit-backdrop-filter: var(--blur);
            display: flex; flex-direction: column; align-items: center;
            padding: 10px 0; gap: 10px; z-index: 40; box-shadow: var(--shadow);
            transition: width 0.3s ease;
        }
        .right-sidebar:hover { width: 200px; } 
        .sidebar-section { width: 100%; display: flex; flex-direction: column; align-items: center; gap: 6px; }
        .sidebar-section-title {
            color: var(--text-muted); font-size: 10px; font-weight: 500; text-transform: uppercase;
            letter-spacing: 0.5px; margin-top: 4px; white-space: nowrap; opacity: 0;
            transition: opacity 0.2s ease; text-align: center;
        }
        .right-sidebar:hover .sidebar-section-title { opacity: 1; }
        .sidebar-btn {
            width: 38px; height: 38px; border-radius: 10px; border: none;
            background-color: var(--surface-1); color: var(--text-secondary); cursor: pointer;
            display: flex; align-items: center; justify-content: center; transition: all 0.2s ease;
            position: relative; box-shadow: var(--shadow-sm); font-size: 16px;
        }
        .sidebar-btn .btn-label {
            position: absolute; left: 48px; white-space: nowrap; color: var(--text-secondary);
            font-weight: 500; opacity: 0; transition: opacity 0.2s ease; pointer-events: none;
            font-size: 13px;
        }
        .right-sidebar:hover .sidebar-btn .btn-label { opacity: 1; }
        .sidebar-btn:hover { background-color: var(--surface-2); color: var(--text-primary); transform: translateY(-1px); box-shadow: var(--shadow); }
        .sidebar-btn.active { background-color: var(--primary); color: white; }

        .left-toolbar {
            position: absolute; left: 10px; top: 50%; transform: translateY(-50%);
            display: flex; flex-direction: column; gap: 6px; z-index: 30;
        }
        .left-toolbar-group {
            display: flex; flex-direction: column; background-color: var(--surface-1);
            border-radius: 10px; padding: 4px; gap: 4px; box-shadow: var(--shadow);
        }

        .floating-panel {
            position: absolute;
            background-color: var(--surface-1);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            box-shadow: var(--shadow-lg);
            padding: 12px;
            z-index: 200; 
            display: none; 
            min-width: 220px;
            backdrop-filter: var(--blur);
            -webkit-backdrop-filter: var(--blur);
        }
        .floating-panel.visible { display: block; animation: fadeInUp 0.2s ease-out; }
        .panel-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        .panel-title { font-size: 14px; font-weight: 600; color: var(--text-primary); }
        .panel-close-btn {
            width: 20px; height: 20px; border-radius: 5px; border: none;
            background-color: transparent; color: var(--text-muted); cursor: pointer;
            display: flex; align-items: center; justify-content: center; font-size: 12px;
        }
        .panel-close-btn:hover { background-color: var(--surface-2); color: var(--danger); }
        .panel-content { font-size: 13px; }
        .panel-content label, .panel-content span {
            display: block; margin-bottom: 4px; color: var(--text-secondary);
        }
        .panel-content input[type="number"], .panel-content select {
            width: 100%;
            padding: 6px 8px;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            background-color: var(--cad-input-bg);
            color: var(--cad-input-text);
            font-size: 13px;
            margin-bottom: 8px;
        }
        .panel-content input[type="number"]:focus, .panel-content select:focus {
            border-color: var(--primary); outline: none;
        }
        .panel-content .checkbox-group { display: flex; flex-wrap: wrap; gap: 8px; }
        .panel-content .reference-checkbox { display: flex; align-items: center; font-size: 12px; color: var(--text-secondary); }
        .panel-content .reference-checkbox input { margin-right: 4px; accent-color: var(--primary); }

        .offset-controls-panel div { display: flex; align-items: center; margin-bottom: 5px; }
        .offset-controls-panel span { margin-right: 5px; font-size: 13px; color: var(--text-secondary); }
        .offset-controls-panel input[type="number"] { width: 60px; margin-right: 10px; }
        .offset-controls-panel .offset-side-btn {
            padding: 5px 8px; margin: 0 2px; border-radius: 5px; cursor: pointer;
            font-size: 12px; color: var(--text-secondary); background-color: var(--surface-2);
            border: 1px solid var(--border-color);
        }
        .offset-controls-panel .offset-side-btn.active {
            background-color: var(--primary); color: white; border-color: var(--primary);
        }

        /* Layer Panel Specifics */
        #layersList .layer-item {
            display: flex; align-items: center; margin-bottom: 8px;
            padding: 5px; border-radius: 5px;
            cursor: pointer;
        }
        #layersList .layer-item.active-layer {
            background-color: var(--surface-3);
            font-weight: bold;
        }
        #layersList .layer-item input[type="radio"] { margin-right: 8px; transform: scale(0.9); }
        #layersList .layer-item input[type="color"] {
            margin-right: 8px; border: 1px solid var(--border-color); width: 22px; height: 22px; padding:0;
            background: none; -webkit-appearance: none; -moz-appearance: none; appearance: none;
            border-radius: 4px; overflow: hidden; cursor: pointer;
        }
         #layersList .layer-item input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        #layersList .layer-item input[type="color"]::-webkit-color-swatch { border: none; border-radius: 3px;}
        #layersList .layer-item .layer-name { flex-grow: 1; font-size: 0.9em; }
        #layersList .layer-item .layer-visibility, #layersList .layer-item .layer-lock {
            margin-left: 8px; color: var(--text-muted); font-size: 0.9em;
        }
        #layersList .layer-item .layer-visibility:hover, #layersList .layer-item .layer-lock:hover {
            color: var(--text-primary);
        }
        #layersPanel hr { border: none; border-top: 1px solid var(--border-color); margin: 10px 0; }
        #layersPanel button#applyLayerToSelectionBtn {
            background-color: var(--primary); color: white; border: none;
            padding: 6px 10px; border-radius: 5px; cursor: pointer;
            font-size: 0.9em; margin-top: 5px;
        }
        #layersPanel button#applyLayerToSelectionBtn:disabled {
             background-color: var(--cad-button-disabled-bg);
             color: var(--cad-button-disabled-text);
        }


        #toolStatus {
            position: absolute;
            left: 10px; 
            bottom: 10px;
            background-color: var(--toolbar-bg); 
            backdrop-filter: var(--blur);
            -webkit-backdrop-filter: var(--blur);
            border-radius: 8px;
            padding: 6px 10px;
            font-size: 12px;
            color: var(--text-secondary);
            box-shadow: var(--shadow);
            z-index: 20;
            pointer-events: none;
            opacity: 0.9;
            max-width: calc(100% - 80px); 
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        #snapIndicator {
            position: absolute; pointer-events: none; z-index: 110;
            opacity: 0; transition: opacity 0.1s ease;
        }
        .snap-indicator-label { 
            position: absolute;
            background-color: var(--surface-2); 
            backdrop-filter: var(--blur);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 2px 5px;
            font-size: 10px;
            color: var(--text-primary);
            transform: translate(10px, -15px); 
            white-space: nowrap;
            box-shadow: var(--shadow-sm);
        }
        
        #transformValues {
            position: absolute;
            bottom: 10px;
            right: 60px; 
            background: var(--toolbar-bg);
            backdrop-filter: var(--blur);
            color: var(--text-secondary);
            padding: 5px 10px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            font-size: 0.8em;
            display: none;
            z-index: 200;
            box-shadow: var(--shadow);
        }

        /* Code Editor Panel Specifics */
        #codeEditorPanel {
            top: 60px;
            left: 20px;
            width: 450px; 
            min-height: 300px; 
            display: none; /* Initially hidden, shown by JS */
            flex-direction: column;
        }
        #aceCodeEditor {
            width: 100%;
            flex-grow: 1; /* Allow editor to take available space */
            height: 250px; /* Default height, can be overridden by flex-grow */
            border: 1px solid var(--border-color); 
            border-radius: 5px;
        }
        #codeEditorStatus.error {
            color: var(--danger);
        }


        @keyframes fadeInUp { from { opacity: 0; transform: translateY(8px); } to { opacity: 1; transform: translateY(0); } }

        @media (max-width: 900px) { 
            .tools-section { max-width: calc(100vw - 250px); } 
        }
        @media (max-width: 768px) {
            .top-toolbar { height: 48px; padding: 0 8px; }
            .tool-btn, .action-btn { width: 30px; height: 30px; font-size: 13px; }
            .logo { font-size: 16px; }
            .right-sidebar { width: 48px; }
            .right-sidebar:hover { width: 160px; }
            .sidebar-btn { width: 34px; height: 34px; font-size: 15px; }
            .left-toolbar { left: 8px; }
            #toolStatus { display: none; }
            #codeEditorPanel { width: calc(100vw - 40px); left: 20px;}
        }
    </style>
</head>
<body class=""> <!-- Start with light theme (no class) -->
    <div class="app-container">
        <!-- Barra de herramientas superior -->
        <div class="top-toolbar">
            <div class="logo-section">
                <button id="openCodeEditorBtn" class="tool-btn" title="Abrir Editor de Código">
                    <i class="fas fa-bars"></i>
                </button>
                <div class="logo">XOCONODO</div>
            </div>
            
            <div class="tools-section">
                <div class="tool-group">
                    <button id="selectToolBtn" class="tool-btn" title="Seleccionar (V)">
                        <i class="fas fa-mouse-pointer"></i>
                    </button>
                    <button id="editPointsBtn" class="tool-btn" title="Editar Geometría" style="display:none;">
                        <i class="fas fa-edit"></i>
                    </button>
                    <button id="rotateToolBtn" class="tool-btn" title="Rotar (R)">
                        <i class="fas fa-sync"></i>
                    </button>
                    <button id="scaleToolBtn" class="tool-btn" title="Escalar (S)">
                        <i class="fas fa-expand-arrows-alt"></i>
                    </button>
                </div>
                
                <div class="tool-group">
                    <button id="lineToolBtn" class="tool-btn" title="Línea (L)">
                        <i class="fas fa-slash"></i>
                    </button>
                    <button id="rectangleToolBtn" class="tool-btn" title="Rectángulo">
                        <i class="far fa-square"></i>
                    </button>
                    <button id="circleToolBtn" class="tool-btn" title="Círculo (C)">
                        <i class="far fa-circle"></i>
                    </button>
                     <button id="arcToolBtn" class="tool-btn" title="Arco (3P)">
                        <i class="fas fa-chart-pie"></i>
                    </button>
                    <button id="arcCenterStartEndToolBtn" class="tool-btn" title="Arco (C,I,F)">
                        <i class="fas fa-bullseye"></i>
                    </button>
                    <button id="splineToolBtn" class="tool-btn" title="Spline">
                        <i class="fas fa-wave-square"></i>
                    </button>
                </div>

                <div class="tool-group">
                    <button id="pointToolBtn" class="tool-btn" title="Punto">
                        <i class="fas fa-map-marker-alt"></i>
                    </button>
                    <button id="ellipseToolBtn" class="tool-btn" title="Elipse">
                         <i class="fas fa-ellipsis-h"></i>
                    </button>
                    <button id="polygonToolBtn" class="tool-btn" title="Hexágono">
                        <i class="fas fa-draw-polygon"></i>
                    </button>
                     <button id="starToolBtn" class="tool-btn" title="Estrella">
                        <i class="fas fa-star"></i>
                    </button>
                </div>
                
                <div class="tool-group">
                    <button id="offsetToolBtn" class="tool-btn" title="Equidistancia">
                        <i class="fas fa-object-group"></i>
                    </button>
                    <button id="trimToolBtn" class="tool-btn" title="Recortar">
                        <i class="fas fa-cut"></i>
                    </button>
                    <button id="extendToolBtn" class="tool-btn" title="Alargar">
                        <i class="fas fa-arrows-alt-h"></i>
                    </button>
                </div>

                <div class="tool-group">
                    <button id="dimHorizontalBtn" class="tool-btn" title="Cota Horizontal">
                        <i class="fas fa-ruler-horizontal"></i>
                    </button>
                    <button id="dimVerticalBtn" class="tool-btn" title="Cota Vertical">
                        <i class="fas fa-ruler-vertical"></i>
                    </button>
                    <button id="dimRadiusBtn" class="tool-btn" title="Cota Radio">
                        <i class="fas fa-drafting-compass"></i>
                    </button>
                </div>
            </div>
            
            <div class="action-section">
                <button id="saveFileBtn" class="action-btn" title="Guardar (Ctrl+S)"> <i class="fas fa-save"></i> </button>
                <button id="openFileBtn" class="action-btn" title="Abrir (Ctrl+O)"> <i class="fas fa-folder-open"></i> </button>
                <button id="clearBtn" class="action-btn" title="Limpiar"><i class="fas fa-trash"></i></button>
                <button id="undoBtn" class="action-btn" title="Deshacer (Ctrl+Z)"> <i class="fas fa-undo"></i> </button>
                <button id="redoBtn" class="action-btn" title="Rehacer (Ctrl+Y)"> <i class="fas fa-redo"></i> </button>
                <button id="toggleThemeBtn" class="action-btn" title="Alternar Tema"> <i class="fas fa-lightbulb"></i> </button>
                <button id="toggleCanvasPatternBtn" class="action-btn" title="Alternar Patrón Fondo"> <i class="fas fa-th-large"></i></button>
            </div>
        </div>
        
        <div class="main-container">
            <div class="left-toolbar">
                <div class="left-toolbar-group">
                    <button id="zoomInBtn" class="tool-btn" title="Acercar (Ctrl+)"> <i class="fas fa-search-plus"></i> </button>
                    <button id="zoomOutBtn" class="tool-btn" title="Alejar (Ctrl-)"> <i class="fas fa-search-minus"></i> </button>
                    <button id="zoomToFitBtn" class="tool-btn" title="Ajustar a Ventana (F)"> <i class="fas fa-compress-arrows-alt"></i> </button>
                </div>
                
                <div class="left-toolbar-group">
                    <button id="snapGridBtn" class="tool-btn" title="Ajustar a Rejilla (G)"> <i class="fas fa-border-all"></i> </button>
                    <button id="orthoModeBtn" class="tool-btn" title="Modo Ortogonal (O)"> <i class="fas fa-drafting-compass"></i> </button>
                    <button id="objectSnapSettingsBtn" class="tool-btn" title="Ajustes de Referencia a Objetos"> <i class="fas fa-magnet"></i></button>
                </div>
            </div>
            
            <div id="canvasContainer" class="canvas-container grid-pattern">
                <canvas id="cadCanvas"></canvas>
                <div id="snapIndicator">
                </div>
                <div id="toolStatus">Herramienta: Seleccionar</div>
                <div id="transformValues"></div>
            </div>
            
            <div class="right-sidebar">
                <div class="sidebar-section">
                    <div class="sidebar-section-title">Vistas</div>
                    <button id="viewTopBtn" class="sidebar-btn active" title="Vista Superior"><i class="fas fa-arrow-down"></i><span class="btn-label">Superior</span></button>
                </div>
                 <div class="sidebar-section">
                    <div class="sidebar-section-title">Capas</div>
                    <button id="layersBtn" class="sidebar-btn" title="Gestionar Capas">
                        <i class="fas fa-layer-group"></i>
                        <span class="btn-label">Capas</span>
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <div id="objectSnapsPanel" class="floating-panel">
        <div class="panel-header">
            <div class="panel-title">Referencias a Objetos</div>
            <button id="closeSnapsPanelBtn" class="panel-close-btn"><i class="fas fa-times"></i></button>
        </div>
        <div class="panel-content">
            <div class="checkbox-group">
                <label class="reference-checkbox"><input type="checkbox" id="refEndpoint" checked> P. Final</label>
                <label class="reference-checkbox"><input type="checkbox" id="refMidpoint"> P. Medio</label>
                <label class="reference-checkbox"><input type="checkbox" id="refCenter" checked> Centro</label>
                <label class="reference-checkbox"><input type="checkbox" id="refQuadrant"> Cuadrante</label>
                <label class="reference-checkbox"><input type="checkbox" id="refIntersection" checked> Intersección</label>
                <label class="reference-checkbox"><input type="checkbox" id="refTangent"> Tangente</label>
                <label class="reference-checkbox"><input type="checkbox" id="refNearest"> Cercano</label>
            </div>
        </div>
    </div>

    <div id="splineOptionsPanel" class="floating-panel">
        <div class="panel-header">
            <div class="panel-title">Opciones de Spline</div>
        </div>
        <div class="panel-content">
            <label for="splineInterpolationSelect">Tipo de Interpolación:</label>
            <select id="splineInterpolationSelect">
                <option value="cardinal" selected>Cardinal</option>
                <option value="linear">Lineal</option>
                <option value="bezier">Bezier</option>
                <option value="catmull-rom">Catmull-Rom</option>
            </select>
        </div>
    </div>

    <div id="offsetOptionsPanel" class="floating-panel offset-controls-panel">
        <div class="panel-header">
            <div class="panel-title">Opciones de Equidistancia</div>
        </div>
        <div class="panel-content">
            <div>
                <span>Distancia:</span>
                <input type="number" id="offsetDistanceInput" value="10" step="1" min="0.1" />
            </div>
            <div>
                <span>Lado:</span>
                <button id="offsetLeftBtn" class="offset-side-btn active">Izq</button>
                <button id="offsetRightBtn" class="offset-side-btn">Der</button>
                <button id="offsetBothBtn" class="offset-side-btn">Ambos</button>
            </div>
        </div>
    </div>
    
    <div id="layersPanel" class="floating-panel">
        <div class="panel-header">
            <div class="panel-title">Gestor de Capas</div>
            <button id="closeLayersPanelBtn" class="panel-close-btn"><i class="fas fa-times"></i></button>
        </div>
        <div class="panel-content">
            <div id="layersList" style="max-height: 200px; overflow-y: auto;">
                <!-- Las capas se generarán aquí por JS -->
            </div>
            <hr>
            <div>
                <label for="selectedObjectLayerSelect">Cambiar capa de selección:</label>
                <select id="selectedObjectLayerSelect" disabled>
                    <!-- Opciones de capa se llenarán por JS -->
                </select>
                <button id="applyLayerToSelectionBtn" disabled>Aplicar</button>
            </div>
        </div>
    </div>

    <div id="codeEditorPanel" class="floating-panel" style="width: 450px; min-height: 300px; display: none; flex-direction: column;">
        <div class="panel-header">
            <div class="panel-title">Editor de Código Xoconodo</div>
            <button id="closeCodeEditorPanelBtn" class="panel-close-btn"><i class="fas fa-times"></i></button>
        </div>
        <div id="aceCodeEditor" style="flex-grow: 1; height: 250px; border: 1px solid var(--border-color); border-radius: 5px;"></div>
        <div style="margin-top: 10px; display: flex; justify-content: flex-end; gap: 10px;">
            <button id="runCodeBtn" class="action-btn" title="Ejecutar Código (Ctrl+Enter)"><i class="fas fa-play"></i></button>
            <button id="clearEditorCanvasBtn" class="action-btn" title="Limpiar Dibujo del Editor"><i class="fas fa-eraser"></i></button>
        </div>
        <div id="codeEditorStatus" style="font-size: 0.8em; color: var(--text-muted); margin-top: 5px; min-height: 1.2em;"></div>
    </div>


    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const body = document.body;
            const canvas = document.getElementById('cadCanvas');
            const canvasContainer = document.getElementById('canvasContainer');
            const ctx = canvas.getContext('2d');
            const toolStatusDiv = document.getElementById('toolStatus');
            const snapIndicatorDiv = document.getElementById('snapIndicator');
            let transformValuesDiv = document.getElementById('transformValues');

            const selectToolBtn = document.getElementById('selectToolBtn');
            const lineToolBtn = document.getElementById('lineToolBtn');
            const circleToolBtn = document.getElementById('circleToolBtn');
            const arcToolBtn = document.getElementById('arcToolBtn');
            const arcCenterStartEndToolBtn = document.getElementById('arcCenterStartEndToolBtn'); 
            const splineToolBtn = document.getElementById('splineToolBtn');
            const pointToolBtn = document.getElementById('pointToolBtn');
            const rectangleToolBtn = document.getElementById('rectangleToolBtn');
            const ellipseToolBtn = document.getElementById('ellipseToolBtn');
            const polygonToolBtn = document.getElementById('polygonToolBtn'); 
            const starToolBtn = document.getElementById('starToolBtn'); 

            const editPointsBtn = document.getElementById('editPointsBtn');
            
            const offsetToolBtn = document.getElementById('offsetToolBtn');
            const trimToolBtn = document.getElementById('trimToolBtn');
            const extendToolBtn = document.getElementById('extendToolBtn');
            const rotateToolBtn = document.getElementById('rotateToolBtn');
            const scaleToolBtn = document.getElementById('scaleToolBtn');

            const dimHorizontalBtn = document.getElementById('dimHorizontalBtn'); 
            const dimVerticalBtn = document.getElementById('dimVerticalBtn');     
            const dimRadiusBtn = document.getElementById('dimRadiusBtn');         

            const objectSnapsPanel = document.getElementById('objectSnapsPanel');
            const objectSnapSettingsBtn = document.getElementById('objectSnapSettingsBtn');
            const closeSnapsPanelBtn = document.getElementById('closeSnapsPanelBtn');
            
            const splineOptionsPanel = document.getElementById('splineOptionsPanel');
            const splineInterpolationSelect = document.getElementById('splineInterpolationSelect');

            const offsetOptionsPanel = document.getElementById('offsetOptionsPanel');
            const offsetDistanceInput = document.getElementById('offsetDistanceInput');
            const offsetLeftBtn = document.getElementById('offsetLeftBtn');
            const offsetRightBtn = document.getElementById('offsetRightBtn');
            const offsetBothBtn = document.getElementById('offsetBothBtn');
            
            const undoBtn = document.getElementById('undoBtn');
            const redoBtn = document.getElementById('redoBtn');
            const clearBtn = document.getElementById('clearBtn');
            const saveFileBtn = document.getElementById('saveFileBtn');
            const openFileBtn = document.getElementById('openFileBtn');

            const zoomInBtn = document.getElementById('zoomInBtn');
            const zoomOutBtn = document.getElementById('zoomOutBtn');
            const zoomToFitBtn = document.getElementById('zoomToFitBtn');
            const snapGridBtn = document.getElementById('snapGridBtn'); 
            const orthoModeBtn = document.getElementById('orthoModeBtn');

            const toggleThemeBtn = document.getElementById('toggleThemeBtn');
            const toggleCanvasPatternBtn = document.getElementById('toggleCanvasPatternBtn');

            const refEndpointCb = document.getElementById('refEndpoint');
            const refMidpointCb = document.getElementById('refMidpoint');
            const refCenterCb = document.getElementById('refCenter');
            const refQuadrantCb = document.getElementById('refQuadrant');
            const refIntersectionCb = document.getElementById('refIntersection');
            const refTangentCb = document.getElementById('refTangent');
            const refNearestCb = document.getElementById('refNearest');

            const layersBtn = document.getElementById('layersBtn');
            const layersPanel = document.getElementById('layersPanel');
            const closeLayersPanelBtn = document.getElementById('closeLayersPanelBtn');
            const layersListDiv = document.getElementById('layersList');
            const selectedObjectLayerSelect = document.getElementById('selectedObjectLayerSelect');
            const applyLayerToSelectionBtn = document.getElementById('applyLayerToSelectionBtn');

            const openCodeEditorBtn = document.getElementById('openCodeEditorBtn');
            const codeEditorPanel = document.getElementById('codeEditorPanel');
            const closeCodeEditorPanelBtn = document.getElementById('closeCodeEditorPanelBtn');
            const aceCodeEditorDiv = document.getElementById('aceCodeEditor');
            const runCodeBtn = document.getElementById('runCodeBtn');
            const clearEditorCanvasBtn = document.getElementById('clearEditorCanvasBtn');
            const codeEditorStatus = document.getElementById('codeEditorStatus');
            let aceEditor; 
            let editorObjects = []; 
            
            let currentTheme = body.classList.contains('dark-theme') ? 'dark-theme' : 'light-theme';
            let currentCanvasPattern = 'grid-pattern'; 

            let fileInput; 
            fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.accept = '.json,.xoccad';
            fileInput.style.display = 'none';
            document.body.appendChild(fileInput);

            const GRID_SIZE = 20; 
            document.documentElement.style.setProperty('--grid-size', GRID_SIZE + 'px');

            const HIT_TOLERANCE_SCREEN = 6; 
            const CONTROL_POINT_RADIUS_SCREEN = 5; 
            const SNAP_TOLERANCE_SCREEN = 15; 
            const SNAP_SYMBOL_SIZE = 8; 
            const TRANSFORM_HANDLE_VISUAL_RADIUS = 50; 
            const DIM_TEXT_SIZE_SCREEN = 10;
            const DIM_OFFSET_FROM_LINE_SCREEN = 3;
            const DIM_EXT_LINE_GAP_SCREEN = 2;    
            const DIM_EXT_LINE_OVERSHOOT_SCREEN = 3;
            const DIM_ARROW_SIZE_SCREEN = 5;
            const DIM_COLOR_VAR = '--cad-dimension-color'; 
            const DIM_SELECTED_COLOR_VAR = '--cad-dimension-selected-color';

            let currentTool = 'select';
            let drawing = false; 
            let startPoint = null;         
            let definingPoint2 = null;     
            let arcCenterPoint = null;     
            let ellipseCenter = null;
            let ellipseRadiusXPoint = null;
            let starNumPoints = 5; 
            let starInnerRadiusFactor = 0.5; 
            let transformState = { active: false, mode: null, center: null, objectsToTransform: [], originalObjectStates: new Map(), dragStartPoint: null, currentAngleRad: 0, initialHandleAngleRad: 0, currentFactor: 1, initialHandleDistance: 1, uniformScale: true, showHandles: true, snapAngleDeg: 15, snapScaleFactor: 0.1, isSnapping: false };
            let currentSplinePoints = [];
            let currentSplineInterpolation = 'cardinal'; 
            let objects = []; 
            let nextObjectId = 1;
            let selectedObjectIds = []; 
            let dimensions = []; 
            let nextDimensionId = 1;
            let selectedDimensionIds = []; 
            let mousePosWorld = { x: 0, y: 0 }; 
            let currentSnap = null; 
            let isDraggingObject = false; 
            let dragStartMousePos_World = null; 
            let dragStartObjectPositions = new Map(); 
            let dragStartDimensionData = new Map(); 
            let undoStack = [];
            let redoStack = [];
            const MAX_HISTORY_STATES = 50;
            let scale = 1.0;
            const MIN_SCALE = 0.1; const MAX_SCALE = 10.0;
            let offsetCanvas = { x: 0, y: 0 }; 
            let isPanning = false;
            let panStartMousePos_Screen = null; 
            let snapToGridEnabled = true; 
            let orthoModeEnabled = false;
            let editModeActive = false;
            let editableObject = null; 
            let controlPointHandles = []; 
            let isDraggingControlPoint = false; 
            let dragStartHandlePositions = new Map(); 
            let objectToOffset = null;
            let offsetPreviewObjects = [];
            let offsetSide = "left"; 
            let trimState = { phase: 0, boundaries: [], objectToTrimId: null, intersections: [], previewSegment: null };
            let extendState = { objectToExtendId: null, boundaryId: null, whichEnd: null, previewPoint: null, possibleExtensions: [] };
            let lastKnownMouseScreenPos = {x: 0, y: 0}; 
            
            let internalClipboard = [];
            const PASTE_OFFSET = 10; 

            let layers = [
                { id: 0, name: "Capa 0", color: "#1a1a2e", isVisible: true, isLocked: false },
                { id: 1, name: "Capa Roja", color: "#ff0000", isVisible: true, isLocked: false },
                { id: 2, name: "Capa Verde", color: "#00ff00", isVisible: true, isLocked: false },
                { id: 3, name: "Capa Azul", color: "#0000ff", isVisible: true, isLocked: false },
            ];
            let currentLayerId = 0; 
            let nextLayerId = layers.length;

            function updateLayersUI() {
                layersListDiv.innerHTML = ''; 
                selectedObjectLayerSelect.innerHTML = ''; 

                layers.forEach(layer => {
                    const layerDiv = document.createElement('div');
                    layerDiv.className = 'layer-item';
                    if (layer.id === currentLayerId) {
                        layerDiv.classList.add('active-layer');
                    }

                    const radioBtn = document.createElement('input');
                    radioBtn.type = 'radio';
                    radioBtn.name = 'activeLayer';
                    radioBtn.value = layer.id;
                    radioBtn.checked = layer.id === currentLayerId;
                    radioBtn.title = "Establecer como capa activa";
                    radioBtn.addEventListener('change', () => {
                        currentLayerId = parseInt(radioBtn.value);
                        updateLayersUI(); 
                        redrawCanvas();
                    });

                    const colorInput = document.createElement('input');
                    colorInput.type = 'color';
                    colorInput.value = layer.color;
                    colorInput.title = "Cambiar color de capa";
                    colorInput.addEventListener('input', (e) => {
                        const newColor = e.target.value;
                        const l = layers.find(l => l.id === layer.id);
                        if (l) {
                            l.color = newColor;
                            saveStateForUndo(`Cambiar color capa ${l.name}`);
                            redrawCanvas();
                            if (l.id === 0 && currentTheme === 'light-theme') {
                                document.documentElement.style.setProperty('--text-primary', newColor);
                            } else if (l.id === 0 && currentTheme === 'dark-theme' && newColor.toLowerCase() === '#1a1a2e') {
                                document.documentElement.style.setProperty('--text-primary', '#f8fafc');
                            }
                        }
                    });

                    const layerNameSpan = document.createElement('span');
                    layerNameSpan.textContent = layer.name;
                    layerNameSpan.className = 'layer-name';
                    layerNameSpan.onclick = () => { 
                        currentLayerId = layer.id;
                        updateLayersUI();
                        redrawCanvas();
                    };
                    
                    const visibilityIcon = document.createElement('i');
                    visibilityIcon.className = `fas ${layer.isVisible ? 'fa-eye' : 'fa-eye-slash'} layer-visibility`;
                    visibilityIcon.title = layer.isVisible ? "Ocultar capa" : "Mostrar capa";
                    visibilityIcon.onclick = (e) => {
                        e.stopPropagation(); 
                        layer.isVisible = !layer.isVisible;
                        saveStateForUndo(`${layer.isVisible ? 'Mostrar' : 'Ocultar'} capa ${layer.name}`);
                        updateLayersUI();
                        redrawCanvas();
                    };


                    layerDiv.appendChild(radioBtn);
                    layerDiv.appendChild(colorInput);
                    layerDiv.appendChild(layerNameSpan);
                    layerDiv.appendChild(visibilityIcon);
                    layersListDiv.appendChild(layerDiv);

                    const option = document.createElement('option');
                    option.value = layer.id;
                    option.textContent = layer.name;
                    selectedObjectLayerSelect.appendChild(option);
                });
                selectedObjectLayerSelect.disabled = selectedObjectIds.length === 0;
                applyLayerToSelectionBtn.disabled = selectedObjectIds.length === 0;

                if (selectedObjectIds.length > 0) {
                    const firstSelectedObject = objects.find(obj => obj.id === selectedObjectIds[0]);
                    if (firstSelectedObject && firstSelectedObject.layerId !== undefined) {
                        selectedObjectLayerSelect.value = firstSelectedObject.layerId;
                    } else if (firstSelectedObject) {
                         selectedObjectLayerSelect.value = currentLayerId;
                    }
                } else {
                     selectedObjectLayerSelect.value = currentLayerId;
                }
            }
            
            applyLayerToSelectionBtn.addEventListener('click', () => {
                if (selectedObjectIds.length === 0 || !selectedObjectLayerSelect.value) return;
                const targetLayerId = parseInt(selectedObjectLayerSelect.value);
                const targetLayer = layers.find(l => l.id === targetLayerId);
                if (!targetLayer) return;

                saveStateForUndo("Cambiar capa de objetos");
                selectedObjectIds.forEach(id => {
                    const obj = objects.find(o => o.id === id);
                    if (obj) {
                        obj.layerId = targetLayerId;
                    }
                });
                redrawCanvas();
                toolStatusDiv.textContent = `${selectedObjectIds.length} objeto(s) movido(s) a capa ${targetLayer.name}.`;
                selectedObjectIds = []; 
                updateLayersUI();
                updateToolStatusAndCursor();
            });


            layersBtn.addEventListener('click', () => {
                if (layersPanel.classList.contains('visible')) {
                    hideFloatingPanel(layersPanel);
                } else {
                    updateLayersUI(); 
                    showFloatingPanel(layersPanel, layersBtn);
                }
            });
            closeLayersPanelBtn.addEventListener('click', () => hideFloatingPanel(layersPanel));


            function getObjectLayerColor(object) {
                if (object.layerId !== undefined) {
                    const layer = layers.find(l => l.id === object.layerId);
                    if (layer) return layer.color;
                }
                const layer0 = layers.find(l => l.id === 0);
                if(layer0) return layer0.color;
                
                return getComputedStyle(document.documentElement).getPropertyValue('--text-primary').trim();
            }

            function isObjectVisible(object) {
                if (object.layerId !== undefined) {
                    const layer = layers.find(l => l.id === object.layerId);
                    return layer ? layer.isVisible : true; 
                }
                return true; 
            }

             function addCreatedObject(newObject) {
                newObject.layerId = currentLayerId; 
                objects.push(newObject);
            }

            function initCodeEditor() {
                aceEditor = ace.edit(aceCodeEditorDiv);
                aceEditor.setTheme("ace/theme/tomorrow_night"); 
                aceEditor.session.setMode("ace/mode/javascript");
                aceEditor.setOptions({
                    fontSize: "13px",
                    enableBasicAutocompletion: true,
                    enableLiveAutocompletion: true,
                    enableSnippets: true,
                    showPrintMargin: false,
                });
                aceEditor.setValue(`// ¡Bienvenido al Editor de Código Xoconodo!
// API disponible: api.ctx, api.addObject({type: '...', ...}), 
// api.screenToWorld({x,y}), api.worldToScreen({x,y}), 
// api.getScale(), api.getOffset(), api.getGridSize(), api.getCurrentLayerId()

// Ejemplo:
// api.addObject({type: 'line', startX: 10, startY: 10, endX: 100, endY: 100});
// api.addObject({type: 'circle', centerX: 150, centerY: 150, radius: 30});
`, -1); 
            }

            openCodeEditorBtn.addEventListener('click', () => {
                if (codeEditorPanel.style.display === 'none' || codeEditorPanel.style.display === '') {
                    codeEditorPanel.style.display = 'flex'; 
                    if (!aceEditor) {
                        initCodeEditor();
                    }
                    const panelRect = codeEditorPanel.getBoundingClientRect();
                    const viewportWidth = window.innerWidth;
                    const viewportHeight = window.innerHeight;
                    codeEditorPanel.style.left = `${Math.max(10, (viewportWidth - panelRect.width) / 2)}px`;
                    codeEditorPanel.style.top = `${Math.max(10, (viewportHeight - panelRect.height) / 2)}px`;
                } else {
                    codeEditorPanel.style.display = 'none';
                }
            });

            if(closeCodeEditorPanelBtn) { // Might not exist if panel is always visible in some designs
                closeCodeEditorPanelBtn.addEventListener('click', () => {
                    codeEditorPanel.style.display = 'none';
                });
            }


            runCodeBtn.addEventListener('click', executeEditorCode);
            aceCodeEditorDiv.addEventListener('keydown', (e) => {
                if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                    e.preventDefault();
                    executeEditorCode();
                }
            });
            
            clearEditorCanvasBtn.addEventListener('click', () => {
                if (confirm("¿Limpiar solo los objetos dibujados por el editor o todo el lienzo?\nOK = Solo editor, Cancelar = Todo el lienzo")) {
                    if (editorObjects.length > 0) {
                        saveStateForUndo("Limpiar dibujo del editor");
                        objects = objects.filter(obj => !editorObjects.includes(obj.id));
                        selectedObjectIds = selectedObjectIds.filter(id => !editorObjects.includes(id));
                        editorObjects = []; 
                        redrawCanvas();
                        codeEditorStatus.textContent = "Dibujo del editor limpiado.";
                        codeEditorStatus.classList.remove('error');
                    } else {
                        codeEditorStatus.textContent = "No hay nada que limpiar del editor.";
                         codeEditorStatus.classList.remove('error');
                    }
                } else {
                    clearBtn.click(); 
                }
            });
            
            function addObjectFromEditor(objData) {
                if (!objData || !objData.type) {
                    throw new Error("El objeto debe tener una propiedad 'type'.");
                }
                const newObj = {
                    id: getNewObjectId(),
                    layerId: currentLayerId, 
                    ...objData
                };
                objects.push(newObj);
                editorObjects.push(newObj.id); 
                return newObj; 
            }


            function executeEditorCode() {
                const userCode = aceEditor.getValue();
                codeEditorStatus.textContent = "Ejecutando...";
                codeEditorStatus.classList.remove('error');
                saveStateForUndo("Ejecutar código del editor");

                try {
                    const api = {
                        ctx: ctx, 
                        addObject: addObjectFromEditor,
                        screenToWorld: screenToWorld,
                        worldToScreen: worldToScreen,
                        getScale: () => scale,
                        getOffset: () => ({...offsetCanvas}),
                        getGridSize: () => GRID_SIZE,
                        getCurrentLayerId: () => currentLayerId
                    };
                    
                    const sandboxedExecution = new Function('api', userCode);
                    sandboxedExecution(api);

                    redrawCanvas(); 
                    codeEditorStatus.textContent = "Código ejecutado correctamente.";
                    if (editorObjects.length > 0) {
                        codeEditorStatus.textContent += ` ${editorObjects.length} objeto(s) del editor en el lienzo.`;
                    }
                } catch (error) {
                    console.error("Error en el código del editor:", error);
                    codeEditorStatus.textContent = `Error: ${error.message}`;
                    codeEditorStatus.classList.add('error');
                    // Consider simple undo if error occurs after some objects were added
                    if (undoStack.length > 0 && undoStack[undoStack.length-1].description === "Ejecutar código del editor") {
                        undo(); // Revertir el estado
                        toolStatusDiv.textContent = "Error en script, estado revertido.";
                    }
                }
            }

            function showFloatingPanel(panelElement, eventSourceElement) {
                if (!panelElement) return;
                if (eventSourceElement) {
                    const rect = eventSourceElement.getBoundingClientRect();
                    let top = rect.bottom + 5;
                    let left = rect.left;
                    if (left + panelElement.offsetWidth > window.innerWidth - 10) {
                        left = window.innerWidth - panelElement.offsetWidth - 10;
                    }
                    if (top + panelElement.offsetHeight > window.innerHeight - 10) {
                        top = rect.top - panelElement.offsetHeight - 5;
                    }
                    panelElement.style.top = `${Math.max(10, top)}px`;
                    panelElement.style.left = `${Math.max(10, left)}px`;

                } else {
                    panelElement.style.top = `70px`;
                    panelElement.style.left = `calc(50% - ${panelElement.offsetWidth / 2}px)`;
                }
                panelElement.classList.add('visible');
            }

            function hideFloatingPanel(panelElement) {
                if (panelElement) panelElement.classList.remove('visible');
            }

            objectSnapSettingsBtn.addEventListener('click', (e) => {
                if (objectSnapsPanel.classList.contains('visible')) {
                    hideFloatingPanel(objectSnapsPanel);
                } else {
                    showFloatingPanel(objectSnapsPanel, objectSnapSettingsBtn);
                }
            });
            closeSnapsPanelBtn.addEventListener('click', () => hideFloatingPanel(objectSnapsPanel));

            function applyTheme() {
                const layer0 = layers.find(l => l.id === 0);
                if (currentTheme === 'dark-theme') {
                    body.classList.add('dark-theme');
                    if (layer0 && layer0.color.toLowerCase() === '#1a1a2e') layer0.color = '#f8fafc';
                } else {
                    body.classList.remove('dark-theme');
                    if (layer0 && layer0.color.toLowerCase() === '#f8fafc') layer0.color = '#1a1a2e';
                }
                toggleThemeBtn.innerHTML = `<i class="fas ${currentTheme === 'dark-theme' ? 'fa-sun' : 'fa-moon'}"></i>`;
                toggleThemeBtn.title = `Alternar Tema (${currentTheme === 'dark-theme' ? 'Claro' : 'Oscuro'})`;
                updateLayersUI(); 
                applyCanvasPattern(); 
                redrawCanvas();
            }

            function updateCanvasBackgroundStyle() { 
                const dpr = window.devicePixelRatio || 1;
                if (canvasContainer.classList.contains('grid-pattern') || canvasContainer.classList.contains('dots-pattern')) {
                    const scaledGridSize = GRID_SIZE * scale;
                    const bgPosX = ((offsetCanvas.x % scaledGridSize) + scaledGridSize) % scaledGridSize;
                    const bgPosY = ((offsetCanvas.y % scaledGridSize) + scaledGridSize) % scaledGridSize;
                    
                    canvasContainer.style.backgroundPosition = `${bgPosX / dpr}px ${bgPosY / dpr}px`;
                    canvasContainer.style.backgroundSize = `${scaledGridSize / dpr}px ${scaledGridSize / dpr}px`;
                }
            }

            function applyCanvasPattern() {
                canvasContainer.classList.remove('grid-pattern', 'dots-pattern');
                if (currentCanvasPattern) {
                    canvasContainer.classList.add(currentCanvasPattern);
                }
                let patternIconClass = 'fa-th-large'; 
                let patternTitle = 'Alternar Patrón de Fondo (Puntos)';
                if (currentCanvasPattern === 'dots-pattern') {
                    patternIconClass = 'fa-braille'; 
                    patternTitle = 'Alternar Patrón de Fondo (Rejilla)';
                }
                toggleCanvasPatternBtn.innerHTML = `<i class="fas ${patternIconClass}"></i>`;
                toggleCanvasPatternBtn.title = patternTitle;
                updateCanvasBackgroundStyle(); 
            }

            toggleThemeBtn.addEventListener('click', () => {
                currentTheme = (currentTheme === 'dark-theme') ? 'light-theme' : 'dark-theme';
                applyTheme();
            });

            toggleCanvasPatternBtn.addEventListener('click', () => {
                currentCanvasPattern = (currentCanvasPattern === 'grid-pattern') ? 'dots-pattern' : 'grid-pattern';
                applyCanvasPattern();
                redrawCanvas(); 
            });

            function saveStateForUndo(description = "Acción") {
                const state = {
                    objects: JSON.parse(JSON.stringify(objects)),
                    dimensions: JSON.parse(JSON.stringify(dimensions)),
                    layers: JSON.parse(JSON.stringify(layers)), 
                    currentLayerId: currentLayerId,
                    nextLayerId: nextLayerId,
                    nextObjectId: nextObjectId,
                    nextDimensionId: nextDimensionId,
                    selectedObjectIds: [...selectedObjectIds],
                    selectedDimensionIds: [...selectedDimensionIds],
                    description: description
                };
                undoStack.push(state);
                if (undoStack.length > MAX_HISTORY_STATES) {
                    undoStack.shift();
                }
                redoStack = [];
                updateUndoRedoButtons();
            }

            function restoreState(state) {
                objects = JSON.parse(JSON.stringify(state.objects));
                dimensions = JSON.parse(JSON.stringify(state.dimensions));
                layers = JSON.parse(JSON.stringify(state.layers || [])); 
                currentLayerId = state.currentLayerId !== undefined ? state.currentLayerId : 0;
                nextLayerId = state.nextLayerId !== undefined ? state.nextLayerId : layers.length;

                nextObjectId = state.nextObjectId;
                nextDimensionId = state.nextDimensionId;
                selectedObjectIds = [...state.selectedObjectIds];
                selectedDimensionIds = [...state.selectedDimensionIds];

                if (currentTool === 'spline' && drawing) cancelSplineDrawing(false);
                drawing = false; startPoint = null; definingPoint2 = null; arcCenterPoint = null;
                ellipseCenter = null; ellipseRadiusXPoint = null;
                if (transformState.active) exitTransformTool(false);
                if (editModeActive) exitEditMode();
                objectToOffset = null; offsetPreviewObjects = [];
                resetTrimState(); resetExtendState();
                
                updateLayersUI(); 
                redrawCanvas();
                updateToolStatusAndCursor();
                updateUndoRedoButtons();
            }

            function undo() {
                if (undoStack.length > 0) {
                    const currentState = {
                        objects: JSON.parse(JSON.stringify(objects)),
                        dimensions: JSON.parse(JSON.stringify(dimensions)),
                        layers: JSON.parse(JSON.stringify(layers)),
                        currentLayerId: currentLayerId,
                        nextLayerId: nextLayerId,
                        nextObjectId: nextObjectId,
                        nextDimensionId: nextDimensionId,
                        selectedObjectIds: [...selectedObjectIds],
                        selectedDimensionIds: [...selectedDimensionIds],
                        description: "Actual"
                    };
                    redoStack.push(currentState);
                    const stateToRestore = undoStack.pop();
                    restoreState(stateToRestore);
                    toolStatusDiv.textContent = `Deshecho: ${stateToRestore.description || 'Acción previa'}`;
                }
            }

            function redo() {
                if (redoStack.length > 0) {
                    const currentState = {
                        objects: JSON.parse(JSON.stringify(objects)),
                        dimensions: JSON.parse(JSON.stringify(dimensions)),
                        layers: JSON.parse(JSON.stringify(layers)),
                        currentLayerId: currentLayerId,
                        nextLayerId: nextLayerId,
                        nextObjectId: nextObjectId,
                        nextDimensionId: nextDimensionId,
                        selectedObjectIds: [...selectedObjectIds],
                        selectedDimensionIds: [...selectedDimensionIds],
                        description: "Actual"
                    };
                    undoStack.push(currentState);
                     if (undoStack.length > MAX_HISTORY_STATES) {
                        undoStack.shift(); 
                    }
                    const stateToRestore = redoStack.pop();
                    restoreState(stateToRestore);
                    toolStatusDiv.textContent = `Rehecho: ${stateToRestore.description || 'Acción rehecha'}`;
                }
            }

            function updateUndoRedoButtons() {
                undoBtn.disabled = undoStack.length === 0;
                redoBtn.disabled = redoStack.length === 0;
            }

            function copySelection() {
                if (selectedObjectIds.length > 0) {
                    internalClipboard = objects
                        .filter(obj => selectedObjectIds.includes(obj.id))
                        .map(obj => JSON.parse(JSON.stringify(obj))); 
                    toolStatusDiv.textContent = `${internalClipboard.length} objeto(s) copiado(s).`;
                } else {
                    internalClipboard = [];
                    toolStatusDiv.textContent = "Nada seleccionado para copiar.";
                }
            }

            function pasteFromClipboard() {
                if (internalClipboard.length > 0) {
                    saveStateForUndo("Pegar objetos");
                    const newPastedIds = [];
                    const pasteOffsetVal = PASTE_OFFSET / scale; 

                    internalClipboard.forEach(clipboardObj => {
                        const newObj = JSON.parse(JSON.stringify(clipboardObj)); 
                        newObj.id = getNewObjectId();
                        newObj.layerId = currentLayerId; // Asignar capa activa al pegar

                        if (newObj.type === 'line') {
                            newObj.startX += pasteOffsetVal; newObj.startY += pasteOffsetVal;
                            newObj.endX += pasteOffsetVal;   newObj.endY += pasteOffsetVal;
                        } else if (newObj.type === 'circle' || newObj.type === 'ellipse' || newObj.type.startsWith('arc')) {
                            newObj.centerX += pasteOffsetVal; newObj.centerY += pasteOffsetVal;
                            if (newObj.p1) { newObj.p1.x += pasteOffsetVal; newObj.p1.y += pasteOffsetVal; }
                            if (newObj.p2) { newObj.p2.x += pasteOffsetVal; newObj.p2.y += pasteOffsetVal; }
                            if (newObj.p3) { newObj.p3.x += pasteOffsetVal; newObj.p3.y += pasteOffsetVal; }
                            if (newObj.pCenter) { newObj.pCenter.x += pasteOffsetVal; newObj.pCenter.y += pasteOffsetVal; }
                            if (newObj.pStart) { newObj.pStart.x += pasteOffsetVal; newObj.pStart.y += pasteOffsetVal; }
                            if (newObj.pEnd) { newObj.pEnd.x += pasteOffsetVal; newObj.pEnd.y += pasteOffsetVal; }
                        } else if (newObj.type === 'spline' || newObj.type === 'hexagon' || newObj.type === 'star') {
                            if (newObj.points) newObj.points = newObj.points.map(p => ({ x: p.x + pasteOffsetVal, y: p.y + pasteOffsetVal }));
                            if (newObj.centerX !== undefined) newObj.centerX += pasteOffsetVal;
                            if (newObj.centerY !== undefined) newObj.centerY += pasteOffsetVal;
                        } else if (newObj.type === 'point' || newObj.type === 'rectangle') {
                            if(newObj.x !== undefined) newObj.x += pasteOffsetVal; 
                            if(newObj.y !== undefined) newObj.y += pasteOffsetVal;
                        }
                        objects.push(newObj); 
                        newPastedIds.push(newObj.id);
                    });

                    selectedObjectIds = newPastedIds; 
                    selectedDimensionIds = [];
                    setTool('select'); 
                    redrawCanvas();
                    updateToolStatusAndCursor();
                    toolStatusDiv.textContent = `${newPastedIds.length} objeto(s) pegado(s).`;
                } else {
                    toolStatusDiv.textContent = "Portapapeles vacío.";
                }
            }

            function rotatePoint(point, center, angleRad) {
                const s = Math.sin(angleRad); const c = Math.cos(angleRad);
                const px = point.x - center.x; const py = point.y - center.y;
                const xnew = px * c - py * s; const ynew = px * s + py * c;
                return { x: xnew + center.x, y: ynew + center.y };
            }
            function scalePoint(point, base, factor) {
                const newX = base.x + (point.x - base.x) * factor;
                const newY = base.y + (point.y - base.y) * factor;
                return { x: newX, y: newY };
            }
            function applyRotationToObjects(objectList, center, angleRad) { 
                objectList.forEach(objId => {
                    const obj = objects.find(o => o.id === objId);
                    if (!obj) return;
                    if (obj.type === 'line') { const p1 = rotatePoint({ x: obj.startX, y: obj.startY }, center, angleRad); const p2 = rotatePoint({ x: obj.endX, y: obj.endY }, center, angleRad); obj.startX = p1.x; obj.startY = p1.y; obj.endX = p2.x; obj.endY = p2.y;
                    } else if (obj.type === 'circle' || obj.type === 'ellipse') { const newCenter = rotatePoint({ x: obj.centerX, y: obj.centerY }, center, angleRad); obj.centerX = newCenter.x; obj.centerY = newCenter.y; if (obj.type === 'ellipse') { obj.rotation = (obj.rotation || 0) + angleRad; }
                    } else if (obj.type === 'arc' || obj.type === 'arcCenterStartEnd') { const newCenter = rotatePoint({ x: obj.centerX, y: obj.centerY }, center, angleRad); obj.centerX = newCenter.x; obj.centerY = newCenter.y; obj.startAngle += angleRad; obj.endAngle += angleRad; if(obj.p1) obj.p1 = rotatePoint(obj.p1, center, angleRad); if(obj.p2) obj.p2 = rotatePoint(obj.p2, center, angleRad); if(obj.p3) obj.p3 = rotatePoint(obj.p3, center, angleRad); if(obj.pCenter) obj.pCenter = rotatePoint(obj.pCenter, center, angleRad); if(obj.pStart) obj.pStart = rotatePoint(obj.pStart, center, angleRad); if(obj.pEnd) obj.pEnd = rotatePoint(obj.pEnd, center, angleRad);
                    } else if (obj.type === 'spline' || obj.type === 'hexagon' || obj.type === 'star') { obj.points = obj.points.map(p => rotatePoint(p, center, angleRad)); if (obj.centerX !== undefined && obj.centerY !== undefined) { const newPolyCenter = rotatePoint({x: obj.centerX, y: obj.centerY}, center, angleRad); obj.centerX = newPolyCenter.x; obj.centerY = newPolyCenter.y; }
                    } else if (obj.type === 'point') { const newPt = rotatePoint({ x: obj.x, y: obj.y }, center, angleRad); obj.x = newPt.x; obj.y = newPt.y;
                    } else if (obj.type === 'rectangle') { const p1 = {x: obj.x, y: obj.y}; const p2 = {x: obj.x + obj.width, y: obj.y}; const p3 = {x: obj.x + obj.width, y: obj.y + obj.height}; const p4 = {x: obj.x, y: obj.y + obj.height}; const rp1 = rotatePoint(p1, center, angleRad); const rp2 = rotatePoint(p2, center, angleRad); const rp3 = rotatePoint(p3, center, angleRad); const rp4 = rotatePoint(p4, center, angleRad); const minX = Math.min(rp1.x, rp2.x, rp3.x, rp4.x); const minY = Math.min(rp1.y, rp2.y, rp3.y, rp4.y); const maxX = Math.max(rp1.x, rp2.x, rp3.x, rp4.x); const maxY = Math.max(rp1.y, rp2.y, rp3.y, rp4.y); obj.x = minX; obj.y = minY; obj.width = maxX - minX; obj.height = maxY - minY; }
                });
            }
            function applyScalingToObjects(objectList, basePoint, factor, uniform = true) { 
                objectList.forEach(objId => {
                    const obj = objects.find(o => o.id === objId);
                    if (!obj) return;
                    if (obj.type === 'line') { const p1 = scalePoint({ x: obj.startX, y: obj.startY }, basePoint, factor); const p2 = scalePoint({ x: obj.endX, y: obj.endY }, basePoint, factor); obj.startX = p1.x; obj.startY = p1.y; obj.endX = p2.x; obj.endY = p2.y;
                    } else if (obj.type === 'circle') { const newCenter = scalePoint({ x: obj.centerX, y: obj.centerY }, basePoint, factor); obj.centerX = newCenter.x; obj.centerY = newCenter.y; obj.radius = Math.max(0.1/scale, obj.radius * factor); 
                    } else if (obj.type === 'ellipse') { const newCenter = scalePoint({ x: obj.centerX, y: obj.centerY }, basePoint, factor); obj.centerX = newCenter.x; obj.centerY = newCenter.y; obj.radiusX = Math.max(0.1/scale, obj.radiusX * factor); obj.radiusY = Math.max(0.1/scale, obj.radiusY * factor);
                    } else if (obj.type === 'arc' || obj.type === 'arcCenterStartEnd') { const newCenter = scalePoint({ x: obj.centerX, y: obj.centerY }, basePoint, factor); obj.centerX = newCenter.x; obj.centerY = newCenter.y; obj.radius = Math.max(0.1/scale, obj.radius * factor); if(obj.p1) obj.p1 = scalePoint(obj.p1, basePoint, factor); if(obj.p2) obj.p2 = scalePoint(obj.p2, basePoint, factor); if(obj.p3) obj.p3 = scalePoint(obj.p3, basePoint, factor); if(obj.pCenter) obj.pCenter = scalePoint(obj.pCenter, basePoint, factor); if(obj.pStart) obj.pStart = scalePoint(obj.pStart, basePoint, factor); if(obj.pEnd) obj.pEnd = scalePoint(obj.pEnd, basePoint, factor); if (obj.type === 'arcCenterStartEnd' && obj.pStart && obj.pEnd && obj.pCenter) { obj.startAngle = Math.atan2(obj.pStart.y - obj.centerY, obj.pStart.x - obj.centerX); obj.endAngle = Math.atan2(obj.pEnd.y - obj.centerY, obj.pEnd.x - obj.centerX); } else if (obj.type === 'arc' && obj.p1 && obj.p3 && obj.p2){ const newArcParams = calculateArcParameters(obj.p1, obj.p2, obj.p3); if(newArcParams) { obj.centerX = newArcParams.centerX; obj.centerY = newArcParams.centerY; obj.radius = newArcParams.radius; obj.startAngle = newArcParams.startAngle; obj.endAngle = newArcParams.endAngle; obj.clockwise = newArcParams.clockwise; } }
                    } else if (obj.type === 'spline' || obj.type === 'hexagon' || obj.type === 'star') { obj.points = obj.points.map(p => scalePoint(p, basePoint, factor)); if (obj.centerX !== undefined && obj.centerY !== undefined) { const newPolyCenter = scalePoint({x: obj.centerX, y: obj.centerY}, basePoint, factor); obj.centerX = newPolyCenter.x; obj.centerY = newPolyCenter.y; } if(obj.radius !== undefined) obj.radius = Math.max(0.1/scale, obj.radius * factor); if(obj.outerRadius !== undefined) obj.outerRadius = Math.max(0.1/scale, obj.outerRadius * factor); if(obj.innerRadius !== undefined) obj.innerRadius = Math.max(0.1/scale, obj.innerRadius * factor); 
                    } else if (obj.type === 'point') { const newPt = scalePoint({ x: obj.x, y: obj.y }, basePoint, factor); obj.x = newPt.x; obj.y = newPt.y;
                    } else if (obj.type === 'rectangle') { const newTopLeft = scalePoint({ x: obj.x, y: obj.y }, basePoint, factor); const newBottomRight = scalePoint({ x: obj.x + obj.width, y: obj.y + obj.height }, basePoint, factor); obj.x = newTopLeft.x; obj.y = newTopLeft.y; obj.width = newBottomRight.x - newTopLeft.x; obj.height = newBottomRight.y - newTopLeft.y; if (obj.width < 0) { obj.x += obj.width; obj.width *= -1; } if (obj.height < 0) { obj.y += obj.height; obj.height *= -1; } }
                });
            }
            function initTransformTools() { }
            function activateTransformTool(mode) {
                if (selectedObjectIds.length === 0) { toolStatusDiv.textContent = `${mode === 'rotate' ? 'Rotar' : 'Escalar'}: Primero seleccione objetos.`; if(currentTool !== 'select') setTool('select'); return; }
                exitAllToolModes(mode); 
                transformState.active = true; transformState.mode = mode; transformState.objectsToTransform = [...selectedObjectIds];
                transformState.originalObjectStates.clear();
                transformState.objectsToTransform.forEach(id => { const objToCopy = objects.find(o => o.id === id); if (objToCopy) transformState.originalObjectStates.set(id, JSON.parse(JSON.stringify(objToCopy))); });
                transformState.center = calculateCentroid(transformState.objectsToTransform);
                if (!transformState.center) { console.warn("No se pudo calcular el centroide."); exitTransformTool(false); return; }
                transformState.dragStartPoint = null; transformState.currentAngleRad = 0; transformState.initialHandleAngleRad = 0; transformState.currentFactor = 1; transformState.initialHandleDistance = 1; 
                currentTool = mode; drawing = true; updateToolStatusAndCursor(); showTransformValues(); redrawCanvas();
            }
            function exitTransformTool(applyChanges = false) {
                if (!transformState.active) return;
                if (applyChanges) { saveStateForUndo(`Transformar (${transformState.mode})`); } 
                else { transformState.objectsToTransform.forEach(id => { const originalState = transformState.originalObjectStates.get(id); const currentObjIndex = objects.findIndex(o => o.id === id); if (originalState && currentObjIndex !== -1) { objects[currentObjIndex] = JSON.parse(JSON.stringify(originalState)); } }); }
                resetTransformStateOnly(); hideTransformValues(); redrawCanvas(); 
            }
            function resetTransformStateOnly() {
                 transformState.active = false; transformState.mode = null; transformState.center = null; transformState.dragStartPoint = null;
                transformState.currentAngleRad = 0; transformState.initialHandleAngleRad = 0; transformState.currentFactor = 1; transformState.initialHandleDistance = 1; transformState.isSnapping = false;
            }
            function calculateCentroid(objectIds) {
                if (!objectIds || objectIds.length === 0) return null;
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity; let foundValidBounds = false;
                objectIds.forEach(id => {
                    const obj = objects.find(o => o.id === id); if (!obj) return;
                    let objBounds = { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity }; 
                    if (obj.type === 'point') { objBounds = { minX: obj.x, minY: obj.y, maxX: obj.x, maxY: obj.y };
                    } else if (obj.type === 'line') { objBounds = { minX: Math.min(obj.startX, obj.endX), minY: Math.min(obj.startY, obj.endY), maxX: Math.max(obj.startX, obj.endX), maxY: Math.max(obj.startY, obj.endY) };
                    } else if (obj.type === 'circle') { objBounds = { minX: obj.centerX - obj.radius, minY: obj.centerY - obj.radius, maxX: obj.centerX + obj.radius, maxY: obj.centerY + obj.radius };
                    } else if (obj.type === 'ellipse') { const { centerX, centerY, radiusX, radiusY, rotation = 0 } = obj; const cosR = Math.cos(rotation); const sinR = Math.sin(rotation); const extentsX = Math.sqrt(radiusX*radiusX * cosR*cosR + radiusY*radiusY * sinR*sinR); const extentsY = Math.sqrt(radiusX*radiusX * sinR*sinR + radiusY*radiusY * cosR*cosR); objBounds = { minX: centerX - extentsX, minY: centerY - extentsY, maxX: centerX + extentsX, maxY: centerY + extentsY };
                    } else if (obj.type === 'rectangle') { objBounds = { minX: obj.x, minY: obj.y, maxX: obj.x + obj.width, maxY: obj.y + obj.height };
                    } else if (obj.type === 'arc' || obj.type === 'arcCenterStartEnd') { const pointsOnArc = [ {x: obj.centerX + obj.radius * Math.cos(obj.startAngle), y: obj.centerY + obj.radius * Math.sin(obj.startAngle)}, {x: obj.centerX + obj.radius * Math.cos(obj.endAngle), y: obj.centerY + obj.radius * Math.sin(obj.endAngle)} ]; const anglesToCheck = [0, Math.PI/2, Math.PI, 3*Math.PI/2]; let sNorm = (obj.startAngle % (2*Math.PI) + 2*Math.PI) % (2*Math.PI); let eNorm = (obj.endAngle % (2*Math.PI) + 2*Math.PI) % (2*Math.PI); let isObjClockwise = obj.type === 'arc' ? obj.clockwise : !obj.counterClockwise; const epsilonAngle = 1e-5; anglesToCheck.forEach(angle => { let inArc = false; if (Math.abs(sNorm - eNorm) < epsilonAngle || Math.abs(Math.abs(sNorm - eNorm) - 2*Math.PI) < epsilonAngle) { inArc = true; } else if (isObjClockwise) { if (sNorm >= eNorm) inArc = (angle <= sNorm + epsilonAngle && angle >= eNorm - epsilonAngle); else inArc = (angle <= sNorm + epsilonAngle || angle >= eNorm - epsilonAngle); } else { if (sNorm <= eNorm) inArc = (angle >= sNorm - epsilonAngle && angle <= eNorm + epsilonAngle); else inArc = (angle >= sNorm - epsilonAngle || angle <= eNorm + epsilonAngle); } if (inArc) pointsOnArc.push({x: obj.centerX + obj.radius * Math.cos(angle), y: obj.centerY + obj.radius * Math.sin(angle)}); }); pointsOnArc.forEach(p => { objBounds.minX = Math.min(objBounds.minX, p.x); objBounds.minY = Math.min(objBounds.minY, p.y); objBounds.maxX = Math.max(objBounds.maxX, p.x); objBounds.maxY = Math.max(objBounds.maxY, p.y); }); if (objBounds.minX === Infinity) { objBounds = { minX: obj.centerX - obj.radius, minY: obj.centerY - obj.radius, maxX: obj.centerX + obj.radius, maxY: obj.centerY + obj.radius }; }
                    } else if (obj.points && obj.points.length > 0) { obj.points.forEach(p => { objBounds.minX = Math.min(objBounds.minX, p.x); objBounds.minY = Math.min(objBounds.minY, p.y); objBounds.maxX = Math.max(objBounds.maxX, p.x); objBounds.maxY = Math.max(objBounds.maxY, p.y); }); }
                    if (objBounds.minX !== Infinity) { minX = Math.min(minX, objBounds.minX); minY = Math.min(minY, objBounds.minY); maxX = Math.max(maxX, objBounds.maxX); maxY = Math.max(maxY, objBounds.maxY); foundValidBounds = true; }
                });
                if (!foundValidBounds) return (objects.length > 0 && objects[0].centerX !== undefined) ? {x: objects[0].centerX, y: objects[0].centerY} : {x:0, y:0}; 
                return { x: (minX + maxX) / 2, y: (minY + maxY) / 2 };
            }
            function handleTransformMouseDown(event) { 
                if (!transformState.active || event.button !== 0) return false; 
                const handleInfo = getTransformHandleAtPosition(mousePosWorld);
                if (handleInfo) { transformState.dragStartPoint = { ...mousePosWorld, handleType: handleInfo.type, handleIndex: handleInfo.index }; if (transformState.mode === 'rotate') { transformState.initialHandleAngleRad = Math.atan2( mousePosWorld.y - transformState.center.y, mousePosWorld.x - transformState.center.x ); } else if (transformState.mode === 'scale') { transformState.initialHandleDistance = distance(transformState.center, mousePosWorld); if (transformState.initialHandleDistance < 1e-6 / scale) transformState.initialHandleDistance = 1; } return true; } return false; 
            }
            function handleTransformMouseMove(event) { 
                if (!transformState.active || !transformState.dragStartPoint) return false;
                transformState.isSnapping = event.shiftKey; 
                transformState.objectsToTransform.forEach(id => { const originalToolActivationState = transformState.originalObjectStates.get(id); const currentObjIndex = objects.findIndex(o => o.id === id); if (originalToolActivationState && currentObjIndex !== -1) { objects[currentObjIndex] = JSON.parse(JSON.stringify(originalToolActivationState)); } });
                if (transformState.mode === 'rotate') { const currentMouseAngleRad = Math.atan2( mousePosWorld.y - transformState.center.y, mousePosWorld.x - transformState.center.x ); let deltaAngleRad = currentMouseAngleRad - transformState.initialHandleAngleRad; if (transformState.isSnapping) { const snapRad = (transformState.snapAngleDeg * Math.PI) / 180; deltaAngleRad = Math.round(deltaAngleRad / snapRad) * snapRad; } transformState.currentAngleRad = deltaAngleRad; applyRotationToObjects(transformState.objectsToTransform, transformState.center, transformState.currentAngleRad);
                } else if (transformState.mode === 'scale') { const currentMouseDistance = distance(transformState.center, mousePosWorld); let factor = transformState.initialHandleDistance > 1e-6 / scale ? currentMouseDistance / transformState.initialHandleDistance : 1; if (factor < 0.01) factor = 0.01; if (transformState.isSnapping) { factor = Math.round(factor / transformState.snapScaleFactor) * transformState.snapScaleFactor; if (factor < 0.01) factor = Math.max(0.01, transformState.snapScaleFactor); } transformState.currentFactor = factor; applyScalingToObjects(transformState.objectsToTransform, transformState.center, transformState.currentFactor, transformState.uniformScale); }
                showTransformValues(); return true;
            }
            function handleTransformMouseUp(event) { if (!transformState.active || !transformState.dragStartPoint || event.button !== 0) return false; transformState.dragStartPoint = null; redrawCanvas(); return true; }
            function handleTransformKeydown(event) { 
                if (!transformState.active || isInputFocused()) return false; let eventHandled = false;
                if (event.key === 'Escape') { exitTransformTool(false); setTool('select'); eventHandled = true;
                } else if (event.key === 'Enter') { exitTransformTool(true); setTool('select'); eventHandled = true;
                } else if (event.shiftKey && !transformState.isSnapping) { transformState.isSnapping = true; if (transformState.dragStartPoint) { const pseudoEvent = new MouseEvent('mousemove', { clientX: lastKnownMouseScreenPos.x + canvas.getBoundingClientRect().left, clientY: lastKnownMouseScreenPos.y + canvas.getBoundingClientRect().top, shiftKey: true }); mousePosWorld = getMouseWorldPositionWithAids(pseudoEvent); handleTransformMouseMove(pseudoEvent); } showTransformValues(); redrawCanvas(); eventHandled = true;  }
                if (eventHandled) { event.preventDefault(); return true; } return false; 
            }
            function handleTransformKeyup(event) { 
                if (!transformState.active || isInputFocused() || event.key !== 'Shift') return false; let eventHandled = false;
                if (transformState.isSnapping) { transformState.isSnapping = false; if (transformState.dragStartPoint) { const pseudoEvent = new MouseEvent('mousemove', { clientX: lastKnownMouseScreenPos.x + canvas.getBoundingClientRect().left, clientY: lastKnownMouseScreenPos.y + canvas.getBoundingClientRect().top, shiftKey: false }); mousePosWorld = getMouseWorldPositionWithAids(pseudoEvent); handleTransformMouseMove(pseudoEvent); } showTransformValues(); redrawCanvas(); eventHandled = true; }
                return eventHandled;
            }
            function drawTransformControls() { 
                if (!transformState.active || !transformState.center || !transformState.showHandles) return;
                const { center, mode, currentAngleRad, currentFactor, initialHandleAngleRad, dragStartPoint } = transformState;
                const handleScreenRadius = 8; const visualRadiusWorld = TRANSFORM_HANDLE_VISUAL_RADIUS / scale; 
                const handleBaseColor = getComputedStyle(document.documentElement).getPropertyValue('--cad-transform-handle-color');
                ctx.save();
                ctx.beginPath(); ctx.arc(center.x, center.y, handleScreenRadius * 0.7 / scale, 0, Math.PI * 2); ctx.fillStyle = handleBaseColor; ctx.fill();
                ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--canvas-bg'); ctx.lineWidth = 1.5 / scale; ctx.stroke();
                ctx.beginPath(); ctx.arc(center.x, center.y, visualRadiusWorld, 0, Math.PI * 2); ctx.strokeStyle = mode === 'rotate' ? `rgba(${hexToRgb(handleBaseColor)}, 0.5)` : `rgba(${hexToRgb(getComputedStyle(document.documentElement).getPropertyValue('--accent'))}, 0.5)`; ctx.setLineDash([5 / scale, 5 / scale]); ctx.stroke(); ctx.setLineDash([]);
                let displayHandleAngle;
                if (mode === 'rotate') { displayHandleAngle = (dragStartPoint ? Math.atan2(mousePosWorld.y - center.y, mousePosWorld.x - center.x) : (initialHandleAngleRad + currentAngleRad) ); if(!dragStartPoint && initialHandleAngleRad === 0 && currentAngleRad === 0 && transformState.objectsToTransform.length > 0) { const firstObj = objects.find(o => o.id === transformState.objectsToTransform[0]); if (firstObj && firstObj.centerX !== undefined) { displayHandleAngle = Math.atan2( (firstObj.centerY - visualRadiusWorld) - center.y, firstObj.centerX - center.x); } else { displayHandleAngle = -Math.PI / 4; } } else if (!dragStartPoint && initialHandleAngleRad === 0 && currentAngleRad === 0){ displayHandleAngle = -Math.PI / 4; }
                } else { displayHandleAngle = (dragStartPoint ? Math.atan2(mousePosWorld.y - center.y, mousePosWorld.x - center.x) : -Math.PI / 4); }
                const effectiveDisplayRadius = (mode === 'scale' && dragStartPoint) ? distance(center, mousePosWorld) : ( (mode === 'scale') ? visualRadiusWorld * currentFactor : visualRadiusWorld ); 
                const handleDisplayX = center.x + effectiveDisplayRadius * Math.cos(displayHandleAngle); const handleDisplayY = center.y + effectiveDisplayRadius * Math.sin(displayHandleAngle);
                ctx.beginPath(); ctx.lineWidth = 1.5 / scale; ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--canvas-bg');
                if (mode === 'rotate') { ctx.arc(handleDisplayX, handleDisplayY, handleScreenRadius / scale, 0, Math.PI * 2); ctx.fillStyle = `rgba(${hexToRgb(handleBaseColor)}, 0.8)`; 
                } else { const s = handleScreenRadius / scale; ctx.rect(handleDisplayX - s/2, handleDisplayY - s/2, s, s); ctx.fillStyle = `rgba(${hexToRgb(getComputedStyle(document.documentElement).getPropertyValue('--accent'))}, 0.8)`; }
                ctx.fill(); ctx.stroke(); ctx.restore();
            }
            function getTransformHandleAtPosition(pos) { 
                if (!transformState.active || !transformState.center || !transformState.showHandles) return null;
                const handleScreenRadius = 8; const visualRadiusWorld = TRANSFORM_HANDLE_VISUAL_RADIUS / scale;
                const { center, mode, currentAngleRad, currentFactor, initialHandleAngleRad, dragStartPoint } = transformState;
                let handleAngleForHitTest;
                 if (mode === 'rotate') { handleAngleForHitTest = (dragStartPoint ? Math.atan2(mousePosWorld.y - center.y, mousePosWorld.x - center.x) : (initialHandleAngleRad + currentAngleRad) ); if(!dragStartPoint && initialHandleAngleRad === 0 && currentAngleRad === 0 && transformState.objectsToTransform.length > 0) { const firstObj = objects.find(o => o.id === transformState.objectsToTransform[0]); if (firstObj && firstObj.centerX !== undefined) { handleAngleForHitTest = Math.atan2( (firstObj.centerY - visualRadiusWorld) - center.y, firstObj.centerX - center.x); } else { handleAngleForHitTest = -Math.PI / 4; } } else if (!dragStartPoint && initialHandleAngleRad === 0 && currentAngleRad === 0){ handleAngleForHitTest = -Math.PI / 4; }
                } else { handleAngleForHitTest = (dragStartPoint ? Math.atan2(mousePosWorld.y - center.y, mousePosWorld.x - center.x) : -Math.PI / 4); }
                const effectiveHitRadius = (mode === 'scale' && dragStartPoint) ? distance(center, mousePosWorld) : ( (mode === 'scale') ? visualRadiusWorld * currentFactor : visualRadiusWorld );
                const handleX = center.x + effectiveHitRadius * Math.cos(handleAngleForHitTest); const handleY = center.y + effectiveHitRadius * Math.sin(handleAngleForHitTest);
                if (distance(pos, { x: handleX, y: handleY }) <= (handleScreenRadius * 1.8) / scale) { return { type: 'transform', index: 0 }; } return null;
            }
            function showTransformValues() { 
                if (!transformValuesDiv) return;
                if (!transformState.active || !transformState.center) { transformValuesDiv.style.display = 'none'; return; }
                transformValuesDiv.style.display = 'block'; let text = '';
                if (transformState.mode === 'rotate') { const angleDegrees = (transformState.currentAngleRad * 180) / Math.PI; text = `Rotar: ${angleDegrees.toFixed(1)}° ${transformState.isSnapping ? '[SNAP]' : ''}`;
                } else if (transformState.mode === 'scale') { text = `Escalar: ${transformState.currentFactor.toFixed(2)}x ${transformState.isSnapping ? '[SNAP]' : ''}`; }
                transformValuesDiv.textContent = text;
            }
            function hideTransformValues() { if (transformValuesDiv) transformValuesDiv.style.display = 'none'; }

            function resizeCanvas() { 
                requestAnimationFrame(() => { 
                    const dpr = window.devicePixelRatio || 1;
                    canvas.width = canvasContainer.clientWidth * dpr;
                    canvas.height = canvasContainer.clientHeight * dpr;
                    canvas.style.width = canvasContainer.clientWidth + 'px';
                    canvas.style.height = canvasContainer.clientHeight + 'px';
                    ctx.scale(dpr, dpr); 
                    
                    if (objects.length === 0 && dimensions.length === 0 && scale === 1.0 && !transformState.active && undoStack.length === 0) { 
                        offsetCanvas.x = (canvas.width / dpr) / 2;
                        offsetCanvas.y = (canvas.height / dpr) / 2;
                    }
                    redrawCanvas();
                });
            }
            window.addEventListener('resize', resizeCanvas);


            function getNewObjectId() { return nextObjectId++; }
            function getNewDimensionId() { return nextDimensionId++; }

            function screenToWorld(sX, sY) { return { x: (sX - offsetCanvas.x) / scale, y: (sY - offsetCanvas.y) / scale }; }
            function worldToScreen(wX, wY) { return { x: wX * scale + offsetCanvas.x, y: wY * scale + offsetCanvas.y }; }
            
            function distSq(p1, p2) { const dx = p1.x - p2.x; const dy = p1.y - p2.y; return dx * dx + dy * dy; }
            function distance(p1, p2) { return Math.hypot(p1.x - p2.x, p1.y - p2.y); }

            function calculateArcParameters(p1, p2, p3) { 
                const temp = p2.x * p2.x + p2.y * p2.y;
                const bc = (p1.x * p1.x + p1.y * p1.y - temp) / 2;
                const cd = (temp - p3.x * p3.x - p3.y * p3.y) / 2;
                const det = (p1.x - p2.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p2.y);

                if (Math.abs(det) < 1e-9) { return null; } 

                const idet = 1 / det;
                const centerX = (bc * (p2.y - p3.y) - cd * (p1.y - p2.y)) * idet;
                const centerY = (cd * (p1.x - p2.x) - bc * (p2.x - p3.x)) * idet;
                const radius = Math.hypot(p1.x - centerX, p1.y - centerY);

                let startAngle = Math.atan2(p1.y - centerY, p1.x - centerX);
                let midAngle = Math.atan2(p2.y - centerY, p2.x - centerX);
                let endAngle = Math.atan2(p3.y - centerY, p3.x - centerX);
                
                const PI2 = Math.PI * 2;
                startAngle = (startAngle % PI2 + PI2) % PI2;
                midAngle = (midAngle % PI2 + PI2) % PI2;
                endAngle = (endAngle % PI2 + PI2) % PI2;

                let clockwise = false; 
                if (startAngle < endAngle) { 
                    if (!(midAngle > startAngle && midAngle < endAngle)) {
                        clockwise = true;
                    }
                } else { 
                    if (!(midAngle > startAngle || midAngle < endAngle)) {
                        clockwise = true;
                    }
                }
                return { centerX, centerY, radius, startAngle, endAngle, clockwise: clockwise };
            }

            function applyOrthoMode(currentWorldPos, referenceWorldPos) { 
                 if (transformState.active || !orthoModeEnabled || !referenceWorldPos || 
                    !(drawing && !editModeActive && !isDraggingObject && 
                      (['line', 'circle', 'arc', 'arcCenterStartEnd', 'spline', 'point', 'rectangle', 'ellipse', 'hexagon', 'star', 'polygon'].includes(currentTool) || 
                       ((currentTool === 'dimHorizontal' || currentTool === 'dimVertical') && startPoint && !definingPoint2) 
                      )
                     )
                   ) return currentWorldPos; 
                const dX = Math.abs(currentWorldPos.x - referenceWorldPos.x); 
                const dY = Math.abs(currentWorldPos.y - referenceWorldPos.y); 
                if (dX > dY) return { x: currentWorldPos.x, y: referenceWorldPos.y }; 
                else return { x: referenceWorldPos.x, y: currentWorldPos.y }; 
            }

            function snapToGrid(worldPos) {
                if (!snapToGridEnabled) return worldPos;
                return {
                    x: Math.round(worldPos.x / GRID_SIZE) * GRID_SIZE,
                    y: Math.round(worldPos.y / GRID_SIZE) * GRID_SIZE
                };
            }

            function getLineSegmentIntersection(l1, l2) { 
                const x1 = l1.p1.x, y1 = l1.p1.y, x2 = l1.p2.x, y2 = l1.p2.y;
                const x3 = l2.p1.x, y3 = l2.p1.y, x4 = l2.p2.x, y4 = l2.p2.y;
                const den = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
                if (den === 0) return null; 
                const tNum = (x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4);
                const uNum = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3));
                const t = tNum / den; const u = uNum / den;
                const epsilon = 1e-6; 
                if (t >= -epsilon && t <= 1 + epsilon && u >= -epsilon && u <= 1 + epsilon) { 
                    return { x: x1 + t * (x2 - x1), y: y1 + t * (y2 - y1) };
                }
                return null; 
            }

            function getNearestPointOnLineSegment(p, lineStart, lineEnd) {
                const l2 = distSq(lineStart, lineEnd);
                if (l2 === 0) return { ...lineStart }; 
                let t = ((p.x - lineStart.x) * (lineEnd.x - lineStart.x) + (p.y - lineStart.y) * (lineEnd.y - lineStart.y)) / l2;
                t = Math.max(0, Math.min(1, t)); 
                return { x: lineStart.x + t * (lineEnd.x - lineStart.x), y: lineStart.y + t * (lineEnd.y - lineStart.y) };
            }

            function getTangentPointsFromPointToCircle(extPt, circleCenter, radius) {
                const dSq = distSq(extPt, circleCenter);
                const rSq = radius * radius;
                if (dSq < rSq - 1e-9) return []; 
                if (Math.abs(dSq - rSq) < 1e-9) return [{...extPt}]; 

                const d = Math.sqrt(dSq);
                const K = Math.sqrt(dSq - rSq); 
                
                const tangentPoints = [];
                const angle_ep_c = Math.atan2(circleCenter.y - extPt.y, circleCenter.x - extPt.x);
                const angle_delta = Math.acos(K / d) ; 

                const tp1_angle = angle_ep_c + angle_delta;
                tangentPoints.push({
                    x: extPt.x + K * Math.cos(tp1_angle),
                    y: extPt.y + K * Math.sin(tp1_angle)
                });

                const tp2_angle = angle_ep_c - angle_delta;
                 tangentPoints.push({
                    x: extPt.x + K * Math.cos(tp2_angle),
                    y: extPt.y + K * Math.sin(tp2_angle)
                });
                return tangentPoints.filter(p => !isNaN(p.x) && !isNaN(p.y)); 
            }

            function findSnaps(worldMousePos, drawingStartPoint = null) {
                if (transformState.active && transformState.dragStartPoint) return null;

                const snapToleranceWorldSq = (SNAP_TOLERANCE_SCREEN / scale) * (SNAP_TOLERANCE_SCREEN / scale);
                let closestSnap = null;
                let minDistanceSq = snapToleranceWorldSq;

                function updateClosestSnap(snap, dSq) {
                    if (dSq < minDistanceSq) {
                        minDistanceSq = dSq;
                        closestSnap = snap;
                    }
                }
                 objects.forEach(obj => {
                    if (obj.isPreview || !isObjectVisible(obj)) return; // Check layer visibility

                    if (obj.type === 'line') {
                        const p1 = { x: obj.startX, y: obj.startY };
                        const p2 = { x: obj.endX, y: obj.endY };
                        if (refEndpointCb.checked) {
                            updateClosestSnap({ type: 'endpoint', x: p1.x, y: p1.y, text: 'P. Final' }, distSq(worldMousePos, p1));
                            updateClosestSnap({ type: 'endpoint', x: p2.x, y: p2.y, text: 'P. Final' }, distSq(worldMousePos, p2));
                        }
                        if (refMidpointCb.checked) {
                            const mid = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
                            updateClosestSnap({ type: 'midpoint', x: mid.x, y: mid.y, text: 'P. Medio' }, distSq(worldMousePos, mid));
                        }
                        if (refNearestCb.checked) {
                            const nearest = getNearestPointOnLineSegment(worldMousePos, p1, p2);
                            if (!refEndpointCb.checked || (distance(nearest, p1) > 1e-6 && distance(nearest, p2) > 1e-6)) {
                                updateClosestSnap({ type: 'nearest', x: nearest.x, y: nearest.y, text: 'Cercano' }, distSq(worldMousePos, nearest));
                            }
                        }
                    } else if (obj.type === 'circle') {
                        const center = { x: obj.centerX, y: obj.centerY };
                        if (refCenterCb.checked) {
                            updateClosestSnap({ type: 'center', x: center.x, y: center.y, text: 'Centro' }, distSq(worldMousePos, center));
                        }
                        if (refQuadrantCb.checked) {
                            const qPoints = [
                                { x: center.x, y: center.y - obj.radius, name: 'N' }, { x: center.x + obj.radius, y: center.y, name: 'E' },
                                { x: center.x, y: center.y + obj.radius, name: 'S' }, { x: center.x - obj.radius, y: center.y, name: 'O' }
                            ];
                            qPoints.forEach(q => updateClosestSnap({ type: 'quadrant', x: q.x, y: q.y, text: `Cuadrante` }, distSq(worldMousePos, q)));
                        }
                        if (refTangentCb.checked && drawingStartPoint && (currentTool === 'line' || (currentTool === 'spline' && currentSplinePoints.length > 0))) {
                            const tangentPoints = getTangentPointsFromPointToCircle(drawingStartPoint, center, obj.radius);
                            tangentPoints.forEach(tp => updateClosestSnap({ type: 'tangent', x: tp.x, y: tp.y, text: 'Tangente' }, distSq(worldMousePos, tp)));
                        }
                    } else if (obj.type === 'arc' || obj.type === 'arcCenterStartEnd') {
                        const center = { x: obj.centerX, y: obj.centerY };
                        if (refCenterCb.checked) {
                            updateClosestSnap({ type: 'center', x: center.x, y: center.y, text: 'Centro (Arco)' }, distSq(worldMousePos, center));
                        }
                        if (refEndpointCb.checked) {
                            const p1_arc = { x: obj.centerX + obj.radius * Math.cos(obj.startAngle), y: obj.centerY + obj.radius * Math.sin(obj.startAngle) };
                            const p3_arc = { x: obj.centerX + obj.radius * Math.cos(obj.endAngle), y: obj.centerY + obj.radius * Math.sin(obj.endAngle) };
                            updateClosestSnap({ type: 'endpoint', x: p1_arc.x, y: p1_arc.y, text: 'P. Final (Arco)' }, distSq(worldMousePos, p1_arc));
                            updateClosestSnap({ type: 'endpoint', x: p3_arc.x, y: p3_arc.y, text: 'P. Final (Arco)' }, distSq(worldMousePos, p3_arc));
                        }
                         if (refQuadrantCb.checked) {
                            const qPoints = [ 
                                { x: center.x, y: center.y - obj.radius }, { x: center.x + obj.radius, y: center.y },
                                { x: center.x, y: center.y + obj.radius }, { x: center.x - obj.radius, y: center.y }
                            ];
                            qPoints.forEach(q => {
                                let angle = Math.atan2(q.y - center.y, q.x - center.x);
                                let sA = obj.startAngle, eA = obj.endAngle;
                                const twoPi = 2 * Math.PI;
                                angle = (angle % twoPi + twoPi) % twoPi; 
                                sA = (sA % twoPi + twoPi) % twoPi;
                                eA = (eA % twoPi + twoPi) % twoPi;

                                let isOnArc;
                                const isObjClockwise = obj.type === 'arc' ? obj.clockwise : !obj.counterClockwise;

                                if (isObjClockwise) { 
                                    if (sA >= eA) isOnArc = (angle <= sA && angle >= eA);
                                    else isOnArc = (angle <= sA || angle >= eA); 
                                } else { 
                                    if (sA <= eA) isOnArc = (angle >= sA && angle <= eA);
                                    else isOnArc = (angle >= sA || angle <= eA); 
                                }
                                if (isOnArc) {
                                    updateClosestSnap({ type: 'quadrant', x: q.x, y: q.y, text: `Cuadrante (Arco)` }, distSq(worldMousePos, q));
                                }
                            });
                        }
                    } else if (obj.type === 'point') {
                        if (refEndpointCb.checked || refNearestCb.checked) { 
                             updateClosestSnap({ type: 'endpoint', x: obj.x, y: obj.y, text: 'Punto' }, distSq(worldMousePos, {x: obj.x, y: obj.y}));
                        }
                    } else if (obj.type === 'rectangle' || obj.type === 'hexagon' || obj.type === 'star') {
                        if (obj.points && obj.points.length > 0) {
                            obj.points.forEach((pt, index) => {
                                if (refEndpointCb.checked) { 
                                    updateClosestSnap({ type: 'endpoint', x: pt.x, y: pt.y, text: 'Vértice' }, distSq(worldMousePos, pt));
                                }
                                if (refMidpointCb.checked && obj.points.length > 1) { 
                                    const pNext = obj.points[(index + 1) % obj.points.length];
                                    const mid = { x: (pt.x + pNext.x) / 2, y: (pt.y + pNext.y) / 2 };
                                    updateClosestSnap({ type: 'midpoint', x: mid.x, y: mid.y, text: 'P. Medio' }, distSq(worldMousePos, mid));
                                }
                            });
                            if (refCenterCb.checked && obj.centerX && obj.centerY) { 
                                updateClosestSnap({ type: 'center', x: obj.centerX, y: obj.centerY, text: 'Centro' }, distSq(worldMousePos, {x: obj.centerX, y: obj.centerY}));
                            }
                        }
                    } else if (obj.type === 'ellipse') {
                        if (refCenterCb.checked) {
                            updateClosestSnap({ type: 'center', x: obj.centerX, y: obj.centerY, text: 'Centro (Elipse)' }, distSq(worldMousePos, {x:obj.centerX, y:obj.centerY}));
                        }
                        if (refQuadrantCb.checked) {
                            const rot = obj.rotation || 0;
                            const cosR = Math.cos(rot); const sinR = Math.sin(rot);
                            const qx1 = obj.centerX + obj.radiusX * cosR; const qy1 = obj.centerY + obj.radiusX * sinR;
                            const qx2 = obj.centerX - obj.radiusX * cosR; const qy2 = obj.centerY - obj.radiusX * sinR;
                            const qx3 = obj.centerX - obj.radiusY * sinR; const qy3 = obj.centerY + obj.radiusY * cosR; 
                            const qx4 = obj.centerX + obj.radiusY * sinR; const qy4 = obj.centerY - obj.radiusY * cosR;
                            updateClosestSnap({ type: 'quadrant', x: qx1, y: qy1, text: 'Cuadrante' }, distSq(worldMousePos, {x:qx1, y:qy1}));
                            updateClosestSnap({ type: 'quadrant', x: qx2, y: qy2, text: 'Cuadrante' }, distSq(worldMousePos, {x:qx2, y:qy2}));
                            updateClosestSnap({ type: 'quadrant', x: qx3, y: qy3, text: 'Cuadrante' }, distSq(worldMousePos, {x:qx3, y:qy3}));
                            updateClosestSnap({ type: 'quadrant', x: qx4, y: qy4, text: 'Cuadrante' }, distSq(worldMousePos, {x:qx4, y:qy4}));
                        }
                    }
                });

                if (refIntersectionCb.checked) {
                    for (let i = 0; i < objects.length; i++) {
                        if (objects[i].type !== 'line' || objects[i].isPreview || !isObjectVisible(objects[i])) continue;
                        for (let j = i + 1; j < objects.length; j++) {
                            if (objects[j].type !== 'line' || objects[j].isPreview || !isObjectVisible(objects[j])) continue;
                            const line1 = { p1: {x: objects[i].startX, y: objects[i].startY}, p2: {x: objects[i].endX, y: objects[i].endY} };
                            const line2 = { p1: {x: objects[j].startX, y: objects[j].startY}, p2: {x: objects[j].endX, y: objects[j].endY} };
                            const intersectionPt = getLineSegmentIntersection(line1, line2);
                            if (intersectionPt) {
                                updateClosestSnap({ type: 'intersection', x: intersectionPt.x, y: intersectionPt.y, text: 'Intersección' }, distSq(worldMousePos, intersectionPt));
                            }
                        }
                    }
                }
                return closestSnap;
            }

            function showSnapIndicator() { 
                snapIndicatorDiv.innerHTML = ''; 

                const isGeometricDrawingToolActive = ['line', 'circle', 'spline', 'arc', 'arcCenterStartEnd', 'point', 'rectangle', 'ellipse', 'hexagon', 'star', 'polygon'].includes(currentTool);
                const isTransformToolDefiningPoints = (transformState.active && !transformState.dragStartPoint); 
                
                const isDimToolDefiningPoints = drawing && (currentTool === 'dimHorizontal' || currentTool === 'dimVertical') && (!definingPoint2 || !startPoint); 
                
                const shouldShowObjectSnapIndicator = 
                    (currentSnap && currentSnap.type !== 'grid' && (isGeometricDrawingToolActive || isDimToolDefiningPoints || isTransformToolDefiningPoints));
                
                const isGridSnapRelevant = currentSnap && currentSnap.type === 'grid' && snapToGridEnabled &&
                    ( ((currentTool === 'dimHorizontal' || currentTool === 'dimVertical') && startPoint && definingPoint2) || 
                      (isGeometricDrawingToolActive && (!drawing || !startPoint || (currentTool==='spline' && currentSplinePoints.length===0) || (currentTool==='arcCenterStartEnd' && !arcCenterPoint) || (currentTool === 'ellipse' && !ellipseCenter) )) || 
                      (isTransformToolDefiningPoints) || 
                      ((currentTool === 'dimHorizontal' || currentTool === 'dimVertical') && (!drawing || !startPoint)) 
                    );

                if (!currentSnap || !(shouldShowObjectSnapIndicator || isGridSnapRelevant)) {
                    snapIndicatorDiv.style.opacity = '0';
                    return;
                }

                const screenPos = worldToScreen(currentSnap.x, currentSnap.y);
                let snapLabelElement = document.createElement('div');
                snapLabelElement.className = 'snap-indicator-label';
                snapLabelElement.innerText = currentSnap.text;
                snapIndicatorDiv.appendChild(snapLabelElement);

                const canvasRect = canvas.getBoundingClientRect();
                const containerRect = canvasContainer.getBoundingClientRect(); 
                snapIndicatorDiv.style.left = (screenPos.x - (canvasRect.left - containerRect.left)) + 'px';
                snapIndicatorDiv.style.top = (screenPos.y - (canvasRect.top - containerRect.top)) + 'px';
                snapIndicatorDiv.style.opacity = '1';

                const dpr = window.devicePixelRatio || 1;
                ctx.save();
                ctx.setTransform(dpr, 0, 0, dpr, 0, 0); 
                ctx.translate(offsetCanvas.x, offsetCanvas.y); 
                ctx.scale(scale, scale); 
                
                ctx.translate(currentSnap.x, currentSnap.y); 
                ctx.lineWidth = 1.5 / scale; 
                ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--cad-snap-indicator-color');
                ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--cad-snap-indicator-color');
                ctx.beginPath();

                switch (currentSnap.type) {
                    case 'endpoint': ctx.rect(-SNAP_SYMBOL_SIZE/(2*scale), -SNAP_SYMBOL_SIZE/(2*scale), SNAP_SYMBOL_SIZE/scale, SNAP_SYMBOL_SIZE/scale); break;
                    case 'midpoint': ctx.moveTo(0, -SNAP_SYMBOL_SIZE/(2*scale)); ctx.lineTo(SNAP_SYMBOL_SIZE/(2*scale), SNAP_SYMBOL_SIZE/(2*scale)); ctx.lineTo(-SNAP_SYMBOL_SIZE/(2*scale), SNAP_SYMBOL_SIZE/(2*scale)); ctx.closePath(); break;
                    case 'center': ctx.arc(0, 0, SNAP_SYMBOL_SIZE/(1.5*scale), 0, Math.PI * 2); break;
                    case 'quadrant': const qd=SNAP_SYMBOL_SIZE/(2*scale); ctx.moveTo(0,-qd);ctx.lineTo(qd,0);ctx.lineTo(0,qd);ctx.lineTo(-qd,0);ctx.closePath(); break;
                    case 'intersection': const cs = SNAP_SYMBOL_SIZE/(1.5*scale); ctx.moveTo(-cs,-cs);ctx.lineTo(cs,cs);ctx.moveTo(cs,-cs);ctx.lineTo(-cs,cs); break;
                    case 'tangent': ctx.arc(0,0,SNAP_SYMBOL_SIZE/(2*scale),0,Math.PI*2); ctx.moveTo(0,-SNAP_SYMBOL_SIZE*0.8/scale);ctx.lineTo(0,SNAP_SYMBOL_SIZE*0.8/scale); break;
                    case 'nearest': const hs=SNAP_SYMBOL_SIZE/(2*scale); ctx.moveTo(-hs,-hs);ctx.lineTo(hs,hs); ctx.moveTo(hs,-hs);ctx.lineTo(-hs,hs); ctx.moveTo(-hs,0);ctx.lineTo(hs,0); ctx.moveTo(0,-hs);ctx.lineTo(0,hs); break;
                    case 'grid': ctx.arc(0,0, 2/scale,0,Math.PI*2); ctx.fill(); ctx.restore(); return; 
                }
                ctx.stroke();
                ctx.restore();
            }

            function getMouseWorldPositionWithAids(event) {
                const r = canvas.getBoundingClientRect();
                const sX = event.clientX - r.left; const sY = event.clientY - r.top;
                const rawWp = screenToWorld(sX, sY); 
                let wp = { ...rawWp }; 
                currentSnap = null; 

                let referencePointForDrawing = null; 
                if (drawing || transformState.active) { 
                    if ((currentTool === 'line' || currentTool === 'circle' || currentTool === 'rectangle' || currentTool === 'hexagon' || currentTool === 'star' || currentTool === 'polygon') && startPoint) {
                        referencePointForDrawing = startPoint;
                    } else if (currentTool === 'spline' && currentSplinePoints.length > 0) {
                        referencePointForDrawing = currentSplinePoints[currentSplinePoints.length - 1];
                    } else if (currentTool === 'arc') { 
                        if (definingPoint2) referencePointForDrawing = definingPoint2;
                        else if (startPoint) referencePointForDrawing = startPoint;
                    } else if (currentTool === 'arcCenterStartEnd') { 
                        if (startPoint) referencePointForDrawing = startPoint; 
                        else if (arcCenterPoint) referencePointForDrawing = arcCenterPoint; 
                    } else if (currentTool === 'ellipse') {
                        if (ellipseRadiusXPoint) referencePointForDrawing = ellipseRadiusXPoint; 
                        else if (ellipseCenter) referencePointForDrawing = ellipseCenter; 
                    }
                    else if ((currentTool === 'dimHorizontal' || currentTool === 'dimVertical') && startPoint && !definingPoint2) {
                        referencePointForDrawing = startPoint; 
                    } else if (transformState.active && transformState.center) {
                        referencePointForDrawing = transformState.center;
                    }
                }
                
                const isGeometricDrawingToolActive = ['line', 'circle', 'spline', 'arc', 'arcCenterStartEnd', 'point', 'rectangle', 'ellipse', 'hexagon', 'star', 'polygon'].includes(currentTool);
                const isTransformToolDefiningPoints = (transformState.active && !transformState.dragStartPoint); 

                const isDimToolDefiningFirstOrSecondPoint = drawing && (currentTool === 'dimHorizontal' || currentTool === 'dimVertical') && (!definingPoint2 || !startPoint);

                const shouldActivateObjectSnaps = !transformState.dragStartPoint && 
                    (isGeometricDrawingToolActive || isDimToolDefiningFirstOrSecondPoint || isTransformToolDefiningPoints);


                if (shouldActivateObjectSnaps && !editModeActive && !isDraggingObject) {
                    const potentialSnap = findSnaps(rawWp, referencePointForDrawing);
                    if (potentialSnap) {
                        let allowSnap = true;
                        if (referencePointForDrawing && distance(potentialSnap, referencePointForDrawing) < 1e-6 / scale) {
                             if (potentialSnap.type === 'nearest' && objects.filter(o => !o.isPreview).length < 1) {
                                allowSnap = false;
                             }
                        }
                        if (allowSnap) {
                            currentSnap = potentialSnap;
                            wp = { x: currentSnap.x, y: currentSnap.y };
                        }
                    }
                }
                
                if (!currentSnap) { 
                    const isPlacingDimLine = (currentTool === 'dimHorizontal' || currentTool === 'dimVertical') && startPoint && definingPoint2;
                    const isPlacingDimRadiusText = currentTool === 'dimRadius' && drawing; 
                    
                    if (isDraggingControlPoint || isDraggingObject) { 
                        if (snapToGridEnabled) wp = snapToGrid(rawWp); 
                    } else if (!editModeActive) { 
                        if (!transformState.active && (drawing) && referencePointForDrawing && orthoModeEnabled && (isGeometricDrawingToolActive || isDimToolDefiningFirstOrSecondPoint )) {
                            wp = applyOrthoMode(rawWp, referencePointForDrawing);
                            if (snapToGridEnabled) { 
                                const gridSnappedAfterOrtho = snapToGrid(wp);
                                if(gridSnappedAfterOrtho.x !== wp.x || gridSnappedAfterOrtho.y !== wp.y) {
                                    wp = gridSnappedAfterOrtho;
                                }
                            }
                        } 
                        else if (snapToGridEnabled) {
                            const conditionForGridSnap = 
                                (isGeometricDrawingToolActive && (!startPoint || currentTool === 'spline' || (currentTool === 'arcCenterStartEnd' && !arcCenterPoint && !startPoint) || (currentTool === 'ellipse' && !ellipseCenter && !ellipseRadiusXPoint) )) || 
                                (isGeometricDrawingToolActive && startPoint) || 
                                isPlacingDimLine ||
                                isPlacingDimRadiusText ||
                                isTransformToolDefiningPoints || 
                                ((currentTool === 'dimHorizontal' || currentTool === 'dimVertical') && (!startPoint || !definingPoint2));

                            if (conditionForGridSnap) {
                                const snappedGridWp = snapToGrid(rawWp);
                                if (snappedGridWp.x !== rawWp.x || snappedGridWp.y !== rawWp.y) { 
                                   currentSnap = { type: 'grid', x: snappedGridWp.x, y: snappedGridWp.y, text: 'Rejilla' };
                                   wp = { ...currentSnap };
                                }
                            }
                        }
                    }
                }
                return wp;
            }

            function updateToolStatusAndCursor() {
                let sMsg = `Herramienta: ${currentTool.charAt(0).toUpperCase() + currentTool.slice(1).replace(/_/g, ' ')}`; 
                if (editModeActive && editableObject) {
                    sMsg = `Editando Puntos (ID: ${editableObject.id}, Tipo: ${editableObject.type}). Ctrl+Click para multiselect. Esc para salir.`;
                } else if (transformState.active) { 
                    if (transformState.mode === 'rotate') {
                        sMsg = "Rotar: Arrastre el manejador. Shift para snap. Enter para aplicar, Esc para cancelar.";
                    } else if (transformState.mode === 'scale') {
                        sMsg = "Escalar: Arrastre el manejador. Shift para snap. Enter para aplicar, Esc para cancelar.";
                    }
                } else if (currentTool === 'spline') {
                    let splineStatusText = splineInterpolationSelect.options[splineInterpolationSelect.selectedIndex].text;
                    if (drawing) {
                        if (currentSplineInterpolation === 'bezier') {
                            const numPts = currentSplinePoints.length;
                            if (numPts === 0) splineStatusText += " (Inicio)";
                            else if (numPts === 1) splineStatusText += " (CP1)";
                            else if ((numPts - 1) % 3 === 0 ) splineStatusText += " (Siguiente Pto. Ancla)"; 
                            else if ((numPts - 1) % 3 === 1 ) splineStatusText += " (Control 1)";
                            else if ((numPts - 1) % 3 === 2 ) splineStatusText += " (Control 2)";
                        }
                        sMsg = `Dibujando Spline (${splineStatusText} - ${currentSplinePoints.length} puntos. Enter para finalizar, Esc para cancelar)`;
                    } else { 
                         sMsg = `Herramienta: Spline (${splineStatusText}). Click para iniciar.`;
                    }
                } else if (currentTool === 'arc') { 
                    if (!drawing) sMsg = `Herramienta: Arco (3P). Defina punto inicial.`
                    else if (!definingPoint2) sMsg = `Arco (3P): Defina punto intermedio (Esc para cancelar)`;
                    else sMsg = `Arco (3P): Defina punto final (Esc para cancelar)`;
                } else if (currentTool === 'point') {
                    sMsg = "Herramienta: Punto. Click para crear un punto.";
                } else if (currentTool === 'rectangle') {
                    if (drawing) sMsg = "Dibujando Rectángulo: Defina esquina opuesta (Esc para cancelar)";
                    else sMsg = "Herramienta: Rectángulo. Defina primera esquina.";
                } else if (currentTool === 'arcCenterStartEnd') { 
                    if (!arcCenterPoint) sMsg = "Arco (C,I,F): Defina el CENTRO";
                    else if (!startPoint) sMsg = `Arco (C,I,F): Centro en (${arcCenterPoint.x.toFixed(1)}, ${arcCenterPoint.y.toFixed(1)}). Defina PUNTO INICIAL`;
                    else sMsg = `Arco (C,I,F): Centro en (${arcCenterPoint.x.toFixed(1)}, ${arcCenterPoint.y.toFixed(1)}), Inicio en (${startPoint.x.toFixed(1)}, ${startPoint.y.toFixed(1)}). Defina PUNTO FINAL (Ctrl para invertir dirección)`;
                } else if (currentTool === 'ellipse') {
                    if (!ellipseCenter) sMsg = "Elipse: Defina el CENTRO.";
                    else if (!ellipseRadiusXPoint) sMsg = `Elipse: Centro en (${ellipseCenter.x.toFixed(1)}, ${ellipseCenter.y.toFixed(1)}). Defina radio en EJE X.`;
                    else sMsg = `Elipse: Centro en (${ellipseCenter.x.toFixed(1)}, ${ellipseCenter.y.toFixed(1)}), Radio X definido. Defina radio en EJE Y.`;
                } else if (currentTool === 'hexagon' || (currentTool === 'polygon' && starNumPoints === 6)) { 
                    if (!startPoint) sMsg = "Hexágono: Defina el CENTRO.";
                    else sMsg = `Hexágono: Centro en (${startPoint.x.toFixed(1)}, ${startPoint.y.toFixed(1)}). Defina un VÉRTICE (radio).`;
                } else if (currentTool === 'star' || (currentTool === 'polygon' && starNumPoints !== 6)) { 
                    if (!startPoint) sMsg = `Estrella (${starNumPoints} puntas): Defina el CENTRO.`;
                    else sMsg = `Estrella (${starNumPoints} puntas): Centro en (${startPoint.x.toFixed(1)}, ${startPoint.y.toFixed(1)}). Defina RADIO EXTERIOR (punta).`;
                } else if (currentTool === 'offset') {
                    sMsg = `Equidistancia (Seleccione objeto. Lado: ${offsetSide === "left" ? "Izquierdo" : offsetSide === "right" ? "Derecho" : "Ambos"})`;
                    if (objectToOffset) {
                        sMsg = `Equidistancia (ID: ${objectToOffset.id}. Click para aplicar o Enter. Lado: ${offsetSide === "left" ? "Izquierdo" : offsetSide === "right" ? "Derecho" : "Ambos"})`;
                    }
                } else if (currentTool === 'trim') {
                    sMsg = "Recortar - ";
                    if (trimState.phase === 0 || trimState.phase === 1) sMsg += `Seleccione ${trimState.boundaries.length > 0 ? trimState.boundaries.length : ''} objetos límite (Enter para confirmar)`;
                    else if (trimState.phase === 2) sMsg += "Seleccione objeto a recortar";
                    else if (trimState.phase === 3) sMsg += "Haga clic en la parte a eliminar";
                } else if (currentTool === 'extend') {
                     if (!extendState.objectToExtendId) {
                        sMsg = "Alargar: Seleccione línea a alargar (cerca del extremo)";
                    } else if (!extendState.boundaryId && extendState.previewPoint) { 
                        sMsg = `Alargar (ID: ${extendState.objectToExtendId}): Seleccione objeto límite o Click/Enter para alargar al más cercano`;
                    } else if (extendState.boundaryId && extendState.previewPoint) { 
                         sMsg = `Alargar (ID: ${extendState.objectToExtendId}): Click para alargar al límite (ID: ${extendState.boundaryId})`;
                    }
                     else if (!extendState.previewPoint && extendState.objectToExtendId) { 
                        sMsg = `Alargar (ID: ${extendState.objectToExtendId}): No hay límite de extensión. Seleccione objeto límite o Esc.`;
                    }
                } else if (currentTool === 'dimHorizontal') {
                    if (!drawing) sMsg = "Cota Horizontal: Defina primer punto (snap a objeto)";
                    else if (!definingPoint2) sMsg = "Cota Horizontal: Defina segundo punto (snap a objeto)";
                    else sMsg = "Cota Horizontal: Defina posición de línea de cota (snap a rejilla opcional)";
                } else if (currentTool === 'dimVertical') {
                    if (!drawing) sMsg = "Cota Vertical: Defina primer punto (snap a objeto)";
                    else if (!definingPoint2) sMsg = "Cota Vertical: Defina segundo punto (snap a objeto)";
                    else sMsg = "Cota Vertical: Defina posición de línea de cota (snap a rejilla opcional)";
                } else if (currentTool === 'dimRadius') {
                    const selCircle = getSelectedCircleForRadiusDim();
                    if (!selCircle) sMsg = "Cota Radio: Primero seleccione un círculo, luego active esta herramienta.";
                    else {
                        sMsg = `Cota Radio (para círculo ID: ${selCircle.id}): Defina posición del texto/directriz.`;
                        if(!drawing) drawing = true; 
                    }
                }
                toolStatusDiv.textContent = sMsg;

                document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active', 'edit-mode-active'));
                snapGridBtn.classList.toggle('active', snapToGridEnabled); 
                orthoModeBtn.classList.toggle('active', orthoModeEnabled);

                if(currentTool.startsWith('edit_points_active')) { 
                    if(editPointsBtn) editPointsBtn.classList.add('edit-mode-active');
                } else {
                    let currentBtnId = currentTool + 'ToolBtn';
                    if (currentTool === 'polygon' && starNumPoints === 6) currentBtnId = 'polygonToolBtn';
                    else if (currentTool === 'polygon' && starNumPoints !== 6) currentBtnId = 'starToolBtn'; // If polygon implies star
                    else if (currentTool === 'star') currentBtnId = 'starToolBtn'; // Explicit star tool
                    
                    const currentBtn = document.getElementById(currentBtnId);
                    if (currentBtn) {
                        currentBtn.classList.add('active');
                        const group = currentBtn.closest('.tool-group');
                        if (group) { group.querySelectorAll('.tool-btn').forEach(b => { if (b !== currentBtn) b.classList.remove('active'); }); }
                    }
                }

                const singleEditableObjSelected = selectedObjectIds.length === 1 && objects.find(obj => obj.id === selectedObjectIds[0] && ['line', 'circle', 'spline', 'point', 'rectangle', 'arc', 'arcCenterStartEnd', 'ellipse', 'hexagon', 'star'].includes(obj.type));
                if (editModeActive && editableObject) {
                    if(editPointsBtn) { editPointsBtn.style.display = 'flex'; editPointsBtn.disabled = false; editPointsBtn.classList.add('edit-mode-active'); editPointsBtn.title = "Finalizar Edición"; }
                } else if (singleEditableObjSelected && currentTool === 'select') {
                     if(editPointsBtn) { editPointsBtn.style.display = 'flex'; editPointsBtn.disabled = false; editPointsBtn.title = "Editar Geometría"; }
                } else {
                    if(editPointsBtn) editPointsBtn.style.display = 'none';
                    if (editModeActive) exitEditMode(); 
                }

                if (currentTool === 'spline' && !editModeActive) showFloatingPanel(splineOptionsPanel, splineToolBtn); else hideFloatingPanel(splineOptionsPanel);
                if (currentTool === 'offset' && !editModeActive) showFloatingPanel(offsetOptionsPanel, offsetToolBtn); else hideFloatingPanel(offsetOptionsPanel);

                if (isPanning || (isDraggingObject && !editModeActive) || (isDraggingControlPoint && editModeActive) || (transformState.active && transformState.dragStartPoint)) { canvas.style.cursor = 'grabbing';
                } else if (editModeActive) { canvas.style.cursor = 'default'; 
                } else if (transformState.active) { canvas.style.cursor = 'default'; 
                } else if (currentTool === 'select') { canvas.style.cursor = 'default';
                } else if (['line', 'circle', 'arc', 'arcCenterStartEnd', 'spline', 'point', 'rectangle', 'ellipse', 'hexagon', 'star', 'polygon', 'offset', 'trim', 'extend', 'dimHorizontal', 'dimVertical', 'dimRadius'].includes(currentTool)) { canvas.style.cursor = 'crosshair';
                } else { canvas.style.cursor = 'default'; }
            }
            
            function drawSplinePath(pathPoints, interpolationType) { 
                if (!pathPoints || pathPoints.length === 0) return;
                ctx.moveTo(pathPoints[0].x, pathPoints[0].y);
                if (interpolationType === 'linear') { if (pathPoints.length < 2) return; for (let i = 1; i < pathPoints.length; i++) ctx.lineTo(pathPoints[i].x, pathPoints[i].y);
                } else if (interpolationType === 'cardinal' || interpolationType === 'catmull-rom') { 
                    if (pathPoints.length < 2) return; if (pathPoints.length === 2) { ctx.lineTo(pathPoints[1].x, pathPoints[1].y); return; } 
                    for (let i = 0; i < pathPoints.length - 1; i++) { const p0 = (i === 0) ? pathPoints[i] : pathPoints[i - 1]; const p1 = pathPoints[i]; const p2 = pathPoints[i + 1]; const p3 = (i === pathPoints.length - 2) ? pathPoints[i + 1] : pathPoints[i + 2]; const cp1x = p1.x + (p2.x - p0.x) / 6; const cp1y = p1.y + (p2.y - p0.y) / 6; const cp2x = p2.x - (p3.x - p1.x) / 6; const cp2y = p2.y - (p3.y - p1.y) / 6; ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, p2.x, p2.y); }
                } else if (interpolationType === 'bezier') {
                    if (pathPoints.length < 4 || (pathPoints.length - 1) % 3 !== 0) { for (let i = 1; i < pathPoints.length; i++) ctx.lineTo(pathPoints[i].x, pathPoints[i].y); return; }
                    for (let i = 0; i < pathPoints.length - 1; i += 3) { if (pathPoints[i+3]) { ctx.bezierCurveTo(pathPoints[i+1].x, pathPoints[i+1].y, pathPoints[i+2].x, pathPoints[i+2].y, pathPoints[i+3].x, pathPoints[i+3].y); } else { for (let j = i + 1; j < pathPoints.length; j++) ctx.lineTo(pathPoints[j].x, pathPoints[j].y); break; } }
                }
            }
            function drawAllObjects() {
                const selectedObjectColor = getComputedStyle(document.documentElement).getPropertyValue('--cad-selection-color').trim(); 
                const editingObjectColor = getComputedStyle(document.documentElement).getPropertyValue('--cad-edit-mode-color').trim(); 
                
                objects.forEach(obj => {
                    if (!isObjectVisible(obj)) return; 

                    const defaultObjectColor = getObjectLayerColor(obj); 

                    const isSelGeneral = selectedObjectIds.includes(obj.id) && !editModeActive && !transformState.active && currentTool !== 'offset' && currentTool !== 'trim' && currentTool !== 'extend';
                    const isBeingEdited = editModeActive && editableObject && obj.id === editableObject.id;
                    const isBeingOffset = currentTool === 'offset' && objectToOffset && obj.id === objectToOffset.id;
                    const isTrimBoundary = currentTool === 'trim' && (trimState.phase === 0 || trimState.phase === 1) && trimState.boundaries.includes(obj.id);
                    const isObjectToTrim = currentTool === 'trim' && (trimState.phase === 2 || trimState.phase === 3) && trimState.objectToTrimId === obj.id;
                    const isObjectToExtend = currentTool === 'extend' && extendState.objectToExtendId === obj.id;
                    const isExtendBoundaryHovered = currentTool === 'extend' && extendState.objectToExtendId && !extendState.boundaryId && extendState.possibleExtensions.length > 0 && extendState.possibleExtensions[0].boundaryId === obj.id;
                    const isExtendBoundarySelected = currentTool === 'extend' && extendState.boundaryId === obj.id;
                    const isSelectedForRadiusDim = currentTool === 'dimRadius' && getSelectedCircleForRadiusDim()?.id === obj.id;
                    const isSelectedForTransform = transformState.active && transformState.objectsToTransform.includes(obj.id); 

                    ctx.beginPath(); let lW = 2; let sS = defaultObjectColor;
                    if (isBeingEdited) { lW = 2.5; sS = editingObjectColor; } 
                    else if (isBeingOffset) { lW = 3; sS = getComputedStyle(document.documentElement).getPropertyValue('--accent-hover').trim(); } 
                    else if (isTrimBoundary) { lW = 3; sS = getComputedStyle(document.documentElement).getPropertyValue('--primary-hover').trim(); } 
                    else if (isObjectToTrim) { lW = 3; sS = getComputedStyle(document.documentElement).getPropertyValue('--danger').trim(); } 
                    else if (isObjectToExtend) { lW = 3; sS = getComputedStyle(document.documentElement).getPropertyValue('--accent').trim(); } 
                    else if (isExtendBoundarySelected) {lW = 3; sS = getComputedStyle(document.documentElement).getPropertyValue('--primary').trim(); } 
                    else if (isExtendBoundaryHovered) {lW = 2.5; sS = getComputedStyle(document.documentElement).getPropertyValue('--primary-focus').trim();} 
                    else if (isSelectedForRadiusDim) { lW = 3; sS = getComputedStyle(document.documentElement).getPropertyValue('--cad-dimension-selected-color').trim(); } 
                    else if (isSelectedForTransform) { lW = 3; sS = getComputedStyle(document.documentElement).getPropertyValue('--accent').trim(); } 
                    else if (isSelGeneral) { lW = 3; sS = selectedObjectColor; } 

                    ctx.lineWidth = lW / scale; ctx.strokeStyle = sS;
                     if (obj.type === 'line') { ctx.moveTo(obj.startX, obj.startY); ctx.lineTo(obj.endX, obj.endY); }
                    else if (obj.type === 'circle') { ctx.arc(obj.centerX, obj.centerY, obj.radius, 0, Math.PI * 2); }
                    else if (obj.type === 'arc') { ctx.arc(obj.centerX, obj.centerY, obj.radius, obj.startAngle, obj.endAngle, !obj.clockwise); } 
                    else if (obj.type === 'arcCenterStartEnd') { ctx.arc(obj.centerX, obj.centerY, obj.radius, obj.startAngle, obj.endAngle, obj.counterClockwise); } 
                    else if (obj.type === 'spline') { drawSplinePath(obj.points, obj.interpolationType); }
                    else if (obj.type === 'point') { const pointRadius = Math.max(1.5, 3 / scale); ctx.arc(obj.x, obj.y, pointRadius, 0, Math.PI * 2); ctx.fillStyle = sS; ctx.fill(); } 
                    else if (obj.type === 'rectangle') { ctx.rect(obj.x, obj.y, obj.width, obj.height); } 
                    else if (obj.type === 'ellipse') { ctx.ellipse(obj.centerX, obj.centerY, obj.radiusX, obj.radiusY, obj.rotation || 0, 0, 2 * Math.PI); } 
                    else if (obj.type === 'hexagon' || obj.type === 'star') {
                        if (obj.points && obj.points.length > 1) {
                            ctx.moveTo(obj.points[0].x, obj.points[0].y);
                            for (let i = 1; i < obj.points.length; i++) ctx.lineTo(obj.points[i].x, obj.points[i].y);
                            ctx.closePath();
                        }
                    }
                    if (obj.type !== 'point') { ctx.stroke(); }
                    if (isObjectToExtend && extendState.whichEnd) { ctx.beginPath(); ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--danger'); const endToMark = extendState.whichEnd === 'start' ? {x: obj.startX, y: obj.startY} : {x: obj.endX, y: obj.endY}; ctx.arc(endToMark.x, endToMark.y, Math.max(3, CONTROL_POINT_RADIUS_SCREEN) / scale, 0, Math.PI * 2); ctx.fill(); }
                });
                if (currentTool === 'trim' && trimState.phase >= 2 && trimState.objectToTrimId) {
                    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--danger'); 
                    trimState.intersections.forEach(p => { ctx.beginPath(); ctx.arc(p.x, p.y, 4 / scale, 0, Math.PI * 2); ctx.fill(); });
                    if (trimState.previewSegment) { ctx.beginPath(); ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent'); ctx.lineWidth = 3 / scale; ctx.setLineDash([3/scale, 3/scale]); if (trimState.previewSegment.type === 'line') { ctx.moveTo(trimState.previewSegment.startX, trimState.previewSegment.startY); ctx.lineTo(trimState.previewSegment.endX, trimState.previewSegment.endY); } ctx.stroke(); ctx.setLineDash([]); }
                }
            }
            function drawArrow(context, x, y, angle, size) { 
                context.save(); context.translate(x, y); context.rotate(angle);
                context.beginPath(); context.moveTo(0, 0); context.lineTo(-size, -size / 2.5); 
                context.lineTo(-size * 0.75, 0); context.lineTo(-size, size / 2.5);
                context.closePath(); context.fill(); context.restore();
            }
            function drawAllDimensions() { 
                const dimTxtSize = DIM_TEXT_SIZE_SCREEN / scale;
                const dimArrowSize = DIM_ARROW_SIZE_SCREEN / scale;
                const extLineGap = DIM_EXT_LINE_GAP_SCREEN / scale; 
                const extLineOvershoot = DIM_EXT_LINE_OVERSHOOT_SCREEN / scale; 
                const textOffsetFromDimLine = DIM_OFFSET_FROM_LINE_SCREEN / scale;
                const defaultDimColor = getComputedStyle(document.documentElement).getPropertyValue(DIM_COLOR_VAR);
                const selectedDimColor = getComputedStyle(document.documentElement).getPropertyValue(DIM_SELECTED_COLOR_VAR);

                dimensions.forEach(dim => {
                    const isSelected = selectedDimensionIds.includes(dim.id);
                    ctx.strokeStyle = isSelected ? selectedDimColor : defaultDimColor;
                    ctx.fillStyle = isSelected ? selectedDimColor : defaultDimColor; 
                    ctx.lineWidth = (isSelected ? 1.5 : 1) / scale;
                    ctx.font = `bold ${dimTxtSize}px Arial`;
                    
                    if (dim.type === 'dimHorizontal') { 
                        ctx.textAlign = 'center'; ctx.textBaseline = 'bottom'; 
                        ctx.beginPath();
                        ctx.moveTo(dim.p1.x, dim.p1.y - Math.sign(dim.p1.y - dim.offsetY) * extLineGap); ctx.lineTo(dim.p1.x, dim.offsetY + Math.sign(dim.p1.y - dim.offsetY) * extLineOvershoot);
                        ctx.moveTo(dim.p2.x, dim.p2.y - Math.sign(dim.p2.y - dim.offsetY) * extLineGap); ctx.lineTo(dim.p2.x, dim.offsetY + Math.sign(dim.p2.y - dim.offsetY) * extLineOvershoot);
                        ctx.stroke(); ctx.beginPath();
                        ctx.moveTo(dim.p1.x, dim.offsetY); ctx.lineTo(dim.p2.x, dim.offsetY);
                        ctx.stroke();
                        drawArrow(ctx, dim.p1.x, dim.offsetY, Math.atan2(0, dim.p2.x - dim.p1.x), dimArrowSize); 
                        drawArrow(ctx, dim.p2.x, dim.offsetY, Math.atan2(0, dim.p1.x - dim.p2.x), dimArrowSize); 
                        ctx.fillText(dim.value.toFixed(1), (dim.p1.x + dim.p2.x) / 2, dim.offsetY - textOffsetFromDimLine);
                    } 
                    else if (dim.type === 'dimVertical') { 
                        ctx.textBaseline = 'middle'; 
                        ctx.beginPath();
                        ctx.moveTo(dim.p1.x - Math.sign(dim.p1.x - dim.offsetX) * extLineGap, dim.p1.y); ctx.lineTo(dim.offsetX + Math.sign(dim.p1.x - dim.offsetX) * extLineOvershoot, dim.p1.y);
                        ctx.moveTo(dim.p2.x - Math.sign(dim.p2.x - dim.offsetX) * extLineGap, dim.p2.y); ctx.lineTo(dim.offsetX + Math.sign(dim.p2.x - dim.offsetX) * extLineOvershoot, dim.p2.y);
                        ctx.stroke(); ctx.beginPath();
                        ctx.moveTo(dim.offsetX, dim.p1.y); ctx.lineTo(dim.offsetX, dim.p2.y);
                        ctx.stroke();
                        drawArrow(ctx, dim.offsetX, dim.p1.y, Math.atan2(dim.p2.y - dim.p1.y, 0), dimArrowSize); 
                        drawArrow(ctx, dim.offsetX, dim.p2.y, Math.atan2(dim.p1.y - dim.p2.y, 0), dimArrowSize); 
                        ctx.save();
                        const textX = dim.offsetX - textOffsetFromDimLine * (Math.sign(dim.p1.x - dim.offsetX) || 1); 
                        ctx.textAlign = (Math.sign(dim.p1.x - dim.offsetX) || 1) > 0 ? 'right' : 'left'; 
                        ctx.translate(textX, (dim.p1.y + dim.p2.y) / 2); ctx.rotate(-Math.PI / 2);
                        ctx.textAlign = 'center'; ctx.fillText(dim.value.toFixed(1), 0, 0);
                        ctx.restore();
                    }
                    else if (dim.type === 'dimRadius') { 
                        ctx.textAlign = 'left'; ctx.textBaseline = 'middle';
                        ctx.beginPath(); ctx.moveTo(dim.center.x, dim.center.y); ctx.lineTo(dim.pointOnCircle.x, dim.pointOnCircle.y);
                        let textDisplayX = dim.textPos.x; let textDisplayY = dim.textPos.y;
                        if(dim.hasExtension) { ctx.lineTo(dim.textPos.x, dim.textPos.y); }
                        ctx.stroke();
                        const angleToPoint = Math.atan2(dim.pointOnCircle.y - dim.center.y, dim.pointOnCircle.x - dim.center.x);
                        drawArrow(ctx, dim.pointOnCircle.x, dim.pointOnCircle.y, angleToPoint + Math.PI, dimArrowSize); 
                        if (!dim.hasExtension) {
                             const textOffsetFromCirc = dimArrowSize + textOffsetFromDimLine;
                             textDisplayX = dim.pointOnCircle.x + textOffsetFromCirc * Math.cos(angleToPoint);
                             textDisplayY = dim.pointOnCircle.y + textOffsetFromCirc * Math.sin(angleToPoint);
                             const cosAngle = Math.cos(angleToPoint); const sinAngle = Math.sin(angleToPoint);
                             if (cosAngle < -0.1) ctx.textAlign = 'right'; else if (cosAngle > 0.1) ctx.textAlign = 'left'; else ctx.textAlign = 'center';
                             if (sinAngle < -0.707) ctx.textBaseline = 'top'; else if (sinAngle > 0.707) ctx.textBaseline = 'bottom'; else ctx.textBaseline = 'middle';
                        } else { 
                            const dxTextLeader = dim.textPos.x - dim.pointOnCircle.x;
                            if (Math.abs(dxTextLeader) < dimTxtSize * 0.2) ctx.textAlign = 'center'; 
                            else if (dxTextLeader > 0) ctx.textAlign = 'left'; 
                            else ctx.textAlign = 'right'; 
                        }
                        ctx.fillText(`R${dim.value.toFixed(1)}`, textDisplayX, textDisplayY);
                    }
                });
            }
            
            function drawPreview() { 
                if (transformState.active || currentTool === 'offset' || currentTool === 'trim' || currentTool === 'extend' || editModeActive ) return;
                 if (!drawing && currentTool !== 'point' && !(currentTool === 'arcCenterStartEnd' && arcCenterPoint) && !(currentTool === 'ellipse' && ellipseCenter) && currentTool !== 'spline' && currentTool !== 'hexagon' && currentTool !== 'star' && currentTool !== 'polygon' ) return;
                if (currentTool !== 'spline' && currentTool !== 'point' && !(currentTool === 'arcCenterStartEnd' && arcCenterPoint) && !(currentTool === 'ellipse' && ellipseCenter) && !startPoint && currentSplinePoints.length === 0) return;

                const previewColor = getComputedStyle(document.documentElement).getPropertyValue('--cad-selection-color'); 
                ctx.strokeStyle = previewColor;
                ctx.lineWidth = 1 / scale; ctx.setLineDash([5 / scale, 5 / scale]); ctx.beginPath();
                if (currentTool === 'line' && startPoint) { ctx.moveTo(startPoint.x, startPoint.y); ctx.lineTo(mousePosWorld.x, mousePosWorld.y);
                } else if (currentTool === 'circle' && startPoint) { const radius = distance(startPoint, mousePosWorld); ctx.arc(startPoint.x, startPoint.y, radius, 0, Math.PI * 2);
                } else if (currentTool === 'arc' && startPoint) { 
                    if (startPoint && !definingPoint2) { ctx.moveTo(startPoint.x, startPoint.y); ctx.lineTo(mousePosWorld.x, mousePosWorld.y); ctx.stroke(); ctx.beginPath(); ctx.arc(startPoint.x, startPoint.y, 2 / scale, 0, Math.PI * 2); ctx.fillStyle = previewColor; ctx.fill(); 
                    } else if (startPoint && definingPoint2) { 
                        const arcParams = calculateArcParameters(startPoint, definingPoint2, mousePosWorld);
                        if (arcParams) { ctx.arc(arcParams.centerX, arcParams.centerY, arcParams.radius, arcParams.startAngle, arcParams.endAngle, !arcParams.clockwise); 
                        } else { ctx.moveTo(startPoint.x, startPoint.y); ctx.lineTo(definingPoint2.x, definingPoint2.y); ctx.lineTo(mousePosWorld.x, mousePosWorld.y); }
                        ctx.stroke(); ctx.beginPath(); ctx.arc(startPoint.x, startPoint.y, 2 / scale, 0, Math.PI * 2); ctx.arc(definingPoint2.x, definingPoint2.y, 2 / scale, 0, Math.PI * 2); ctx.fillStyle = previewColor; ctx.fill(); 
                    }
                } else if (currentTool === 'point' && mousePosWorld) { ctx.arc(mousePosWorld.x, mousePosWorld.y, 3 / scale, 0, Math.PI * 2); ctx.fillStyle = previewColor; ctx.fill();
                } else if (currentTool === 'rectangle' && startPoint && mousePosWorld) { ctx.rect(startPoint.x, startPoint.y, mousePosWorld.x - startPoint.x, mousePosWorld.y - startPoint.y);
                } else if (currentTool === 'arcCenterStartEnd') { 
                    if (arcCenterPoint && !startPoint && mousePosWorld) { ctx.moveTo(arcCenterPoint.x, arcCenterPoint.y); ctx.lineTo(mousePosWorld.x, mousePosWorld.y); ctx.stroke(); ctx.beginPath(); ctx.arc(mousePosWorld.x, mousePosWorld.y, 2 / scale, 0, Math.PI * 2); ctx.fillStyle = previewColor; ctx.fill();
                    } else if (arcCenterPoint && startPoint && mousePosWorld) { 
                        const radius = distance(arcCenterPoint, startPoint);
                        if (radius > 1e-6 / scale) { let sAngle = Math.atan2(startPoint.y - arcCenterPoint.y, startPoint.x - arcCenterPoint.x); let eAngle = Math.atan2(mousePosWorld.y - arcCenterPoint.y, mousePosWorld.x - arcCenterPoint.x); ctx.arc(arcCenterPoint.x, arcCenterPoint.y, radius, sAngle, eAngle, false); }
                    }
                    if (arcCenterPoint) { ctx.stroke(); ctx.beginPath(); ctx.arc(arcCenterPoint.x, arcCenterPoint.y, 2 / scale, 0, Math.PI * 2); ctx.fillStyle = '#ff00ff'; ctx.fill(); } 
                    if (startPoint) { ctx.stroke(); ctx.beginPath(); ctx.arc(startPoint.x, startPoint.y, 2 / scale, 0, Math.PI * 2); ctx.fillStyle = '#00ff00'; ctx.fill(); }
                } else if (currentTool === 'ellipse') {
                    if (ellipseCenter && !ellipseRadiusXPoint && mousePosWorld) { ctx.moveTo(ellipseCenter.x, ellipseCenter.y); ctx.lineTo(mousePosWorld.x, ellipseCenter.y); ctx.stroke(); ctx.beginPath(); ctx.arc(ellipseCenter.x, ellipseCenter.y, 2 / scale, 0, Math.PI * 2); ctx.fillStyle = previewColor; ctx.fill();
                    } else if (ellipseCenter && ellipseRadiusXPoint && mousePosWorld) { 
                        const radiusX = Math.abs(ellipseRadiusXPoint.x - ellipseCenter.x); const radiusY = Math.abs(mousePosWorld.y - ellipseCenter.y); 
                        if (radiusX > 1e-6 / scale && radiusY > 1e-6 / scale) { ctx.ellipse(ellipseCenter.x, ellipseCenter.y, radiusX, radiusY, 0, 0, 2 * Math.PI); }
                        ctx.stroke(); ctx.beginPath(); ctx.arc(ellipseCenter.x, ellipseCenter.y, 2 / scale, 0, Math.PI * 2); ctx.fillStyle = '#ff00ff'; ctx.fill(); 
                        ctx.beginPath(); ctx.arc(ellipseRadiusXPoint.x, ellipseCenter.y, 2 / scale, 0, Math.PI * 2); ctx.fillStyle = '#00ff00'; ctx.fill(); 
                    } else if (ellipseCenter) { ctx.beginPath(); ctx.arc(ellipseCenter.x, ellipseCenter.y, 2 / scale, 0, Math.PI * 2); ctx.fillStyle = previewColor; ctx.fill(); }
                } else if ((currentTool === 'hexagon' || (currentTool === 'polygon' && starNumPoints === 6)) && startPoint && mousePosWorld) { 
                    const radius = distance(startPoint, mousePosWorld);
                    if (radius > 1e-6 / scale) {
                        const initialAngle = Math.atan2(mousePosWorld.y - startPoint.y, mousePosWorld.x - startPoint.x);
                        for (let i = 0; i < 6; i++) { const angle = (Math.PI / 3) * i + initialAngle; const x = startPoint.x + radius * Math.cos(angle); const y = startPoint.y + radius * Math.sin(angle); if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y); }
                        ctx.closePath();
                    }
                    ctx.stroke(); ctx.beginPath(); ctx.arc(startPoint.x, startPoint.y, 2 / scale, 0, Math.PI * 2); ctx.fillStyle = previewColor; ctx.fill();
                } else if ((currentTool === 'star' || (currentTool === 'polygon' && starNumPoints !== 6)) && startPoint && mousePosWorld) { 
                    const outerRadius = distance(startPoint, mousePosWorld);
                    if (outerRadius > 1e-6 / scale) {
                        const innerRadius = outerRadius * starInnerRadiusFactor; const angleStep = Math.PI / starNumPoints;
                        let rotation = Math.atan2(mousePosWorld.y - startPoint.y, mousePosWorld.x - startPoint.x); 
                        ctx.moveTo(startPoint.x + outerRadius * Math.cos(rotation), startPoint.y + outerRadius * Math.sin(rotation) );
                        for (let i = 0; i < starNumPoints * 2; i++) { rotation += angleStep; const currentRadius = (i % 2 === 0) ? outerRadius : innerRadius; ctx.lineTo( startPoint.x + currentRadius * Math.cos(rotation), startPoint.y + currentRadius * Math.sin(rotation) ); }
                        ctx.closePath();
                    }
                    ctx.stroke(); ctx.beginPath(); ctx.arc(startPoint.x, startPoint.y, 2 / scale, 0, Math.PI * 2); ctx.fillStyle = previewColor; ctx.fill();
                } else if (currentTool === 'spline') {
                    if (currentSplinePoints.length === 0) { if (mousePosWorld) { ctx.arc(mousePosWorld.x, mousePosWorld.y, 2 / scale, 0, Math.PI * 2); }
                    } else { const previewPoints = [...currentSplinePoints, mousePosWorld]; if (currentSplineInterpolation === 'bezier') { ctx.moveTo(currentSplinePoints[0].x, currentSplinePoints[0].y); for (let i = 1; i < currentSplinePoints.length; i++) ctx.lineTo(currentSplinePoints[i].x, currentSplinePoints[i].y); if (mousePosWorld) ctx.lineTo(mousePosWorld.x, mousePosWorld.y); } else { drawSplinePath(previewPoints, currentSplineInterpolation); } }
                } else if (currentTool === 'dimHorizontal' && startPoint) { 
                    if (!definingPoint2) { ctx.moveTo(startPoint.x, startPoint.y); ctx.lineTo(mousePosWorld.x, mousePosWorld.y); ctx.stroke(); ctx.beginPath(); ctx.arc(startPoint.x, startPoint.y, 2/scale, 0, Math.PI*2); ctx.fillStyle = previewColor; ctx.fill();
                    } else { 
                        const yOffset = mousePosWorld.y; const extLineGap = DIM_EXT_LINE_GAP_SCREEN / scale; const extLineOvershoot = DIM_EXT_LINE_OVERSHOOT_SCREEN / scale;
                        ctx.moveTo(startPoint.x, startPoint.y - Math.sign(startPoint.y - yOffset) * extLineGap); ctx.lineTo(startPoint.x, yOffset + Math.sign(startPoint.y - yOffset) * extLineOvershoot);
                        ctx.moveTo(definingPoint2.x, definingPoint2.y - Math.sign(definingPoint2.y - yOffset) * extLineGap); ctx.lineTo(definingPoint2.x, yOffset + Math.sign(definingPoint2.y - yOffset) * extLineOvershoot);
                        ctx.moveTo(startPoint.x, yOffset); ctx.lineTo(definingPoint2.x, yOffset);
                    }
                }
                else if (currentTool === 'dimVertical' && startPoint) { 
                     if (!definingPoint2) { ctx.moveTo(startPoint.x, startPoint.y); ctx.lineTo(mousePosWorld.x, mousePosWorld.y); ctx.stroke(); ctx.beginPath(); ctx.arc(startPoint.x, startPoint.y, 2/scale, 0, Math.PI*2); ctx.fillStyle = previewColor; ctx.fill();
                    } else { 
                        const xOffset = mousePosWorld.x; const extLineGap = DIM_EXT_LINE_GAP_SCREEN / scale; const extLineOvershoot = DIM_EXT_LINE_OVERSHOOT_SCREEN / scale;
                        ctx.moveTo(startPoint.x - Math.sign(startPoint.x - xOffset) * extLineGap, startPoint.y); ctx.lineTo(xOffset + Math.sign(startPoint.x - xOffset) * extLineOvershoot, startPoint.y);
                        ctx.moveTo(definingPoint2.x - Math.sign(definingPoint2.x - xOffset) * extLineGap, definingPoint2.y); ctx.lineTo(xOffset + Math.sign(definingPoint2.x - xOffset) * extLineOvershoot, definingPoint2.y);
                        ctx.moveTo(xOffset, startPoint.y); ctx.lineTo(xOffset, definingPoint2.y);
                    }
                }
                else if (currentTool === 'dimRadius') { 
                    const circle = getSelectedCircleForRadiusDim();
                    if (circle) {
                        const dxMouse = mousePosWorld.x - circle.centerX; const dyMouse = mousePosWorld.y - circle.centerY; const distMouse = Math.hypot(dxMouse, dyMouse);
                        if (distMouse > 1e-6) { 
                            const leaderEndX = circle.centerX + (dxMouse / distMouse) * circle.radius; const leaderEndY = circle.centerY + (dyMouse / distMouse) * circle.radius;
                            ctx.moveTo(circle.centerX, circle.centerY); ctx.lineTo(leaderEndX, leaderEndY);
                            const textPreviewDistThreshold = circle.radius * 0.1; 
                            if (Math.hypot(mousePosWorld.x - leaderEndX, mousePosWorld.y - leaderEndY) > textPreviewDistThreshold) { ctx.lineTo(mousePosWorld.x, mousePosWorld.y); }
                        }
                    }
                }
                if (currentTool !== 'point' && !(currentTool === 'arc' && startPoint && !definingPoint2) && !(currentTool === 'arcCenterStartEnd' && arcCenterPoint) && !(currentTool === 'ellipse' && ellipseCenter)) { ctx.stroke(); }
                ctx.setLineDash([]);
            }
            function drawOffsetPreviewInternal() { 
                if (currentTool !== 'offset' || !objectToOffset || offsetPreviewObjects.length === 0) return;
                ctx.save(); ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent'); ctx.lineWidth = 1.5 / scale; 
                ctx.setLineDash([4 / scale, 4 / scale]);
                offsetPreviewObjects.forEach(previewObj => {
                    if (!previewObj) return; ctx.beginPath();
                    if (previewObj.type === "line") { ctx.moveTo(previewObj.startX, previewObj.startY); ctx.lineTo(previewObj.endX, previewObj.endY); }
                    else if (previewObj.type === "circle") { ctx.arc(previewObj.centerX, previewObj.centerY, previewObj.radius, 0, Math.PI * 2); }
                     else if (previewObj.type === "arc" || previewObj.type === "arcCenterStartEnd") { ctx.arc(previewObj.centerX, previewObj.centerY, previewObj.radius, previewObj.startAngle, previewObj.endAngle, previewObj.type === 'arc' ? !previewObj.clockwise : previewObj.counterClockwise); }
                    ctx.stroke();
                });
                ctx.setLineDash([]); ctx.restore();
            }
            function drawExtendPreview() { 
                 if (currentTool !== 'extend' || !extendState.objectToExtendId || !extendState.previewPoint) return;
                const obj = objects.find(o => o.id === extendState.objectToExtendId);
                if (obj && obj.type === 'line') {
                    ctx.beginPath(); ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent'); ctx.lineWidth = 2 / scale; 
                    ctx.setLineDash([4 / scale, 4 / scale]);
                    const originalPoint = extendState.whichEnd === 'start' ? {x: obj.startX, y: obj.startY} : {x: obj.endX, y: obj.endY};
                    ctx.moveTo(originalPoint.x, originalPoint.y); ctx.lineTo(extendState.previewPoint.x, extendState.previewPoint.y);
                    ctx.stroke(); ctx.setLineDash([]);
                }
            }
            function drawControlPointHandles() { 
                if (!editModeActive || !editableObject || !controlPointHandles) return;
                const dpr = window.devicePixelRatio || 1; 
                const baseHandleColor = getComputedStyle(document.documentElement).getPropertyValue('--cad-selection-color');
                const specialHandleColor = getComputedStyle(document.documentElement).getPropertyValue('--accent');
                const selectedHandleColor = getComputedStyle(document.documentElement).getPropertyValue('--danger'); 

                controlPointHandles.forEach(h => {
                    const sPos = worldToScreen(h.x, h.y); 
                    ctx.save();
                    ctx.setTransform(dpr, 0, 0, dpr, 0, 0); 
                    ctx.translate(sPos.x, sPos.y); 
                    ctx.beginPath();
                    ctx.arc(0, 0, CONTROL_POINT_RADIUS_SCREEN, 0, Math.PI * 2);
                    let fC = baseHandleColor;
                    if (h.role === 'cp1' || h.role === 'cp2' || h.role === 'center' || h.role === 'radius') fC = specialHandleColor; 
                    if (h.selected) { fC = selectedHandleColor; } 
                    ctx.fillStyle = fC; ctx.fill(); 
                    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--canvas-bg'); 
                    ctx.lineWidth = h.selected ? 1.5 : 1; 
                    ctx.stroke();
                    ctx.restore(); 
                });
            }
            function redrawCanvas() {
                const dpr = window.devicePixelRatio || 1;
                ctx.save();
                ctx.setTransform(dpr, 0, 0, dpr, 0, 0); 
                ctx.clearRect(0, 0, canvas.width / dpr, canvas.height / dpr); 
                ctx.restore();

                updateCanvasBackgroundStyle();


                ctx.save();
                ctx.translate(offsetCanvas.x, offsetCanvas.y);
                ctx.scale(scale, scale);
                drawAllObjects();
                drawAllDimensions(); 
                drawPreview(); 
                if (transformState.active) { drawTransformControls(); }
                drawOffsetPreviewInternal();
                drawExtendPreview(); 
                ctx.restore(); 
                showSnapIndicator(); 
                drawControlPointHandles(); 
            }

            function distanceToSegment(p,v,w) { return distance(p, getNearestPointOnLineSegment(p,v,w));}
            function distanceToCurve(p, cPts, iType) {  
                const worldHitTol = HIT_TOLERANCE_SCREEN / scale;
                if (!cPts || cPts.length < 2) return Infinity;
                if (iType === 'linear') { for (let j = 0; j < cPts.length - 1; j++) { if (distanceToSegment(p, cPts[j], cPts[j+1]) < worldHitTol) return 0; } return Infinity; }
                const numSegApprox = 20; let minDist = Infinity;
                if (iType === 'cardinal' || iType === 'catmull-rom') {
                    if (cPts.length === 2) return distanceToSegment(p, cPts[0], cPts[1]);
                    for (let i = 0; i < cPts.length - 1; i++) { const p0 = (i === 0) ? cPts[i] : cPts[i - 1]; const p1 = cPts[i]; const p2 = cPts[i + 1]; const p3 = (i === cPts.length - 2) ? cPts[i + 1] : cPts[i + 2]; const cp1x = p1.x + (p2.x - p0.x) / 6; const cp1y = p1.y + (p2.y - p0.y) / 6; const cp2x = p2.x - (p3.x - p1.x) / 6; const cp2y = p2.y - (p3.y - p1.y) / 6; let prevPt = p1; for (let k = 1; k <= numSegApprox; k++) { const t = k / numSegApprox; const t_1 = 1 - t; const B0 = t_1*t_1*t_1; const B1 = 3*t*t_1*t_1; const B2 = 3*t*t*t_1; const B3 = t*t*t; const cPtVal = { x: B0*p1.x + B1*cp1x + B2*cp2x + B3*p2.x, y: B0*p1.y + B1*cp1y + B2*cp2y + B3*p2.y }; minDist = Math.min(minDist, distanceToSegment(p, prevPt, cPtVal)); if (minDist < worldHitTol) return minDist; prevPt = cPtVal; } }
                } else if (iType === 'bezier') {
                    if (cPts.length < 4 || (cPts.length - 1) % 3 !== 0) return Infinity; 
                    for (let i = 0; i < cPts.length - 1; i += 3) { const p1 = cPts[i]; const cp1 = cPts[i+1]; const cp2 = cPts[i+2]; const p2 = cPts[i+3]; if (!p2) break; let prevPt = p1; for (let k = 1; k <= numSegApprox; k++) { const t = k / numSegApprox; const t_1 = 1-t; const B0=t_1*t_1*t_1; const B1=3*t*t_1*t_1; const B2=3*t*t*t_1; const B3=t*t*t; const cPtVal = { x: B0*p1.x + B1*cp1.x + B2*cp2.x + B3*p2.x, y: B0*p1.y + B1*cp1.y + B2*cp2.y + B3*p2.y }; minDist = Math.min(minDist, distanceToSegment(p, prevPt, cPtVal)); if (minDist < worldHitTol) return minDist; prevPt = cPtVal; } }
                } return minDist;
            }
            function distanceToArc(p, arc) {  
                const dx_center = p.x - arc.centerX; const dy_center = p.y - arc.centerY;
                const distToCenter = Math.hypot(dx_center, dy_center);
                let angleToPoint = Math.atan2(dy_center, dx_center);
                let sAngle = arc.startAngle; let eAngle = arc.endAngle;
                let arcIsClockwise = arc.type === 'arc' ? arc.clockwise : !arc.counterClockwise; 
                const normalize = (angle) => { angle = angle % (2 * Math.PI); if (angle < 0) angle += (2 * Math.PI); return angle; };
                sAngle = normalize(sAngle); eAngle = normalize(eAngle); angleToPoint = normalize(angleToPoint);
                let angleInArc = false; const epsilon = 1e-5; 
                if (!arcIsClockwise) { if (sAngle < eAngle) { angleInArc = angleToPoint >= sAngle - epsilon && angleToPoint <= eAngle + epsilon; } else { angleInArc = (angleToPoint >= sAngle - epsilon || angleToPoint <= eAngle + epsilon); }
                } else { if (sAngle > eAngle) { angleInArc = angleToPoint <= sAngle + epsilon && angleToPoint >= eAngle - epsilon; } else { angleInArc = (angleToPoint <= sAngle + epsilon || angleToPoint >= eAngle - epsilon); } }
                let angularSpan = arcIsClockwise ? sAngle - eAngle : eAngle - sAngle;
                if (angularSpan < 0) angularSpan += 2 * Math.PI; 
                if (Math.abs(angularSpan) < epsilon * 10 || Math.abs(angularSpan - 2*Math.PI) < epsilon*10) angleInArc = true; 
                if (angleInArc) { return Math.abs(distToCenter - arc.radius);
                } else { const startArcPoint = { x: arc.centerX + arc.radius * Math.cos(arc.startAngle), y: arc.centerY + arc.radius * Math.sin(arc.startAngle) }; const endArcPoint   = { x: arc.centerX + arc.radius * Math.cos(arc.endAngle),   y: arc.centerY + arc.radius * Math.sin(arc.endAngle)   }; const distToStart = distance(p, startArcPoint); const distToEnd   = distance(p, endArcPoint); return Math.min(distToStart, distToEnd); }
            }
            function getObjectAtPosition(wp) { 
                if (editModeActive) return null; 
                const wHT = HIT_TOLERANCE_SCREEN / scale; 
                for (let i = objects.length - 1; i >= 0; i--) {
                    const obj = objects[i]; 
                    if (obj.isPreview || !isObjectVisible(obj)) continue; // Check visibility
                    if (obj.type === 'line') { if (distanceToSegment(wp, {x:obj.startX,y:obj.startY},{x:obj.endX,y:obj.endY}) < wHT) return obj; }
                    else if (obj.type === 'circle') { const dTC = distance(wp, {x:obj.centerX,y:obj.centerY}); if (Math.abs(dTC-obj.radius) < wHT) return obj; }
                    else if (obj.type === 'arc' || obj.type === 'arcCenterStartEnd') { if (distanceToArc(wp, obj) < wHT) return obj; }
                    else if (obj.type === 'spline') { if (distanceToCurve(wp, obj.points, obj.interpolationType) < wHT) return obj; }
                    else if (obj.type === 'point') { if (distance(wp, {x: obj.x, y: obj.y}) < wHT + (3 / scale)) return obj; }
                    else if (obj.type === 'rectangle') { const p1={x:obj.x,y:obj.y},p2={x:obj.x+obj.width,y:obj.y},p3={x:obj.x+obj.width,y:obj.y+obj.height},p4={x:obj.x,y:obj.y+obj.height}; if(distanceToSegment(wp,p1,p2)<wHT||distanceToSegment(wp,p2,p3)<wHT||distanceToSegment(wp,p3,p4)<wHT||distanceToSegment(wp,p4,p1)<wHT) return obj; } 
                    else if (obj.type === 'ellipse') { const dx = wp.x - obj.centerX; const dy = wp.y - obj.centerY; const rot = -(obj.rotation || 0); const cosR = Math.cos(rot); const sinR = Math.sin(rot); const dx_rot = dx * cosR - dy * sinR; const dy_rot = dx * sinR + dy * cosR; const dist_norm_sq = (dx_rot / obj.radiusX)**2 + (dy_rot / obj.radiusY)**2; const toleranceFactor = 0.15; if (Math.abs(dist_norm_sq - 1) < toleranceFactor * (wHT / Math.min(obj.radiusX, obj.radiusY)) ) { return obj; } } 
                    else if (obj.type === 'hexagon' || obj.type === 'star') { if (obj.points && obj.points.length > 1) { for (let k = 0; k < obj.points.length; k++) { const p_current = obj.points[k]; const p_next = obj.points[(k + 1) % obj.points.length]; if (distanceToSegment(wp, p_current, p_next) < wHT) return obj; } } }
                } return null; 
            }
            function getDimensionAtPosition(wp) { 
                if (editModeActive) return null;
                const worldHitTol = HIT_TOLERANCE_SCREEN / scale; const dimTxtSizeScaled = DIM_TEXT_SIZE_SCREEN / scale; const textOffsetFromDimLineScaled = DIM_OFFSET_FROM_LINE_SCREEN / scale;
                for (let i = dimensions.length - 1; i >= 0; i--) {
                    const dim = dimensions[i];
                    if (dim.type === 'dimHorizontal') { if (Math.abs(wp.y - dim.offsetY) < worldHitTol && wp.x >= Math.min(dim.p1.x, dim.p2.x) - worldHitTol && wp.x <= Math.max(dim.p1.x, dim.p2.x) + worldHitTol) return dim; const textCenterX = (dim.p1.x + dim.p2.x) / 2; const textCenterY = dim.offsetY - textOffsetFromDimLineScaled;  const textWidthApprox = String(dim.value.toFixed(1)).length * dimTxtSizeScaled * 0.55; if (Math.abs(wp.y - textCenterY) < dimTxtSizeScaled / 1.5 && Math.abs(wp.x - textCenterX) < textWidthApprox / 2) return dim;
                    } else if (dim.type === 'dimVertical') { if (Math.abs(wp.x - dim.offsetX) < worldHitTol && wp.y >= Math.min(dim.p1.y, dim.p2.y) - worldHitTol && wp.y <= Math.max(dim.p1.y, dim.p2.y) + worldHitTol) return dim; const textRotatedCenterX = dim.offsetX - textOffsetFromDimLineScaled * (Math.sign(dim.p1.x - dim.offsetX) || 1); const textRotatedCenterY = (dim.p1.y + dim.p2.y) / 2; if (distance(wp, {x: textRotatedCenterX, y: textRotatedCenterY}) < dimTxtSizeScaled * 1.2) return dim;
                    } else if (dim.type === 'dimRadius') { if (distanceToSegment(wp, dim.center, dim.pointOnCircle) < worldHitTol) return dim; if (dim.hasExtension && distanceToSegment(wp, dim.pointOnCircle, dim.textPos) < worldHitTol) return dim; let textDisplayX = dim.textPos.x; let textDisplayY = dim.textPos.y; if (!dim.hasExtension) { const angleToPoint = Math.atan2(dim.pointOnCircle.y - dim.center.y, dim.pointOnCircle.x - dim.center.x); const textOffsetFromCirc = (DIM_ARROW_SIZE_SCREEN / scale) + (DIM_OFFSET_FROM_LINE_SCREEN / scale); textDisplayX = dim.pointOnCircle.x + textOffsetFromCirc * Math.cos(angleToPoint); textDisplayY = dim.pointOnCircle.y + textOffsetFromCirc * Math.sin(angleToPoint); } if (distance(wp, {x: textDisplayX, y: textDisplayY}) < dimTxtSizeScaled) return dim;  }
                } return null;
            }
            function getControlPointHandleAtPosition(wp) { 
                if (!editModeActive || !controlPointHandles || !controlPointHandles.length) return null;
                const sMp = worldToScreen(wp.x, wp.y); 
                for (let i = controlPointHandles.length - 1; i >= 0; i--) { const h = controlPointHandles[i]; const hSp = worldToScreen(h.x, h.y); const d = distance(sMp, hSp); if (d <= CONTROL_POINT_RADIUS_SCREEN + (HIT_TOLERANCE_SCREEN / 2)) return h; } return null;
            }
            
            function enterEditMode(objectToEdit) { 
                if (!objectToEdit || !['line', 'circle', 'spline', 'point', 'rectangle', 'arc', 'arcCenterStartEnd', 'ellipse', 'hexagon', 'star'].includes(objectToEdit.type)) return;
                exitAllToolModes(); editModeActive = true; editableObject = objectToEdit;
                currentTool = `edit_points_active_${objectToEdit.type}`; controlPointHandles = [];
                if (objectToEdit.type === 'line') { controlPointHandles.push({ x: objectToEdit.startX, y: objectToEdit.startY, role: 'start', originalIndex: 0, selected: false }); controlPointHandles.push({ x: objectToEdit.endX,   y: objectToEdit.endY,   role: 'end',   originalIndex: 1, selected: false });
                } else if (objectToEdit.type === 'circle') { controlPointHandles.push({ x: objectToEdit.centerX, y: objectToEdit.centerY, role: 'center', originalIndex: 0, selected: false }); const radiusHandleX = objectToEdit.centerX + objectToEdit.radius; const radiusHandleY = objectToEdit.centerY; controlPointHandles.push({ x: radiusHandleX, y: radiusHandleY, role: 'radius', originalIndex: 1, selected: false });
                } else if (objectToEdit.type === 'spline') { objectToEdit.points.forEach((p, idx) => { let role = 'anchor'; if (objectToEdit.interpolationType === 'bezier') { if (idx % 3 === 0) role = 'anchor'; else if ((idx - 1) % 3 === 0) role = 'cp1'; else if ((idx - 2) % 3 === 0) role = 'cp2'; } controlPointHandles.push({ x: p.x, y: p.y, originalIndex: idx, role: role, selected: false }); });
                } else if (objectToEdit.type === 'point') { controlPointHandles.push({ x: objectToEdit.x, y: objectToEdit.y, role: 'point', originalIndex: 0, selected: false }); 
                } else if (objectToEdit.type === 'rectangle') {
                    controlPointHandles.push({ x: objectToEdit.x, y: objectToEdit.y, role: 'corner', originalIndex: 0, selected: false }); // TL
                    controlPointHandles.push({ x: objectToEdit.x + objectToEdit.width, y: objectToEdit.y, role: 'corner', originalIndex: 1, selected: false }); // TR
                    controlPointHandles.push({ x: objectToEdit.x + objectToEdit.width, y: objectToEdit.y + objectToEdit.height, role: 'corner', originalIndex: 2, selected: false }); // BR
                    controlPointHandles.push({ x: objectToEdit.x, y: objectToEdit.y + objectToEdit.height, role: 'corner', originalIndex: 3, selected: false }); // BL
                } else if (objectToEdit.type === 'arc' || objectToEdit.type === 'arcCenterStartEnd') {
                    controlPointHandles.push({ x: objectToEdit.centerX, y: objectToEdit.centerY, role: 'center', originalIndex: 0, selected: false });
                    const pStart = {x: objectToEdit.centerX + objectToEdit.radius * Math.cos(objectToEdit.startAngle), y: objectToEdit.centerY + objectToEdit.radius * Math.sin(objectToEdit.startAngle)};
                    const pEnd = {x: objectToEdit.centerX + objectToEdit.radius * Math.cos(objectToEdit.endAngle), y: objectToEdit.centerY + objectToEdit.radius * Math.sin(objectToEdit.endAngle)};
                    controlPointHandles.push({ ...pStart, role: 'startPoint', originalIndex: 1, selected: false });
                    controlPointHandles.push({ ...pEnd, role: 'endPoint', originalIndex: 2, selected: false });
                    if (objectToEdit.type === 'arc' && objectToEdit.p2) { // Midpoint for 3P arc
                         controlPointHandles.push({ ...objectToEdit.p2, role: 'midPointArc', originalIndex: 3, selected: false });
                    }
                } else if (objectToEdit.type === 'ellipse') {
                    controlPointHandles.push({ x: objectToEdit.centerX, y: objectToEdit.centerY, role: 'center', originalIndex: 0, selected: false });
                    const rot = objectToEdit.rotation || 0;
                    const cosR = Math.cos(rot); const sinR = Math.sin(rot);
                    controlPointHandles.push({ x: objectToEdit.centerX + objectToEdit.radiusX * cosR, y: objectToEdit.centerY + objectToEdit.radiusX * sinR, role: 'radiusX', originalIndex: 1, selected: false });
                    controlPointHandles.push({ x: objectToEdit.centerX - objectToEdit.radiusY * sinR, y: objectToEdit.centerY + objectToEdit.radiusY * cosR, role: 'radiusY', originalIndex: 2, selected: false });
                } else if (objectToEdit.type === 'hexagon' || objectToEdit.type === 'star') {
                     objectToEdit.points.forEach((p, idx) => {
                        controlPointHandles.push({ x: p.x, y: p.y, role: 'vertex', originalIndex: idx, selected: false });
                    });
                    if (objectToEdit.centerX !== undefined) {
                        controlPointHandles.push({ x: objectToEdit.centerX, y: objectToEdit.centerY, role: 'centerPoly', originalIndex: objectToEdit.points.length, selected: false });
                    }
                }
                selectedObjectIds = [objectToEdit.id]; updateToolStatusAndCursor(); redrawCanvas();
            }
            function exitEditMode() { 
                if (!editModeActive) return;
                if (editableObject) saveStateForUndo("Finalizar Edición de Puntos"); 
                editModeActive = false; editableObject = null; currentSnap = null;
                if (controlPointHandles) controlPointHandles.forEach(h => h.selected = false); 
                controlPointHandles = []; isDraggingControlPoint = false; dragStartHandlePositions.clear();
                if (currentTool.startsWith('edit_points_active')) { currentTool = 'select'; }
                updateToolStatusAndCursor(); redrawCanvas();
            }
            function getPerpendicularVector(startX, startY, endX, endY, sideFactor = 1) { const dx = endX - startX; const dy = endY - startY; const length = Math.hypot(dx,dy); if (length === 0) return {x:0, y:0}; return { x:sideFactor*(-dy/length), y:sideFactor*(dx/length)}; }
            function calculateOffsetForObject(obj, distanceVal, singleSide) { 
                if (obj.type === "line") { const sideFactor = singleSide === "left" ? 1 : -1; const perp = getPerpendicularVector(obj.startX, obj.startY, obj.endX, obj.endY, sideFactor); return { type: "line", isPreview: true, startX: obj.startX + perp.x * distanceVal, startY: obj.startY + perp.y * distanceVal, endX: obj.endX + perp.x * distanceVal, endY: obj.endY + perp.y * distanceVal, };
                } else if (obj.type === "circle") { const radiusChange = singleSide === "left" ? distanceVal : -distanceVal; const newRadius = Math.max(0.1 / scale, obj.radius + radiusChange); return { type: "circle", isPreview: true, centerX: obj.centerX, centerY: obj.centerY, radius: newRadius }; 
                } else if (obj.type === "arc" || obj.type === "arcCenterStartEnd") {
                    const radiusChange = singleSide === "left" ? distanceVal : -distanceVal; 
                    const newRadius = Math.max(0.1 / scale, obj.radius + radiusChange);
                    return { ...obj, type: obj.type, radius: newRadius, isPreview: true }; 
                }
                console.warn(`Offset para ${obj.type} not fully implemented for preview or needs refinement.`); return null;
            }
            function updateOffsetPreview() { 
                if (!objectToOffset) { offsetPreviewObjects = []; redrawCanvas(); return; }
                const distanceVal = parseFloat(offsetDistanceInput.value);
                if (isNaN(distanceVal) || distanceVal <= 0) { offsetPreviewObjects = []; redrawCanvas(); return; }
                offsetPreviewObjects = [];
                if (offsetSide === "left" || offsetSide === "right") { const preview = calculateOffsetForObject(objectToOffset, distanceVal, offsetSide); if (preview) offsetPreviewObjects.push(preview);
                } else if (offsetSide === "both") { const previewLeft = calculateOffsetForObject(objectToOffset, distanceVal, "left"); const previewRight = calculateOffsetForObject(objectToOffset, distanceVal, "right"); if (previewLeft) offsetPreviewObjects.push(previewLeft); if (previewRight) offsetPreviewObjects.push(previewRight); }
                redrawCanvas();
            }
            function applyCurrentOffset() { 
                if (offsetPreviewObjects.length > 0) {
                    saveStateForUndo("Equidistancia");
                    offsetPreviewObjects.forEach(preview => { if (preview) { addCreatedObject({ ...preview, isPreview: false }); } }); // Use addCreatedObject
                    selectedObjectIds = []; objectToOffset = null; offsetPreviewObjects = [];
                } redrawCanvas(); updateToolStatusAndCursor(); 
            }
            function setOffsetSideUI(side) { 
                offsetSide = side;
                offsetLeftBtn.classList.toggle("active", side === "left");
                offsetRightBtn.classList.toggle("active", side === "right");
                offsetBothBtn.classList.toggle("active", side === "both");
                if (objectToOffset) updateOffsetPreview(); updateToolStatusAndCursor();
            }
            function resetTrimState() { trimState = { phase: 0, boundaries: [], objectToTrimId: null, intersections: [], previewSegment: null }; currentSnap = null; }
            function lineLineIntersection(lineObj1, lineObj2, forTrimSegmentCheck = true) { 
                const x1=lineObj1.startX,y1=lineObj1.startY,x2=lineObj1.endX,y2=lineObj1.endY,x3=lineObj2.startX,y3=lineObj2.startY,x4=lineObj2.endX,y4=lineObj2.endY;
                const den=(x1-x2)*(y3-y4)-(y1-y2)*(x3-x4); if(den===0)return null;
                const tNum=(x1-x3)*(y3-y4)-(y1-y3)*(x3-x4), uNum=-((x1-x2)*(y1-y3)-(y1-y2)*(x1-x3));
                const t=tNum/den, u=uNum/den;
                if(forTrimSegmentCheck){if(t>=-1e-9&&t<=1+1e-9&&u>=-1e-9&&u<=1+1e-9)return{x:x1+t*(x2-x1),y:y1+t*(y2-y1)};}
                else return{x:x1+t*(x2-x1),y:y1+t*(y2-y1),t:t,u:u}; return null;
            }
            function calculateTrimIntersections() { 
                if (!trimState.objectToTrimId || trimState.boundaries.length === 0) return;
                const objToTrim = objects.find(o => o.id === trimState.objectToTrimId);
                if (!objToTrim || objToTrim.type !== 'line') { trimState.intersections = []; return; }
                trimState.intersections = [];
                trimState.boundaries.forEach(boundaryId => { const boundaryObj = objects.find(o => o.id === boundaryId); if (boundaryObj && boundaryObj.id !== objToTrim.id && boundaryObj.type === 'line') { const intersect = lineLineIntersection(objToTrim, boundaryObj, true); if (intersect) trimState.intersections.push(intersect); } });
                if (objToTrim.type === 'line' && trimState.intersections.length > 0) { trimState.intersections.sort((a, b) => distance(a, {x:objToTrim.startX, y:objToTrim.startY}) - distance(b, {x:objToTrim.startX, y:objToTrim.startY})); }
            }
            function getTrimPreviewSegment(mouseWPos) { 
                if (!trimState.objectToTrimId || trimState.intersections.length === 0) return null;
                const objToTrim = objects.find(o => o.id === trimState.objectToTrimId);
                if (!objToTrim || objToTrim.type !== 'line') return null;
                let closestSegment = null; let minDistToMouse = Infinity;
                const worldHitTol = HIT_TOLERANCE_SCREEN / scale; const segments = [];
                let currentStart = {x: objToTrim.startX, y: objToTrim.startY};
                for (const intersect of trimState.intersections) { segments.push({ type: 'line', startX: currentStart.x, startY: currentStart.y, endX: intersect.x, endY: intersect.y}); currentStart = intersect; }
                segments.push({ type: 'line', startX: currentStart.x, startY: currentStart.y, endX: objToTrim.endX, endY: objToTrim.endY});
                segments.forEach((seg, index) => { if (distance({x:seg.startX,y:seg.startY}, {x:seg.endX,y:seg.endY}) < 1e-6 / scale) return; const distVal = distanceToSegment(mouseWPos, {x: seg.startX, y: seg.startY}, {x: seg.endX, y: seg.endY}); if (distVal < minDistToMouse) { minDistToMouse = distVal; closestSegment = { ...seg, part: index }; } });
                if (minDistToMouse > worldHitTol * 2) return null; return closestSegment;
            }
            function applyActualTrim() { 
                if (!trimState.objectToTrimId || !trimState.previewSegment) return;
                saveStateForUndo("Recortar");
                const objIndex = objects.findIndex(o => o.id === trimState.objectToTrimId);
                if (objIndex === -1) return; const objToModify = objects[objIndex]; const partToRemove = trimState.previewSegment;
                if (objToModify.type === 'line') {
                    const segLengthThreshold = 1e-6 / scale; 
                    if (distance(partToRemove, {x:objToModify.startX, y:objToModify.startY}) < segLengthThreshold && distance({x:partToRemove.endX, y:partToRemove.endY}, {x:objToModify.endX, y:objToModify.endY}) < segLengthThreshold) { objects.splice(objIndex, 1); }
                    else if (distance(partToRemove, {x:objToModify.startX, y:objToModify.startY}) < segLengthThreshold) { objToModify.startX = partToRemove.endX; objToModify.startY = partToRemove.endY; }
                    else if (distance({x:partToRemove.endX, y:partToRemove.endY}, {x:objToModify.endX, y:objToModify.endY}) < segLengthThreshold) { objToModify.endX = partToRemove.startX; objToModify.endY = partToRemove.startY; }
                    else { const originalEnd = {x: objToModify.endX, y: objToModify.endY}; objToModify.endX = partToRemove.startX; objToModify.endY = partToRemove.startY; 
                           addCreatedObject({ type: 'line', startX: partToRemove.endX, startY: partToRemove.endY, endX: originalEnd.x, endY: originalEnd.y }); // Use addCreatedObject
                         }
                    if (distance({x:objToModify.startX, y:objToModify.startY}, {x:objToModify.endX, y:objToModify.endY}) < segLengthThreshold) { objects.splice(objIndex, 1); }
                }
                resetTrimState(); setTool('trim'); if (trimState.objectToTrimId && objects.find(o => o.id === trimState.objectToTrimId)) { calculateTrimIntersections(); } else { trimState.phase = (trimState.boundaries.length > 0) ? 2 : 0; }
                redrawCanvas(); updateToolStatusAndCursor();
            }
            function resetExtendState() { extendState = { objectToExtendId: null, boundaryId: null, whichEnd: null, previewPoint: null, possibleExtensions: [] }; currentSnap = null; }
            function getClosestLineEnd(line, point) { 
                const distToStart = distance({ x: line.startX, y: line.startY }, point); const distToEnd = distance({ x: line.endX, y: line.endY }, point);
                if (Math.abs(distToStart - distToEnd) < (HIT_TOLERANCE_SCREEN / scale)) { const lineVector = {x: line.endX - line.startX, y: line.endY - line.startY}; const pointVector = {x: point.x - line.startX, y: point.y - line.startY}; const dotProduct = lineVector.x * pointVector.x + lineVector.y * pointVector.y; return dotProduct > (Math.hypot(lineVector.x, lineVector.y)**2 / 2) ? 'end' : 'start'; }
                return distToStart < distToEnd ? 'start' : 'end';
            }
            function getLineCircleIntersections(lineStart, lineEnd, circle) { 
                const cx=circle.centerX,cy=circle.centerY,r=circle.radius,x1=lineStart.x,y1=lineStart.y,x2=lineEnd.x,y2=lineEnd.y;
                const dx=x2-x1,dy=y2-y1,A=dx*dx+dy*dy,B=2*(dx*(x1-cx)+dy*(y1-cy)),C=(x1-cx)*(x1-cx)+(y1-cy)*(y1-cy)-r*r;
                const det=B*B-4*A*C; if(A<=1e-9||det<-1e-9)return[];
                const results=[]; if(Math.abs(det)<1e-9){const t=-B/(2*A);results.push({x:x1+t*dx,y:y1+t*dy,t:t});}
                else{const t1=(-B+Math.sqrt(det))/(2*A),t2=(-B-Math.sqrt(det))/(2*A);results.push({x:x1+t1*dx,y:y1+t1*dy,t:t1});results.push({x:x1+t2*dx,y:y1+t2*dy,t:t2});} return results;
            }
            function calculatePossibleExtensions() { 
                extendState.possibleExtensions = []; if (!extendState.objectToExtendId || !extendState.whichEnd) return;
                const targetLine = objects.find(o => o.id === extendState.objectToExtendId); if (!targetLine || targetLine.type !== 'line') return;
                let p0, dirVect; 
                if (extendState.whichEnd === 'start') { p0 = { x: targetLine.startX, y: targetLine.startY }; dirVect = { x: targetLine.startX - targetLine.endX, y: targetLine.startY - targetLine.endY }; } 
                else { p0 = { x: targetLine.endX, y: targetLine.endY }; dirVect = { x: targetLine.endX - targetLine.startX, y: targetLine.endY - targetLine.startY }; }
                const lenDir = Math.hypot(dirVect.x, dirVect.y); if (lenDir < 1e-9) return; 
                const p1Ray = { x: p0.x + dirVect.x / lenDir * 1000000, y: p0.y + dirVect.y / lenDir * 1000000 }; 
                const lineToExtendRay = { startX: p0.x, startY: p0.y, endX: p1Ray.x, endY: p1Ray.y };
                objects.forEach(boundaryObj => {
                    if (boundaryObj.id === targetLine.id || boundaryObj.isPreview || !isObjectVisible(boundaryObj)) return; 
                    if (boundaryObj.type === 'line') { const intersect = lineLineIntersection(lineToExtendRay, boundaryObj, false); if (intersect && intersect.t > 1e-9 && intersect.u >= -1e-9 && intersect.u <= 1.0 + 1e-9) { extendState.possibleExtensions.push({ boundaryId: boundaryObj.id, point: { x: intersect.x, y: intersect.y }, distance: distance(p0, {x: intersect.x, y: intersect.y}) }); }
                    } else if (boundaryObj.type === 'circle') { const intersects = getLineCircleIntersections(p0, p1Ray, boundaryObj); intersects.forEach(intersect => { if (intersect.t > 1e-9) { extendState.possibleExtensions.push({ boundaryId: boundaryObj.id, point: { x: intersect.x, y: intersect.y }, distance: distance(p0, {x: intersect.x, y: intersect.y}) }); } }); }
                });
                extendState.possibleExtensions.sort((a,b) => a.distance - b.distance);
            }
            function updateExtendPreview() { 
                if (!extendState.objectToExtendId || !extendState.whichEnd) { extendState.previewPoint = null; redrawCanvas(); return; }
                calculatePossibleExtensions();
                if (extendState.boundaryId) { const specificExt = extendState.possibleExtensions.find(ext => ext.boundaryId === extendState.boundaryId); extendState.previewPoint = specificExt ? specificExt.point : null;
                } else if (extendState.possibleExtensions.length > 0) { extendState.previewPoint = extendState.possibleExtensions[0].point;
                } else { extendState.previewPoint = null; } redrawCanvas(); 
            }
            function applyActualExtend() { 
                if (!extendState.objectToExtendId || !extendState.whichEnd || !extendState.previewPoint) return;
                saveStateForUndo("Alargar");
                const targetObj = objects.find(o => o.id === extendState.objectToExtendId);
                if (!targetObj || targetObj.type !== 'line') return;
                if (extendState.whichEnd === 'start') { targetObj.startX = extendState.previewPoint.x; targetObj.startY = extendState.previewPoint.y; }
                else { targetObj.endX = extendState.previewPoint.x; targetObj.endY = extendState.previewPoint.y; }
                setTool('extend'); redrawCanvas(); updateToolStatusAndCursor();
            }
            function getSelectedCircleForRadiusDim() { if (selectedObjectIds.length === 1) { const obj = objects.find(o => o.id === selectedObjectIds[0]); if (obj && obj.type === 'circle') return obj; } return null; }

            function exitAllToolModes(exceptTool = null) { 
                if (editModeActive && exceptTool !== 'edit') exitEditMode();
                if (transformState.active && (exceptTool !== 'rotate' && exceptTool !== 'scale')) { exitTransformTool(true); }
                const isMultiStepToolInProgress = (currentTool === 'spline' && drawing && currentSplinePoints.length > 0 && exceptTool === 'spline') || (currentTool === 'arcCenterStartEnd' && drawing && (arcCenterPoint || startPoint) && exceptTool === 'arcCenterStartEnd') || (currentTool === 'ellipse' && drawing && (ellipseCenter || ellipseRadiusXPoint) && exceptTool === 'ellipse');
                if (!isMultiStepToolInProgress) { if (drawing && exceptTool !== 'drawing' && !transformState.active) { if (currentTool === 'spline') cancelSplineDrawing(); else if (['arc', 'arcCenterStartEnd', 'ellipse', 'hexagon', 'star', 'polygon', 'rectangle'].includes(currentTool) || currentTool.startsWith('dim')) { drawing = false; startPoint = null; definingPoint2 = null; arcCenterPoint = null; ellipseCenter = null; ellipseRadiusXPoint = null; } else { drawing = false; startPoint = null; } } }
                if (objectToOffset && exceptTool !== 'offset') { objectToOffset = null; offsetPreviewObjects = []; hideFloatingPanel(offsetOptionsPanel); }
                if ((trimState.phase > 0 || trimState.objectToTrimId) && exceptTool !== 'trim') resetTrimState();
                if (extendState.objectToExtendId && exceptTool !== 'extend') resetExtendState();
                isDraggingObject = false; isDraggingControlPoint = false; currentSnap = null;
                if (exceptTool !== 'arcCenterStartEnd') { arcCenterPoint = null; }
                if (exceptTool !== 'ellipse') { ellipseCenter = null; ellipseRadiusXPoint = null; }
                if (exceptTool !== 'spline' && splineOptionsPanel.classList.contains('visible')) hideFloatingPanel(splineOptionsPanel);
            }
            
            zoomInBtn.addEventListener('click', () => {
                const r = canvas.getBoundingClientRect(); const sX = r.width / 2; const sY = r.height / 2;
                const newScale = Math.min(MAX_SCALE, scale * 1.2); if (newScale === scale) return;
                offsetCanvas.x = sX - (sX - offsetCanvas.x) * (newScale / scale); offsetCanvas.y = sY - (sY - offsetCanvas.y) * (newScale / scale);
                scale = newScale; redrawCanvas();
            });
            zoomOutBtn.addEventListener('click', () => {
                const r = canvas.getBoundingClientRect(); const sX = r.width / 2; const sY = r.height / 2;
                const newScale = Math.max(MIN_SCALE, scale / 1.2); if (newScale === scale) return;
                offsetCanvas.x = sX - (sX - offsetCanvas.x) * (newScale / scale); offsetCanvas.y = sY - (sY - offsetCanvas.y) * (newScale / scale);
                scale = newScale; redrawCanvas();
            });
            zoomToFitBtn.addEventListener('click', () => {
                if (objects.length === 0) { scale = 1.0; const dpr = window.devicePixelRatio || 1; offsetCanvas.x = (canvas.width / dpr) / 2; offsetCanvas.y = (canvas.height / dpr) / 2; redrawCanvas(); return; }
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                objects.forEach(obj => {
                    if (!isObjectVisible(obj)) return; // Consider only visible objects for zoom fit
                    if (obj.type === 'line') { minX = Math.min(minX, obj.startX, obj.endX); minY = Math.min(minY, obj.startY, obj.endY); maxX = Math.max(maxX, obj.startX, obj.endX); maxY = Math.max(maxY, obj.startY, obj.endY); }
                    else if (obj.type === 'circle') { minX = Math.min(minX, obj.centerX - obj.radius); minY = Math.min(minY, obj.centerY - obj.radius); maxX = Math.max(maxX, obj.centerX + obj.radius); maxY = Math.max(maxY, obj.centerY + obj.radius); }
                    else if (obj.points && obj.points.length > 0) { obj.points.forEach(p => { minX=Math.min(minX,p.x); minY=Math.min(minY,p.y); maxX=Math.max(maxX,p.x); maxY=Math.max(maxY,p.y); }); }
                    else if (obj.x !== undefined && obj.y !== undefined) { minX = Math.min(minX, obj.x); minY = Math.min(minY, obj.y); if (obj.width !== undefined) { maxX = Math.max(maxX, obj.x + obj.width); maxY = Math.max(maxY, obj.y + obj.height); } else { maxX = Math.max(maxX, obj.x); maxY = Math.max(maxY, obj.y); } }
                     else if (obj.type === 'arc' || obj.type === 'arcCenterStartEnd') { 
                        const pS = {x: obj.centerX + obj.radius * Math.cos(obj.startAngle), y: obj.centerY + obj.radius * Math.sin(obj.startAngle) };
                        const pE = {x: obj.centerX + obj.radius * Math.cos(obj.endAngle), y: obj.centerY + obj.radius * Math.sin(obj.endAngle) };
                        minX = Math.min(minX, obj.centerX - obj.radius, pS.x, pE.x); minY = Math.min(minY, obj.centerY - obj.radius, pS.y, pE.y);
                        maxX = Math.max(maxX, obj.centerX + obj.radius, pS.x, pE.x); maxY = Math.max(maxY, obj.centerY + obj.radius, pS.y, pE.y);
                    }
                });
                if (minX === Infinity) { redrawCanvas(); return; } 
                const dpr = window.devicePixelRatio || 1; const canvasWidthCSS = canvas.width / dpr; const canvasHeightCSS = canvas.height / dpr;
                const worldWidth = maxX - minX; const worldHeight = maxY - minY;
                const padding = 20 * dpr; 
                const scaleX = worldWidth > 0 ? (canvasWidthCSS - 2 * padding) / worldWidth : MAX_SCALE;
                const scaleY = worldHeight > 0 ? (canvasHeightCSS - 2 * padding) / worldHeight : MAX_SCALE;
                scale = Math.min(scaleX, scaleY, MAX_SCALE); scale = Math.max(scale, MIN_SCALE);
                offsetCanvas.x = (canvasWidthCSS / 2) - ((minX + worldWidth / 2) * scale);
                offsetCanvas.y = (canvasHeightCSS / 2) - ((minY + worldHeight / 2) * scale);
                redrawCanvas();
            });

            canvas.addEventListener('wheel', (e) => { 
                e.preventDefault(); 
                const r = canvas.getBoundingClientRect(); const sX = e.clientX - r.left; const sY = e.clientY - r.top; 
                const newScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, scale * (e.deltaY < 0 ? 1.1 : 1/1.1)));
                if (newScale === scale) return; 
                const oldScale = scale; scale = newScale;
                offsetCanvas.x = sX - (sX - offsetCanvas.x) * (newScale / oldScale);
                offsetCanvas.y = sY - (sY - offsetCanvas.y) * (newScale / oldScale);
                redrawCanvas(); 
            });
            canvas.addEventListener('mousedown', (event) => { 
                 const rawMousePosWorld = screenToWorld(event.clientX - canvas.getBoundingClientRect().left, event.clientY - canvas.getBoundingClientRect().top);
                 mousePosWorld = getMouseWorldPositionWithAids(event); 
                 
                 if (event.button === 1 || (event.button === 0 && event.altKey)) { isPanning = true; const r = canvas.getBoundingClientRect(); panStartMousePos_Screen = {x:event.clientX-r.left,y:event.clientY-r.top}; event.preventDefault();
                 } else if (event.button === 0) { 
                    if (transformState.active) { if (handleTransformMouseDown(event)) { redrawCanvas(); updateToolStatusAndCursor(); return; } }
                    else if (editModeActive) { 
                        const cH = getControlPointHandleAtPosition(rawMousePosWorld); 
                        if (cH) {
                            if (!event.ctrlKey && !event.metaKey) controlPointHandles.forEach(h => h.selected = (h === cH));
                            else cH.selected = !cH.selected; 
                            isDraggingControlPoint = true; 
                            dragStartMousePos_World = { ...mousePosWorld }; 
                            dragStartHandlePositions.clear();
                            saveStateForUndo("Mover punto de control"); 
                            controlPointHandles.forEach(h => { if (h.selected) dragStartHandlePositions.set(h.originalIndex, {x:h.x,y:h.y}); });
                        } else controlPointHandles.forEach(h => h.selected = false); 
                    } else if (currentTool === 'offset') { 
                        const clickedObjectForOffset = getObjectAtPosition(rawMousePosWorld);
                        if (clickedObjectForOffset) { if (objectToOffset && objectToOffset.id === clickedObjectForOffset.id) applyCurrentOffset(); else { objectToOffset = clickedObjectForOffset; selectedObjectIds = [objectToOffset.id]; updateOffsetPreview(); }
                        } else { if (objectToOffset && offsetPreviewObjects.length > 0) applyCurrentOffset(); else { objectToOffset = null; offsetPreviewObjects = []; selectedObjectIds = []; } }
                    } else if (currentTool === 'trim') { 
                        const clickedTrimObject = getObjectAtPosition(rawMousePosWorld);
                        if (trimState.phase === 0 || trimState.phase === 1) { if (clickedTrimObject) { const index = trimState.boundaries.indexOf(clickedTrimObject.id); if (index > -1) trimState.boundaries.splice(index, 1); else trimState.boundaries.push(clickedTrimObject.id); selectedObjectIds = [...trimState.boundaries]; trimState.phase = 1; }
                        } else if (trimState.phase === 2) { if (clickedTrimObject && !trimState.boundaries.includes(clickedTrimObject.id)) { trimState.objectToTrimId = clickedTrimObject.id; selectedObjectIds = [clickedTrimObject.id, ...trimState.boundaries]; calculateTrimIntersections(); trimState.phase = 3; }
                        } else if (trimState.phase === 3) { if (trimState.previewSegment) applyActualTrim(); } 
                    } else if (currentTool === 'extend') { 
                        const clickedExtendObject = getObjectAtPosition(rawMousePosWorld);
                        if (!extendState.objectToExtendId) { if (clickedExtendObject && clickedExtendObject.type === 'line') { extendState.objectToExtendId = clickedExtendObject.id; extendState.whichEnd = getClosestLineEnd(clickedExtendObject, rawMousePosWorld); selectedObjectIds = [clickedExtendObject.id]; updateExtendPreview(); }
                        } else { if (clickedExtendObject && clickedExtendObject.id !== extendState.objectToExtendId) { extendState.boundaryId = clickedExtendObject.id; updateExtendPreview(); if (extendState.previewPoint) applyActualExtend(); else { extendState.boundaryId = null; updateExtendPreview(); } } else if (extendState.previewPoint) { if (extendState.possibleExtensions.length > 0 && distance(extendState.previewPoint, extendState.possibleExtensions[0].point) < 1e-6/scale) { extendState.boundaryId = extendState.possibleExtensions[0].boundaryId; applyActualExtend(); } } }
                    } else if (currentTool === 'arc') { 
                        if (!drawing) { startPoint = { ...mousePosWorld }; definingPoint2 = null; drawing = true;
                        } else if (!definingPoint2) { if (distance(startPoint, mousePosWorld) > 1e-6 / scale) { definingPoint2 = { ...mousePosWorld }; } else { console.warn("Punto medio del arco (3P) demasiado cerca del punto inicial.");}
                        } else { 
                            if (distance(definingPoint2, mousePosWorld) > 1e-6 / scale && distance(startPoint, mousePosWorld) > 1e-6 / scale) {
                                const arcParams = calculateArcParameters(startPoint, definingPoint2, mousePosWorld);
                                if (arcParams && arcParams.radius > 0.1 / scale) { 
                                    saveStateForUndo("Crear Arco (3P)");
                                    addCreatedObject({ type: 'arc', p1: { ...startPoint }, p2: { ...definingPoint2 }, p3: { ...mousePosWorld }, centerX: arcParams.centerX, centerY: arcParams.centerY, radius: arcParams.radius, startAngle: arcParams.startAngle, endAngle: arcParams.endAngle, clockwise: arcParams.clockwise });
                                } else { console.warn("No se pudo crear el arco (3P). Puntos colineales o radio muy pequeño."); }
                            } else { console.warn("Punto final del arco (3P) demasiado cerca de los puntos anteriores."); }
                            drawing = false; startPoint = null; definingPoint2 = null; currentSnap = null;
                        }
                    } else if (currentTool === 'arcCenterStartEnd') { 
                        if (!arcCenterPoint) { arcCenterPoint = { ...mousePosWorld }; drawing = true; 
                        } else if (!startPoint) { if (distance(arcCenterPoint, mousePosWorld) > 1e-6 / scale) { startPoint = { ...mousePosWorld }; } else { console.warn("Punto inicial del arco (C,I,F) coincide con el centro."); }
                        } else { 
                            const radius = distance(arcCenterPoint, startPoint);
                            if (radius > 1e-6 / scale && distance(arcCenterPoint, mousePosWorld) > 1e-6 / scale) { 
                                saveStateForUndo("Crear Arco (C,I,F)"); let sAngle = Math.atan2(startPoint.y - arcCenterPoint.y, startPoint.x - arcCenterPoint.x); let eAngle = Math.atan2(mousePosWorld.y - arcCenterPoint.y, mousePosWorld.x - arcCenterPoint.x); let isCCW = !event.ctrlKey; 
                                addCreatedObject({ type: 'arcCenterStartEnd', centerX: arcCenterPoint.x, centerY: arcCenterPoint.y, radius: radius, startAngle: sAngle, endAngle: eAngle, counterClockwise: isCCW, pCenter: {...arcCenterPoint}, pStart: {...startPoint}, pEnd: {...mousePosWorld} });
                            } else { console.warn("Punto final del arco (C,I,F) inválido (radio cero o coincide con centro)."); }
                            drawing = false; arcCenterPoint = null; startPoint = null; currentSnap = null;
                        }
                    } else if (currentTool === 'point') { 
                        saveStateForUndo("Crear Punto");
                        addCreatedObject({ type: 'point', x: mousePosWorld.x, y: mousePosWorld.y });
                    } else if (currentTool === 'rectangle') { 
                        if (!drawing) { startPoint = { ...mousePosWorld }; drawing = true;
                        } else { 
                            const width = mousePosWorld.x - startPoint.x; const height = mousePosWorld.y - startPoint.y;
                            if (Math.abs(width) > 1e-6 / scale && Math.abs(height) > 1e-6 / scale) { 
                                saveStateForUndo("Crear Rectángulo");
                                addCreatedObject({ type: 'rectangle', x: Math.min(startPoint.x, mousePosWorld.x), y: Math.min(startPoint.y, mousePosWorld.y), width: Math.abs(width), height: Math.abs(height) });
                            }
                            drawing = false; startPoint = null; currentSnap = null;
                        }
                    } else if (currentTool === 'ellipse') {
                        if (!ellipseCenter) { ellipseCenter = { ...mousePosWorld }; drawing = true;
                        } else if (!ellipseRadiusXPoint) { if (Math.abs(mousePosWorld.x - ellipseCenter.x) > 1e-6 / scale) { ellipseRadiusXPoint = { x: mousePosWorld.x, y: ellipseCenter.y }; } else { console.warn("Radio X de la elipse no puede ser cero."); }
                        } else { 
                            const radiusX = Math.abs(ellipseRadiusXPoint.x - ellipseCenter.x); const radiusY = Math.abs(mousePosWorld.y - ellipseCenter.y); 
                            if (radiusX > 1e-6 / scale && radiusY > 1e-6 / scale) { 
                                saveStateForUndo("Crear Elipse");
                                addCreatedObject({ type: 'ellipse', centerX: ellipseCenter.x, centerY: ellipseCenter.y, radiusX: radiusX, radiusY: radiusY, rotation: 0 });
                            } else { console.warn("Radios de la elipse inválidos."); }
                            drawing = false; ellipseCenter = null; ellipseRadiusXPoint = null; currentSnap = null;
                        }
                    } else if (currentTool === 'hexagon' || (currentTool === 'polygon' && starNumPoints === 6 )) { 
                        if (!startPoint) { startPoint = { ...mousePosWorld }; drawing = true;
                        } else { 
                            const radius = distance(startPoint, mousePosWorld);
                            if (radius > 1e-6 / scale) {
                                saveStateForUndo("Crear Hexágono"); const hexPoints = [];
                                const initialAngle = Math.atan2(mousePosWorld.y - startPoint.y, mousePosWorld.x - startPoint.x); 
                                for (let i = 0; i < 6; i++) { const angle = (Math.PI / 3) * i + initialAngle; hexPoints.push({ x: startPoint.x + radius * Math.cos(angle), y: startPoint.y + radius * Math.sin(angle) }); }
                                addCreatedObject({ type: 'hexagon', centerX: startPoint.x, centerY: startPoint.y, radius: radius, points: hexPoints });
                            } drawing = false; startPoint = null; currentSnap = null;
                        }
                    } else if (currentTool === 'star' || (currentTool === 'polygon' && starNumPoints !== 6)) { 
                        if (!startPoint) { startPoint = { ...mousePosWorld }; drawing = true;
                        } else { 
                            const outerRadius = distance(startPoint, mousePosWorld);
                            if (outerRadius > 1e-6 / scale) {
                                saveStateForUndo("Crear Estrella"); const innerRadius = outerRadius * starInnerRadiusFactor; const starPoints = [];
                                let rotation = Math.atan2(mousePosWorld.y - startPoint.y, mousePosWorld.x - startPoint.x); const angleStep = Math.PI / starNumPoints;
                                for (let i = 0; i < starNumPoints * 2; i++) { const currentRadius = (i % 2 === 0) ? outerRadius : innerRadius; starPoints.push({ x: startPoint.x + currentRadius * Math.cos(rotation), y: startPoint.y + currentRadius * Math.sin(rotation) }); rotation += angleStep; }
                                addCreatedObject({ type: 'star', centerX: startPoint.x, centerY: startPoint.y, outerRadius: outerRadius, innerRadius: innerRadius, numPoints: starNumPoints, points: starPoints });
                            } drawing = false; startPoint = null; currentSnap = null;
                        }
                    } else if (currentTool === 'dimHorizontal' || currentTool === 'dimVertical') { 
                        if (!drawing) { startPoint = { ...mousePosWorld }; drawing = true; definingPoint2 = null;
                        } else if (!definingPoint2) { if (distance(startPoint, mousePosWorld) > 1e-6 / scale) { definingPoint2 = { ...mousePosWorld }; } else { console.warn("Segundo punto de cota coincide con el primero."); }
                        } else { 
                            const value = (currentTool === 'dimHorizontal') ? Math.abs(startPoint.x - definingPoint2.x) : Math.abs(startPoint.y - definingPoint2.y);
                            if (value > 1e-6 / scale) { saveStateForUndo(`Crear Cota ${currentTool === 'dimHorizontal' ? 'H' : 'V'}`); dimensions.push({ id: getNewDimensionId(), type: currentTool, p1: { ...startPoint }, p2: { ...definingPoint2 }, offsetY: (currentTool === 'dimHorizontal') ? mousePosWorld.y : null, offsetX: (currentTool === 'dimVertical') ? mousePosWorld.x : null, value: value });
                            } else { console.warn("Cota de longitud cero."); }
                            drawing = false; startPoint = null; definingPoint2 = null; currentSnap = null;
                        }
                    } else if (currentTool === 'dimRadius') { 
                        const circle = getSelectedCircleForRadiusDim();
                        if (circle && drawing) { 
                            const dxMouse = mousePosWorld.x - circle.centerX; const dyMouse = mousePosWorld.y - circle.centerY; const distMouse = Math.hypot(dxMouse, dyMouse);
                            let pointOnCircle, textPos, hasExtension = false;
                            if (distMouse > 1e-6) { 
                                saveStateForUndo("Crear Cota Radio");
                                pointOnCircle = { x: circle.centerX + (dxMouse / distMouse) * circle.radius, y: circle.centerY + (dyMouse / distMouse) * circle.radius };
                                const textDistFromCircumference = Math.hypot(mousePosWorld.x - pointOnCircle.x, mousePosWorld.y - pointOnCircle.y);
                                const extensionThreshold = circle.radius * 0.1 + (DIM_ARROW_SIZE_SCREEN + DIM_TEXT_SIZE_SCREEN*2) / scale;
                                if (textDistFromCircumference > extensionThreshold ) { hasExtension = true; textPos = { ...mousePosWorld }; } else { textPos = { ...mousePosWorld }; }
                                dimensions.push({ id: getNewDimensionId(), type: 'dimRadius', center: { x: circle.centerX, y: circle.centerY }, radius: circle.radius, value: circle.radius, pointOnCircle: pointOnCircle, textPos: textPos, hasExtension: hasExtension });
                                currentSnap = null; drawing = false; 
                            }
                        } else if (!circle) { toolStatusDiv.textContent = "Cota Radio: Primero seleccione un círculo."; }
                    } else { 
                        const clickedDimension = getDimensionAtPosition(rawMousePosWorld);
                        const objectForSelection = !clickedDimension ? getObjectAtPosition(rawMousePosWorld) : null;

                        if (clickedDimension && currentTool === 'select') { 
                            if (event.ctrlKey || event.metaKey) { const i = selectedDimensionIds.indexOf(clickedDimension.id); if (i > -1) selectedDimensionIds.splice(i,1); else selectedDimensionIds.push(clickedDimension.id); } 
                            else { selectedDimensionIds = [clickedDimension.id]; selectedObjectIds = []; }
                            isDraggingObject = true; saveStateForUndo("Mover Cota"); dragStartMousePos_World = { ...mousePosWorld }; 
                            dragStartDimensionData.clear(); dragStartObjectPositions.clear(); 
                            dimensions.forEach(dim => { if (selectedDimensionIds.includes(dim.id)) { if (dim.type === 'dimHorizontal') dragStartDimensionData.set(dim.id, { p1x: dim.p1.x, p1y: dim.p1.y, p2x: dim.p2.x, p2y:dim.p2.y, offsetY: dim.offsetY }); else if (dim.type === 'dimVertical') dragStartDimensionData.set(dim.id, { p1x: dim.p1.x, p1y: dim.p1.y, p2x: dim.p2.x, p2y:dim.p2.y, offsetX: dim.offsetX }); else if (dim.type === 'dimRadius') dragStartDimensionData.set(dim.id, { centerX: dim.center.x, centerY: dim.center.y, pointX: dim.pointOnCircle.x, pointY: dim.pointOnCircle.y, textX: dim.textPos.x, textY: dim.textPos.y }); } });
                        } else if (objectForSelection && selectedObjectIds.includes(objectForSelection.id) && currentTool === 'select') { 
                            isDraggingObject = true; saveStateForUndo("Mover Objeto(s)"); dragStartMousePos_World = { ...mousePosWorld };
                            dragStartObjectPositions.clear(); dragStartDimensionData.clear(); 
                            objects.forEach(obj => { if (selectedObjectIds.includes(obj.id)) {
                                   if (obj.type==='line') dragStartObjectPositions.set(obj.id, {startX:obj.startX, startY:obj.startY, endX:obj.endX, endY:obj.endY});
                                    else if (obj.type==='circle') dragStartObjectPositions.set(obj.id, {centerX:obj.centerX, centerY:obj.centerY, radius:obj.radius});
                                    else if (obj.type==='arc' || obj.type==='arcCenterStartEnd') dragStartObjectPositions.set(obj.id, { centerX: obj.centerX, centerY: obj.centerY, p1x: obj.p1?.x, p1y: obj.p1?.y, p2x: obj.p2?.x, p2y: obj.p2?.y, p3x: obj.p3?.x, p3y: obj.p3?.y, pCenterX: obj.pCenter?.x, pCenterY: obj.pCenter?.y, pStartX: obj.pStart?.x, pStartY: obj.pStart?.y, pEndX: obj.pEnd?.x, pEndY: obj.pEnd?.y, startAngle: obj.startAngle, endAngle: obj.endAngle, radius: obj.radius });
                                    else if (obj.type==='spline') dragStartObjectPositions.set(obj.id, {points:JSON.parse(JSON.stringify(obj.points))}); 
                                    else if (obj.type==='point') dragStartObjectPositions.set(obj.id, {x: obj.x, y: obj.y});
                                    else if (obj.type==='rectangle') dragStartObjectPositions.set(obj.id, {x: obj.x, y: obj.y, width: obj.width, height: obj.height});
                                    else if (obj.type==='ellipse') dragStartObjectPositions.set(obj.id, {centerX: obj.centerX, centerY: obj.centerY, radiusX: obj.radiusX, radiusY: obj.radiusY, rotation: obj.rotation});
                                    else if (obj.type==='hexagon' || obj.type==='star') dragStartObjectPositions.set(obj.id, {centerX: obj.centerX, centerY: obj.centerY, radius: obj.radius, outerRadius: obj.outerRadius, points: JSON.parse(JSON.stringify(obj.points))});
                            }});
                        } else if (objectForSelection && currentTool === 'select') { if (event.ctrlKey || event.metaKey) { const i = selectedObjectIds.indexOf(objectForSelection.id); if(i>-1) selectedObjectIds.splice(i,1); else selectedObjectIds.push(objectForSelection.id); } else { selectedObjectIds = [objectForSelection.id]; selectedDimensionIds = []; }
                        } else if (currentTool === 'select') { if (!(event.ctrlKey || event.metaKey)) { selectedObjectIds = []; selectedDimensionIds = []; } }

                        if (['line', 'circle'].includes(currentTool)) {
                            if (!drawing) { startPoint = { ...mousePosWorld }; drawing = true; 
                            } else { 
                                if (currentTool === 'line') { if(distance(startPoint, mousePosWorld) > 1e-6 / scale) { saveStateForUndo("Crear Línea"); addCreatedObject({id:getNewObjectId(),type:'line',startX:startPoint.x,startY:startPoint.y,endX:mousePosWorld.x,endY:mousePosWorld.y}); } } 
                                else if (currentTool === 'circle') { const radius = distance(startPoint, mousePosWorld); if (radius > 0.1/scale) { saveStateForUndo("Crear Círculo"); addCreatedObject({id:getNewObjectId(),type:'circle',centerX:startPoint.x,centerY:startPoint.y,radius:radius}); } }
                                startPoint = null; drawing = false; currentSnap = null; 
                            }
                        } else if (currentTool === 'spline') { currentSplinePoints.push({ ...mousePosWorld }); drawing = true; }
                     }
                 }
                 redrawCanvas(); updateToolStatusAndCursor();
            });

            canvas.addEventListener('mousemove', (event) => {
                const canvasRect = canvas.getBoundingClientRect();
                lastKnownMouseScreenPos = {x: event.clientX - canvasRect.left, y: event.clientY - canvasRect.top};
                const prevMousePosWorld = { ...mousePosWorld }; 
                mousePosWorld = getMouseWorldPositionWithAids(event); 

                if (isPanning) {
                    const r = canvas.getBoundingClientRect();
                    const cSX = event.clientX-r.left; const cSY = event.clientY-r.top;
                    const dX = cSX - panStartMousePos_Screen.x; const dY = cSY - panStartMousePos_Screen.y;
                    offsetCanvas.x += dX; offsetCanvas.y += dY;
                    panStartMousePos_Screen = {x:cSX,y:cSY}; 
                } else if (transformState.active && transformState.dragStartPoint) { 
                    handleTransformMouseMove(event);
                } else if (isDraggingControlPoint && editModeActive && editableObject && dragStartHandlePositions.size > 0) { 
                    const deltaX_world = mousePosWorld.x - dragStartMousePos_World.x; 
                    const deltaY_world = mousePosWorld.y - dragStartMousePos_World.y;
                    controlPointHandles.forEach(h => {
                        if (h.selected && dragStartHandlePositions.has(h.originalIndex)) {
                            const originalHandlePos = dragStartHandlePositions.get(h.originalIndex);
                            const newX = originalHandlePos.x + deltaX_world; const newY = originalHandlePos.y + deltaY_world;
                            h.x = newX; h.y = newY; 
                            if (editableObject.type === 'line') {
                                if (h.role === 'start') { editableObject.startX = newX; editableObject.startY = newY; }
                                else if (h.role === 'end') { editableObject.endX = newX; editableObject.endY = newY; }
                            } else if (editableObject.type === 'circle') {
                                if (h.role === 'center') {
                                    editableObject.centerX = newX; editableObject.centerY = newY;
                                    const radiusHandle = controlPointHandles.find(handle => handle.role === 'radius');
                                    if (radiusHandle && !radiusHandle.selected) { 
                                        const originalRadiusHandlePos = dragStartHandlePositions.get(radiusHandle.originalIndex) || {x: editableObject.centerX + editableObject.radius, y: editableObject.centerY}; 
                                        const originalCenterPos = dragStartHandlePositions.get(h.originalIndex); 
                                        let angle;
                                        if (originalCenterPos && originalRadiusHandlePos) angle = Math.atan2(originalRadiusHandlePos.y - originalCenterPos.y, originalRadiusHandlePos.x - originalCenterPos.x);
                                        else angle = Math.atan2(radiusHandle.y - newY, radiusHandle.x - newX); 
                                        radiusHandle.x = newX + editableObject.radius * Math.cos(angle);
                                        radiusHandle.y = newY + editableObject.radius * Math.sin(angle);
                                    }
                                } else if (h.role === 'radius') {
                                    editableObject.radius = Math.max(0.1/scale, distance({x:newX,y:newY}, {x:editableObject.centerX, y:editableObject.centerY}));
                                    const angle = Math.atan2(newY - editableObject.centerY, newX - editableObject.centerX);
                                    h.x = editableObject.centerX + editableObject.radius * Math.cos(angle);
                                    h.y = editableObject.centerY + editableObject.radius * Math.sin(angle);
                                }
                            } else if (editableObject.type === 'spline') {
                                editableObject.points[h.originalIndex] = { x: newX, y: newY };
                            }
                            // Add logic for other editable types (rectangle, arc, ellipse, polygon, star)
                        } 
                    });
                } else if (isDraggingObject && !editModeActive && dragStartMousePos_World) { 
                    const dX = mousePosWorld.x - dragStartMousePos_World.x; 
                    const dY = mousePosWorld.y - dragStartMousePos_World.y;
                    
                    objects.forEach(obj => {
                        if (selectedObjectIds.includes(obj.id) && dragStartObjectPositions.has(obj.id)) {
                            const oP = dragStartObjectPositions.get(obj.id); 
                            if(obj.type==='line'){obj.startX=oP.startX+dX;obj.startY=oP.startY+dY;obj.endX=oP.endX+dX;obj.endY=oP.endY+dY;}
                            else if(obj.type==='circle'){obj.centerX=oP.centerX+dX;obj.centerY=oP.centerY+dY;} 
                            else if(obj.type==='arc' || obj.type==='arcCenterStartEnd'){ 
                                obj.centerX = oP.centerX + dX; obj.centerY = oP.centerY + dY;
                                if (obj.type === 'arcCenterStartEnd' && obj.pStart && obj.pEnd && obj.pCenter) { 
                                    obj.pCenter.x = oP.pCenterX + dX; obj.pCenter.y = oP.pCenterY + dY;
                                    obj.pStart.x = oP.pStartX + dX;   obj.pStart.y = oP.pStartY + dY;
                                    obj.pEnd.x = oP.pEndX + dX;       obj.pEnd.y = oP.pEndY + dY;
                                    obj.startAngle = Math.atan2(obj.pStart.y - obj.centerY, obj.pStart.x - obj.centerX);
                                    obj.endAngle = Math.atan2(obj.pEnd.y - obj.centerY, obj.pEnd.x - obj.centerX);
                                } else if (obj.type === 'arc' && obj.p1 && obj.p2 && obj.p3){ 
                                    obj.p1.x = oP.p1x + dX; obj.p1.y = oP.p1y + dY;
                                    obj.p2.x = oP.p2x + dX; obj.p2.y = oP.p2y + dY;
                                    obj.p3.x = oP.p3x + dX; obj.p3.y = oP.p3y + dY;
                                    const newArcParams = calculateArcParameters(obj.p1, obj.p2, obj.p3);
                                    if(newArcParams) {
                                        obj.centerX = newArcParams.centerX; obj.centerY = newArcParams.centerY;
                                        obj.radius = newArcParams.radius; obj.startAngle = newArcParams.startAngle;
                                        obj.endAngle = newArcParams.endAngle; obj.clockwise = newArcParams.clockwise;
                                    }
                                }
                                if(oP.radius) obj.radius = oP.radius; 
                            }
                            else if(obj.type==='spline'){obj.points=oP.points.map(p=>({x:p.x+dX,y:p.y+dY}));}
                            else if(obj.type==='point') { obj.x = oP.x + dX; obj.y = oP.y + dY; }
                            else if(obj.type==='rectangle') { obj.x = oP.x + dX; obj.y = oP.y + dY; } 
                            else if(obj.type==='ellipse') { obj.centerX = oP.centerX + dX; obj.centerY = oP.centerY + dY; } 
                            else if(obj.type==='hexagon' || obj.type==='star') {
                                obj.centerX = oP.centerX + dX; obj.centerY = oP.centerY + dY;
                                obj.points = oP.points.map(p => ({x: p.x + dX, y: p.y + dY}));
                            }
                        }
                    });
                    dimensions.forEach(dim => {
                        if (selectedDimensionIds.includes(dim.id) && dragStartDimensionData.has(dim.id)) {
                            const oD = dragStartDimensionData.get(dim.id);
                            if (dim.type === 'dimHorizontal') {
                                dim.p1.x = oD.p1x + dX; dim.p1.y = oD.p1y + dY;
                                dim.p2.x = oD.p2x + dX; dim.p2.y = oD.p2y + dY;
                                dim.offsetY = oD.offsetY + dY;
                            } else if (dim.type === 'dimVertical') {
                                dim.p1.x = oD.p1x + dX; dim.p1.y = oD.p1y + dY;
                                dim.p2.x = oD.p2x + dX; dim.p2.y = oD.p2y + dY;
                                dim.offsetX = oD.offsetX + dX;
                            } else if (dim.type === 'dimRadius') {
                                dim.center.x = oD.centerX + dX; dim.center.y = oD.centerY + dY;
                                dim.pointOnCircle.x = oD.pointX + dX; dim.pointOnCircle.y = oD.pointY + dY;
                                dim.textPos.x = oD.textX + dX; dim.textPos.y = oD.textY + dY;
                            }
                        }
                    });

                } else if (currentTool === 'trim' && trimState.phase === 3 && trimState.objectToTrimId) {
                    const rawMouseForTrimPreview = screenToWorld(event.clientX - canvas.getBoundingClientRect().left, event.clientY - canvas.getBoundingClientRect().top);
                    trimState.previewSegment = getTrimPreviewSegment(rawMouseForTrimPreview);
                } else if (currentTool === 'extend' && extendState.objectToExtendId && !extendState.boundaryId) {
                    updateExtendPreview();
                }

                 if (isPanning || isDraggingObject || drawing || isDraggingControlPoint ||
                    (currentTool === 'offset' && objectToOffset) ||
                    (currentTool === 'trim' && trimState.phase === 3) ||
                    (currentTool === 'extend' && extendState.objectToExtendId) ||
                    (transformState.active && transformState.dragStartPoint) || 
                    currentSnap || 
                    (distance(mousePosWorld, prevMousePosWorld) > 1e-6 / scale && !currentSnap) 
                ) {
                    redrawCanvas();
                }
                updateToolStatusAndCursor(); 
            });

            canvas.addEventListener('mouseup', (e) => {
                if((e.button===1 || (e.button === 0 && e.altKey)) && isPanning) isPanning=false; 
                if(e.button===0){ 
                    if (transformState.active && transformState.dragStartPoint) { 
                        handleTransformMouseUp(e);
                    }
                    else if(isDraggingObject) { 
                        isDraggingObject=false;
                        dragStartObjectPositions.clear();
                        dragStartDimensionData.clear();
                    }
                    else if(isDraggingControlPoint) { 
                        isDraggingControlPoint=false; 
                        dragStartHandlePositions.clear();
                    }
                }
                redrawCanvas(); updateToolStatusAndCursor();
            });

            canvas.addEventListener('mouseleave', (e) => { 
                if(isPanning) isPanning=false;
                if (transformState.active && transformState.dragStartPoint) { 
                    handleTransformMouseUp(e); 
                }
                else if(isDraggingObject && !editModeActive) {
                     isDraggingObject=false;
                     dragStartObjectPositions.clear();
                     dragStartDimensionData.clear();
                }
                else if(isDraggingControlPoint && editModeActive) { isDraggingControlPoint=false; dragStartHandlePositions.clear(); }
                currentSnap = null; 
                redrawCanvas(); updateToolStatusAndCursor();
            });
            function resetSplineDrawingState(doSaveState = true){
                if (doSaveState && currentSplinePoints.length > 0 && drawing) saveStateForUndo("Cancelar Spline");
                currentSplinePoints=[];drawing=false; currentSnap = null;
            }
            function finalizeSpline(){
                if (currentTool !=='spline' || !drawing || editModeActive) return;
                let isValid = false; const len = currentSplinePoints.length;
                if (currentSplineInterpolation === 'linear' || currentSplineInterpolation === 'cardinal' || currentSplineInterpolation === 'catmull-rom') {
                    if (len >= 2) isValid = true;
                } else if (currentSplineInterpolation === 'bezier') {
                    if (len >= 4 && (len - 1) % 3 === 0) isValid = true;
                }
                if (isValid) {
                    saveStateForUndo("Crear Spline");
                    addCreatedObject({ type:'spline', points:JSON.parse(JSON.stringify(currentSplinePoints)), interpolationType:currentSplineInterpolation});
                }
                else if (len > 0) { console.warn(`Spline (${currentSplineInterpolation}) no válida con ${len} puntos.`); }
                resetSplineDrawingState(false); 
                redrawCanvas(); updateToolStatusAndCursor();
            }
            function cancelSplineDrawing(doSaveState = true){
                if (currentTool !=='spline' || !drawing || editModeActive) return;
                resetSplineDrawingState(doSaveState); 
                redrawCanvas(); updateToolStatusAndCursor();
            }

            snapGridBtn.addEventListener('click', () => { 
                snapToGridEnabled = !snapToGridEnabled; 
                snapGridBtn.classList.toggle('active', snapToGridEnabled);
                currentSnap = null; 
                const canvasRect = canvas.getBoundingClientRect();
                const pseudoEvent = new MouseEvent('mousemove', { clientX: lastKnownMouseScreenPos.x + canvasRect.left, clientY: lastKnownMouseScreenPos.y + canvasRect.top });
                mousePosWorld = getMouseWorldPositionWithAids(pseudoEvent);
                redrawCanvas(); 
            });
            orthoModeBtn.addEventListener('click', () => { 
                orthoModeEnabled = !orthoModeEnabled;
                orthoModeBtn.classList.toggle('active', orthoModeEnabled);
                currentSnap = null; 
                const canvasRect = canvas.getBoundingClientRect();
                const pseudoEvent = new MouseEvent('mousemove', { clientX: lastKnownMouseScreenPos.x + canvasRect.left, clientY: lastKnownMouseScreenPos.y + canvasRect.top });
                mousePosWorld = getMouseWorldPositionWithAids(pseudoEvent);
                redrawCanvas(); 
            });
            [refEndpointCb, refMidpointCb, refCenterCb, refQuadrantCb, refIntersectionCb, refTangentCb, refNearestCb].forEach(cb => {
                cb.addEventListener('change', () => {
                    currentSnap = null; 
                    const canvasRect = canvas.getBoundingClientRect();
                    const lastMouseEvent = new MouseEvent('mousemove', { clientX: lastKnownMouseScreenPos.x + canvasRect.left, clientY: lastKnownMouseScreenPos.y + canvasRect.top });
                    mousePosWorld = getMouseWorldPositionWithAids(lastMouseEvent);
                    redrawCanvas();
                });
            });
            splineInterpolationSelect.addEventListener('change', function(){ 
                if (drawing && currentTool==='spline' && currentSplinePoints.length>0) finalizeSpline(); 
                currentSplineInterpolation = this.value;
                if (currentTool==='spline' && !editModeActive) redrawCanvas(); 
                updateToolStatusAndCursor();
            });
            if(editPointsBtn) editPointsBtn.addEventListener('click', () => { 
                currentSnap = null; 
                if (editModeActive) exitEditMode();
                else if (selectedObjectIds.length === 1 && currentTool === 'select') {
                    const sO = objects.find(obj => obj.id === selectedObjectIds[0]);
                    if (sO && ['line','circle','spline', 'point', 'rectangle', 'arc', 'arcCenterStartEnd', 'ellipse', 'hexagon', 'star'].includes(sO.type)) enterEditMode(sO);
                }
            });

            offsetDistanceInput.addEventListener('input', updateOffsetPreview);
            offsetLeftBtn.addEventListener('click', () => setOffsetSideUI('left'));
            offsetRightBtn.addEventListener('click', () => setOffsetSideUI('right'));
            offsetBothBtn.addEventListener('click', () => setOffsetSideUI('both'));

            function setTool(tN) { 
                exitAllToolModes(tN); 
                const multiStepDrawingTools = ['spline', 'arcCenterStartEnd', 'ellipse'];
                if (multiStepDrawingTools.includes(currentTool) && drawing && tN !== currentTool) { if (currentTool === 'spline') finalizeSpline(); } 
                else if (!multiStepDrawingTools.includes(tN) || !drawing) { if (!['line', 'circle', 'rectangle', 'arc', 'arcCenterStartEnd', 'ellipse', 'hexagon', 'star', 'polygon'].includes(tN) || (tN === 'arc' && !startPoint && !definingPoint2) || (tN === 'arcCenterStartEnd' && !arcCenterPoint && !startPoint) ) { startPoint = null; definingPoint2 = null; } }
                if (tN !== 'arcCenterStartEnd') arcCenterPoint = null;
                if (tN !== 'ellipse') { ellipseCenter = null; ellipseRadiusXPoint = null; }
                if (tN !== 'spline') currentSplinePoints = []; 
                if (tN !== 'select' && !tN.startsWith('edit_points_active') && tN !== 'offset' && tN !== 'trim' && tN !== 'extend' && tN !== 'rotate' && tN !== 'scale') { if (tN === 'dimRadius') { if (!getSelectedCircleForRadiusDim()) selectedObjectIds = []; } else { selectedObjectIds = []; } selectedDimensionIds = []; } 
                else if (tN === 'offset' || tN === 'trim' || tN === 'extend') { selectedObjectIds = [];  selectedDimensionIds = []; }
                
                currentTool = tN; 
                if(tN === 'polygon') starNumPoints = 6; 
                else if (tN === 'star') starNumPoints = 5; 
                currentSnap = null; 
                if (['spline', 'arcCenterStartEnd', 'ellipse'].includes(tN)) { drawing = true; if(tN === 'spline') currentSplineInterpolation = splineInterpolationSelect.value; } 
                else { drawing = false; }
                if (tN === 'dimRadius' && getSelectedCircleForRadiusDim()) { drawing = true; }

                updateToolStatusAndCursor();
                 // Actualizar select de capa de objeto seleccionado
                if (selectedObjectIds.length > 0) {
                    selectedObjectLayerSelect.disabled = false;
                    applyLayerToSelectionBtn.disabled = false;
                    const firstSelectedObject = objects.find(obj => obj.id === selectedObjectIds[0]);
                    if (firstSelectedObject && firstSelectedObject.layerId !== undefined) {
                        selectedObjectLayerSelect.value = firstSelectedObject.layerId;
                    } else if (firstSelectedObject) {
                         selectedObjectLayerSelect.value = currentLayerId;
                    }
                } else {
                    selectedObjectLayerSelect.disabled = true;
                    applyLayerToSelectionBtn.disabled = true;
                    selectedObjectLayerSelect.value = currentLayerId; // Mostrar capa activa si no hay selección
                }
                
                const canvasRect = canvas.getBoundingClientRect();
                const pseudoEvent = new MouseEvent('mousemove', { clientX: lastKnownMouseScreenPos.x + canvasRect.left, clientY: lastKnownMouseScreenPos.y + canvasRect.top });
                mousePosWorld = getMouseWorldPositionWithAids(pseudoEvent);
                redrawCanvas();
            }

            selectToolBtn.addEventListener('click', () => setTool('select'));
            lineToolBtn.addEventListener('click', () => setTool('line'));
            circleToolBtn.addEventListener('click', () => setTool('circle'));
            arcToolBtn.addEventListener('click', () => setTool('arc')); 
            arcCenterStartEndToolBtn.addEventListener('click', () => setTool('arcCenterStartEnd')); 
            splineToolBtn.addEventListener('click', () => setTool('spline'));
            pointToolBtn.addEventListener('click', () => setTool('point'));
            rectangleToolBtn.addEventListener('click', () => setTool('rectangle'));
            ellipseToolBtn.addEventListener('click', () => setTool('ellipse'));
            polygonToolBtn.addEventListener('click', () => { starNumPoints = 6; setTool('polygon'); }); 
            starToolBtn.addEventListener('click', () => { starNumPoints = 5; setTool('star'); }); 
            
            rotateToolBtn.addEventListener('click', () => activateTransformTool('rotate'));
            scaleToolBtn.addEventListener('click', () => activateTransformTool('scale'));

            offsetToolBtn.addEventListener('click', () => setTool('offset'));
            trimToolBtn.addEventListener('click', () => setTool('trim'));
            extendToolBtn.addEventListener('click', () => setTool('extend'));
            
            dimHorizontalBtn.addEventListener('click', () => setTool('dimHorizontal')); 
            dimVerticalBtn.addEventListener('click', () => setTool('dimVertical'));     
            dimRadiusBtn.addEventListener('click', () => setTool('dimRadius'));         


            undoBtn.addEventListener('click', undo);
            redoBtn.addEventListener('click', redo);

            function resetApplicationState(resetView = true) { 
                exitAllToolModes(); objects = []; selectedObjectIds = []; dimensions = []; selectedDimensionIds = [];
                drawing = false; startPoint = null; currentSplinePoints = []; definingPoint2 = null; arcCenterPoint = null; ellipseCenter = null; ellipseRadiusXPoint = null;
                resetTransformStateOnly(); hideTransformValues();
                isDraggingObject = false; isPanning = false; nextObjectId = 1; nextDimensionId = 1;
                objectToOffset = null; offsetPreviewObjects = []; resetTrimState(); resetExtendState();
                if (editModeActive) exitEditMode(); currentSnap = null; internalClipboard = []; 
                // Reset layers to default if not just resetting view for loading
                if (resetView) {
                    layers = [
                        { id: 0, name: "Capa 0", color: getComputedStyle(document.documentElement).getPropertyValue('--text-primary').trim(), isVisible: true, isLocked: false },
                        { id: 1, name: "Capa Roja", color: "#ff0000", isVisible: true, isLocked: false },
                        { id: 2, name: "Capa Verde", color: "#00ff00", isVisible: true, isLocked: false },
                        { id: 3, name: "Capa Azul", color: "#0000ff", isVisible: true, isLocked: false },
                    ];
                    currentLayerId = 0;
                    nextLayerId = layers.length;
                    updateLayersUI();
                }

                if (resetView) { scale = 1.0; const dpr = window.devicePixelRatio||1; offsetCanvas.x = (canvas.width/dpr)/2; offsetCanvas.y = (canvas.height/dpr)/2; }
                undoStack = []; redoStack = []; updateUndoRedoButtons();
            }
            clearBtn.addEventListener('click', () => { 
                saveStateForUndo("Limpiar Lienzo"); 
                resetApplicationState(true); 
                setTool('select'); 
                redrawCanvas(); 
                updateToolStatusAndCursor(); 
            });
            saveFileBtn.addEventListener('click', () => { 
                const drawingData = { 
                    objects: objects, 
                    dimensions: dimensions, 
                    layers: layers, 
                    currentLayerId: currentLayerId, 
                    nextLayerId: nextLayerId,
                    nextObjectId: nextObjectId, 
                    nextDimensionId: nextDimensionId, 
                    view: { 
                        scale: scale, 
                        offsetCanvasX: offsetCanvas.x, 
                        offsetCanvasY: offsetCanvas.y 
                    }, 
                };
                const jsonString = JSON.stringify(drawingData, null, 2); 
                const blob = new Blob([jsonString], {type: 'application/json'});
                const url = URL.createObjectURL(blob); 
                const a = document.createElement('a');
                a.href = url; 
                a.download = 'xoconodo_drawing.xoccad'; 
                document.body.appendChild(a);
                a.click(); 
                document.body.removeChild(a); 
                URL.revokeObjectURL(url);
                toolStatusDiv.textContent = "Dibujo guardado como xoconodo_drawing.xoccad";
            });
            openFileBtn.addEventListener('click', () => { fileInput.click(); });
            fileInput.addEventListener('change', (event) => { 
                const file = event.target.files[0]; if (!file) return;
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const loadedData = JSON.parse(e.target.result); 
                        resetApplicationState(false); 
                        objects = loadedData.objects || []; 
                        dimensions = loadedData.dimensions || [];
                        
                        if (loadedData.layers && loadedData.layers.length > 0) {
                            layers = loadedData.layers;
                            currentLayerId = loadedData.currentLayerId !== undefined ? loadedData.currentLayerId : 0;
                            nextLayerId = loadedData.nextLayerId !== undefined ? loadedData.nextLayerId : layers.length;
                        } else { 
                            layers = [ { id: 0, name: "Capa 0", color: getComputedStyle(document.documentElement).getPropertyValue('--text-primary').trim(), isVisible: true, isLocked: false }];
                            currentLayerId = 0;
                            nextLayerId = 1;
                        }
                        objects.forEach(obj => { if (obj.layerId === undefined) { obj.layerId = 0; } });

                        nextObjectId = loadedData.nextObjectId || 1; 
                        nextDimensionId = loadedData.nextDimensionId || 1;
                        if (loadedData.view) { 
                            scale = loadedData.view.scale || 1.0; 
                            offsetCanvas.x = loadedData.view.offsetCanvasX || (canvas.width / (window.devicePixelRatio || 1)) / 2; 
                            offsetCanvas.y = loadedData.view.offsetCanvasY || (canvas.height / (window.devicePixelRatio || 1)) / 2;
                        } else { 
                            scale = 1.0; 
                            const dpr = window.devicePixelRatio || 1; 
                            offsetCanvas.x = (canvas.width/dpr)/2; 
                            offsetCanvas.y = (canvas.height/dpr)/2; 
                        }
                        internalClipboard = []; 
                        undoStack = []; 
                        redoStack = []; 
                        updateUndoRedoButtons(); 
                        saveStateForUndo("Abrir archivo"); 
                        setTool('select'); 
                        updateLayersUI(); 
                        redrawCanvas(); 
                        updateToolStatusAndCursor(); 
                        toolStatusDiv.textContent = `Dibujo '${file.name}' cargado.`;
                    } catch (error) { 
                        console.error("Error al abrir:", error); 
                        alert(`Error: ${error.message}`); 
                        toolStatusDiv.textContent = "Error al cargar."; 
                    } 
                    finally { fileInput.value = null; }
                }; 
                reader.readAsText(file);
            });

            document.addEventListener('keydown', (e) => {
                if (isInputFocused()) return; 
                if (transformState.active) { if (handleTransformKeydown(e)) return; }
                if (e.ctrlKey || e.metaKey) { 
                    if (e.key.toLowerCase() === 'c') { e.preventDefault(); copySelection(); return; }
                    if (e.key.toLowerCase() === 'v') { e.preventDefault(); pasteFromClipboard(); return; }
                    if (e.key.toLowerCase() === 'z') { e.preventDefault(); undo(); return; }
                    if (e.key.toLowerCase() === 'y') { e.preventDefault(); redo(); return; }
                }
                 if ((e.key==='Delete'||e.key==='Backspace')) {
                    let changed = false; 
                    let itemsWereSelected = selectedObjectIds.length > 0 || selectedDimensionIds.length > 0 || (editModeActive && editableObject);
                    if (itemsWereSelected) { saveStateForUndo("Eliminar selección"); }
                    if (editModeActive && editableObject) { 
                        objects = objects.filter(o => o.id !== editableObject.id); 
                        selectedObjectIds=[]; 
                        exitEditMode(); 
                        changed = true;
                    } else { 
                        if (selectedObjectIds.length > 0) {
                            objects = objects.filter(o => !selectedObjectIds.includes(o.id));
                            if (transformState.active) {
                                const remainingTransformObjects = transformState.objectsToTransform.filter(id => objects.some(o => o.id === id));
                                if (remainingTransformObjects.length === 0) {
                                    exitTransformTool(false); setTool('select');
                                } else {
                                    transformState.objectsToTransform = remainingTransformObjects;
                                    if(transformState.center) { 
                                       transformState.center = calculateCentroid(transformState.objectsToTransform);
                                       if (!transformState.center) exitTransformTool(false); 
                                    }
                                }
                            }
                            selectedObjectIds = []; 

                            if (objectToOffset && !objects.find(o => o.id === objectToOffset.id)) { 
                                objectToOffset = null; 
                                offsetPreviewObjects = []; 
                            }
                            trimState.boundaries = trimState.boundaries.filter(id => objects.some(o => o.id === id));
                            if (currentTool === 'trim') { 
                                if (!objects.some(o => o.id === trimState.objectToTrimId)) { 
                                    trimState.objectToTrimId = null;
                                    trimState.intersections = [];
                                    trimState.previewSegment = null;
                                    trimState.phase = trimState.boundaries.length > 0 ? 1 : 0; 
                                } else if (trimState.boundaries.length === 0 && !trimState.objectToTrimId) {
                                     trimState.phase = 0; 
                                }
                            }
                            if (extendState.objectToExtendId && !objects.find(o => o.id === extendState.objectToExtendId)) {
                                resetExtendState();
                            }
                            if (extendState.boundaryId && !objects.some(o => o.id === extendState.boundaryId)) {
                                extendState.boundaryId = null; 
                            }
                            if (currentTool === 'extend' && extendState.objectToExtendId) {
                                updateExtendPreview(); 
                            }
                            changed = true;
                        }
                        if (selectedDimensionIds.length > 0) {
                            dimensions = dimensions.filter(d => !selectedDimensionIds.includes(d.id));
                            selectedDimensionIds = [];
                            changed = true;
                        }
                    }
                    if (changed) { currentSnap = null; redrawCanvas(); updateToolStatusAndCursor(); }
                }
                if (e.key === 'Escape' && !isInputFocused()) {
                    currentSnap = null; 
                    if (isDraggingControlPoint) { 
                        if (undoStack.length > 0 && undoStack[undoStack.length -1].description === "Mover punto de control") {
                           undo(); 
                        }
                        isDraggingControlPoint = false; 
                        dragStartHandlePositions.clear();
                    }
                    else if (editModeActive) exitEditMode(); 
                    else if (currentTool === 'offset' && objectToOffset) { objectToOffset = null; offsetPreviewObjects = []; selectedObjectIds = []; hideFloatingPanel(offsetOptionsPanel); } 
                    else if (currentTool === 'trim') { 
                        if (trimState.phase === 3 || trimState.phase === 2) { trimState.objectToTrimId = null; trimState.intersections = []; trimState.previewSegment = null; trimState.phase = (trimState.boundaries.length > 0) ? 1 : 0; selectedObjectIds = [...trimState.boundaries]; } 
                        else if (trimState.phase === 1) { resetTrimState(); selectedObjectIds = []; } 
                        else { setTool('select'); } 
                    }
                    else if (currentTool === 'extend') { if (extendState.objectToExtendId) { resetExtendState(); selectedObjectIds = []; } else { setTool('select'); } }
                    else if (currentTool==='spline'&&drawing) { cancelSplineDrawing(); hideFloatingPanel(splineOptionsPanel); }
                    else if ((['arc', 'arcCenterStartEnd', 'ellipse', 'hexagon', 'star', 'polygon', 'rectangle'].includes(currentTool) || currentTool.startsWith('dim')) && drawing) { drawing=false; startPoint=null; definingPoint2=null; arcCenterPoint = null; ellipseCenter = null; ellipseRadiusXPoint = null; }
                    else if (drawing) { drawing=false; startPoint=null; } 
                    else if (isDraggingObject) { 
                        if (undoStack.length > 0 && (undoStack[undoStack.length -1].description === "Mover Objeto(s)" || undoStack[undoStack.length -1].description === "Mover Cota")) {
                           undo(); 
                        }
                        isDraggingObject = false; 
                        dragStartObjectPositions.clear();
                        dragStartDimensionData.clear();
                    }
                    else if (isPanning) isPanning = false; 
                    else if (selectedObjectIds.length > 0 || selectedDimensionIds.length > 0) { selectedObjectIds = []; selectedDimensionIds = []; }
                    else {
                        if (objectSnapsPanel.classList.contains('visible')) hideFloatingPanel(objectSnapsPanel);
                        else if (layersPanel.classList.contains('visible')) hideFloatingPanel(layersPanel);
                        else if (codeEditorPanel.style.display !== 'none') codeEditorPanel.style.display = 'none';
                        else setTool('select'); 
                    }
                    redrawCanvas(); updateToolStatusAndCursor();
                }
                if (e.key === 'Enter' && !isInputFocused()) {
                    if (currentTool==='spline'&&drawing&&!editModeActive) { finalizeSpline(); hideFloatingPanel(splineOptionsPanel); }
                    else if (editModeActive) exitEditMode(); 
                    else if (currentTool === 'offset' && objectToOffset && offsetPreviewObjects.length > 0) { applyCurrentOffset(); hideFloatingPanel(offsetOptionsPanel); objectToOffset = null; }
                    else if (currentTool === 'trim' && trimState.phase === 1 && trimState.boundaries.length > 0) { trimState.phase = 2; selectedObjectIds = [...trimState.boundaries]; }
                     else if (currentTool === 'extend' && extendState.objectToExtendId && extendState.previewPoint && !extendState.boundaryId) { if (extendState.possibleExtensions.length > 0) { extendState.boundaryId = extendState.possibleExtensions[0].boundaryId; applyActualExtend(); } }
                    currentSnap = null; redrawCanvas(); updateToolStatusAndCursor(); 
                }
            });
           
            document.addEventListener('keyup', (e) => { 
                if (transformState.active) { if (handleTransformKeyup(e)) return; }
            });
            
            function isInputFocused() {
                return document.activeElement && (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'SELECT' || document.activeElement.classList.contains('ace_text-input'));
            }

            // --- Initialization ---
            function initAll() {
                initTransformTools(); 
                splineInterpolationSelect.value = currentSplineInterpolation;
                setOffsetSideUI(offsetSide); 
                
                // Asegurar que la capa 0 tenga el color del tema al iniciar
                const layer0 = layers.find(l => l.id === 0);
                if (layer0) { // Actualizar color de Capa 0 según el tema inicial
                    layer0.color = getComputedStyle(document.documentElement).getPropertyValue('--text-primary').trim();
                }


                document.documentElement.style.setProperty('--grid-size', GRID_SIZE + 'px');
                applyTheme(); 
                
                resizeCanvas(); 
                updateToolStatusAndCursor(); 
                updateUndoRedoButtons();
                snapGridBtn.classList.toggle('active', snapToGridEnabled);
                orthoModeBtn.classList.toggle('active', orthoModeEnabled);
                setTool('select'); 
                
                applyCanvasPattern(); 
                updateLayersUI(); 
                // initCodeEditor se llama ahora al abrir el panel, no aquí.
                redrawCanvas(); 

                saveStateForUndo("Estado inicial");
                updateUndoRedoButtons(); 
            }
            
            initAll(); 
        });
    </script>
</body>
</html>
